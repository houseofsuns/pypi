<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Python WebDAV Client 3=========[![Build Status](https://travis-ci.com/ezhov-evgeny/webdav-client-python-3.svg?branch=develop)](https://travis-ci.com/ezhov-evgeny/webdav-client-python-3)[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=ezhov-evgeny_webdav-client-python-3&amp;metric=alert_status)](https://sonarcloud.io/dashboard?id=ezhov-evgeny_webdav-client-python-3)[![Coverage](https://sonarcloud.io/api/project_badges/measure?project=ezhov-evgeny_webdav-client-python-3&amp;metric=coverage)](https://sonarcloud.io/dashboard?id=ezhov-evgeny_webdav-client-python-3)[![PyPI](https://img.shields.io/pypi/v/webdavclient3)](https://pypi.org/project/webdavclient3/) ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/webdavclient3)  Package webdavclient3 based on https://github.com/designerror/webdav-client-python but uses `requests` instead of `PyCURL`.It provides easy way to work with WebDAV-servers.Installation------------```bash$ pip install webdavclient3```Sample Usage------------```pythonfrom webdav3.client import Clientoptions = { 'webdav_hostname': &quot;https://webdav.server.ru&quot;, 'webdav_login':    &quot;login&quot;, 'webdav_password': &quot;password&quot;}client = Client(options)client.verify = False # To not check SSL certificates (Default = True)client.session.proxies(...) # To set proxy directly into the session (Optional)client.session.auth(...) # To set proxy auth directly into the session (Optional)client.execute_request(&quot;mkdir&quot;, 'directory_name')```Webdav API==========Webdav API is a set of webdav actions of work with cloud storage. This set includes the following actions:`check`, `free`, `info`, `list`, `mkdir`, `clean`, `copy`, `move`, `download`, `upload`, `publish` and `unpublish`.**Configuring the client**Required key is host name or IP address of the WevDAV-server with param name `webdav_hostname`.  For authentication in WebDAV server use `webdav_login`, `webdav_password`.  For an anonymous login do not specify auth properties.```pythonfrom webdav3.client import Clientoptions = { 'webdav_hostname': &quot;https://webdav.server.ru&quot;, 'webdav_login':    &quot;login&quot;, 'webdav_password': &quot;password&quot;}client = Client(options)```If your server does not support `HEAD` method or there are other reasons to override default WebDAV methods for actions use a dictionary option `webdav_override_methods`. The key should be in the following list: `check`, `free`, `info`, `list`, `mkdir`, `clean`, `copy`, `move`, `download`, `upload`, `publish` and `unpublish`. The value should a string name of WebDAV method, for example `GET`. ```pythonfrom webdav3.client import Clientoptions = { 'webdav_hostname': &quot;https://webdav.server.ru&quot;, 'webdav_login':    &quot;login&quot;, 'webdav_password': &quot;password&quot;, 'webdav_override_methods': {            'check': 'GET'        }}client = Client(options)```For configuring a requests timeout you can use an option `webdav_timeout` with int value in seconds, by default the timeout is set to 30 seconds.```pythonfrom webdav3.client import Clientoptions = { 'webdav_hostname': &quot;https://webdav.server.ru&quot;, 'webdav_login':    &quot;login&quot;, 'webdav_password': &quot;password&quot;, 'webdav_timeout': 30}client = Client(options)```When a proxy server you need to specify settings to connect through it.```pythonfrom webdav3.client import Clientoptions = { 'webdav_hostname': &quot;https://webdav.server.ru&quot;, 'webdav_login':    &quot;w_login&quot;, 'webdav_password': &quot;w_password&quot;,  'proxy_hostname':  &quot;http://127.0.0.1:8080&quot;, 'proxy_login':     &quot;p_login&quot;, 'proxy_password':  &quot;p_password&quot;}client = Client(options)```If you want to use the certificate path to certificate and private key is defined as follows:```pythonfrom webdav3.client import Clientoptions = { 'webdav_hostname': &quot;https://webdav.server.ru&quot;, 'webdav_login':    &quot;w_login&quot;, 'webdav_password': &quot;w_password&quot;, 'cert_path':       &quot;/etc/ssl/certs/certificate.crt&quot;, 'key_path':        &quot;/etc/ssl/private/certificate.key&quot;}client = Client(options)```Or you want to limit the speed or turn on verbose mode:```pythonoptions = { ... 'recv_speed' : 3000000, 'send_speed' : 3000000, 'verbose'    : True}client = Client(options)```recv_speed: rate limit data download speed in Bytes per second. Defaults to unlimited speed.  send_speed: rate limit data upload speed in Bytes per second. Defaults to unlimited speed.  verbose:    set verbose mode on/off. By default verbose mode is off.Also if your server does not support `check` it is possible to disable it:```pythonoptions = { ... 'disable_check': True}client = Client(options)```By default, checking of remote resources is enabled.For configuring chunk size of content downloading use `chunk_size` param, by default it is `65536````pythonoptions = { ... 'chunk_size': 65536}client = Client(options)```**Synchronous methods**```python# Checking existence of the resourceclient.check(&quot;dir1/file1&quot;)client.check(&quot;dir1&quot;)``````python# Get information about the resourceclient.info(&quot;dir1/file1&quot;)client.info(&quot;dir1/&quot;)``````python# Check free spacefree_size = client.free()``````python# Get a list of resourcesfiles1 = client.list()files2 = client.list(&quot;dir1&quot;)files3 = client.list(&quot;dir1&quot;, get_info=True) # returns a list of dictionaries with files details``````python# Create directoryclient.mkdir(&quot;dir1/dir2&quot;)``````python# Delete resourceclient.clean(&quot;dir1/dir2&quot;)``````python# Copy resourceclient.copy(remote_path_from=&quot;dir1/file1&quot;, remote_path_to=&quot;dir2/file1&quot;)client.copy(remote_path_from=&quot;dir2&quot;, remote_path_to=&quot;dir3&quot;)``````python# Move resourceclient.move(remote_path_from=&quot;dir1/file1&quot;, remote_path_to=&quot;dir2/file1&quot;)client.move(remote_path_from=&quot;dir2&quot;, remote_path_to=&quot;dir3&quot;)``````python# Download a resourceclient.download_sync(remote_path=&quot;dir1/file1&quot;, local_path=&quot;~/Downloads/file1&quot;)client.download_sync(remote_path=&quot;dir1/dir2/&quot;, local_path=&quot;~/Downloads/dir2/&quot;)``````python# Upload resourceclient.upload_sync(remote_path=&quot;dir1/file1&quot;, local_path=&quot;~/Documents/file1&quot;)client.upload_sync(remote_path=&quot;dir1/dir2/&quot;, local_path=&quot;~/Documents/dir2/&quot;)``````python# Publish the resourcelink = client.publish(&quot;dir1/file1&quot;)link = client.publish(&quot;dir2&quot;)``````python# Unpublish resourceclient.unpublish(&quot;dir1/file1&quot;)client.unpublish(&quot;dir2&quot;)``````python# Exception handlingfrom webdav3.client import WebDavExceptiontry:...except WebDavException as exception:...``````python# Get the missing filesclient.pull(remote_directory='dir1', local_directory='~/Documents/dir1')``````python# Send missing filesclient.push(remote_directory='dir1', local_directory='~/Documents/dir1')```**Asynchronous methods**```python# Load resourcekwargs = { 'remote_path': &quot;dir1/file1&quot;, 'local_path':  &quot;~/Downloads/file1&quot;, 'callback':    callback}client.download_async(**kwargs)kwargs = { 'remote_path': &quot;dir1/dir2/&quot;, 'local_path':  &quot;~/Downloads/dir2/&quot;, 'callback':    callback}client.download_async(**kwargs)``````python# Unload resourcekwargs = { 'remote_path': &quot;dir1/file1&quot;, 'local_path':  &quot;~/Downloads/file1&quot;, 'callback':    callback}client.upload_async(**kwargs)kwargs = { 'remote_path': &quot;dir1/dir2/&quot;, 'local_path':  &quot;~/Downloads/dir2/&quot;, 'callback':    callback}client.upload_async(**kwargs)```Resource API============Resource API using the concept of OOP that enables cloud-level resources.```python# Get a resourceres1 = client.resource(&quot;dir1/file1&quot;)``````python# Work with the resourceres1.rename(&quot;file2&quot;)res1.move(&quot;dir1/file2&quot;)res1.copy(&quot;dir2/file1&quot;)info = res1.info()res1.read_from(buffer)res1.read(local_path=&quot;~/Documents/file1&quot;)res1.read_async(local_path=&quot;~/Documents/file1&quot;, callback)res1.write_to(buffer)res1.write(local_path=&quot;~/Downloads/file1&quot;)res1.write_async(local_path=&quot;~/Downloads/file1&quot;, callback)```# For Contributors### Prepare development environment1. Install docker on your development machine1. Start WebDAV server for testing by following commands from the project's root folder or change path to `conf` dir in second command to correct:```shell scriptdocker pull bytemark/webdavdocker run -d --name webdav -e AUTH_TYPE=Basic -e USERNAME=alice -e PASSWORD=secret1234 -v conf:/usr/local/apache2/conf -p 8585:80 bytemark/webdav``` ### Code conventionPlease check your code according PEP8 Style guides.### Run tests1. Check that webdav container is started on your local machine1. Execute following command in the project's root folder:```shell scriptpython -m unittest discover -s tests```### Prepare a Pull RequestPlease use this check list before creating PR:1. You code should be formatted according PEP81. All tests should successfully pass1. Your changes shouldn't change previous default behaviour, exclude defects1. All changes are covered by tests</longdescription>
</pkgmetadata>