<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># OmnibenchmarkGenerate and manage omnibenchmark modules for open and continuous benchmarking.Each module represents a single building block of a benchmark, e.g., dataset, method, metric.Omnibenchmark-py provides a structure to generate modules and automatically run them.![](omni.svg)## InstallationYou can install **omnibenchmark** from [PyPI](https://pypi.org/project/omnibenchmark/):```shpip install omnibenchmark```The module requires Python &gt;= 3.8 and [renku &gt;= 1.5.0](https://pypi.org/project/renku/).## How to use omnibenchmarkFor detailed documentation and tutorials, check the [omnibenchmark documentation](https://omnibenchmark.readthedocs.io).### Quick startOmnibenchmark uses the `renku` platform to run open and continuous benchmarks. To contribute an independent module to one of the existing benchmarks please start by creating a new [renku project](#Create-a-new-renku-project). Each module (= renkulab project) consists of a Docker image, which defines its software environment, a dataset to store outputs and metadata, a workflow that describes how to generate outputs and input and parameter datasets with input files and parameter definitions, if they are used. Thus, each module is an independent benchmark component and can be run, used and modified independently as such. Modules are connected by importing (result) datasets from other modules as input datasets and will automatically be updated according to them.  All relevant information on how to run a specific module are stored as [`OmniObject`](#omnibenchmark-classes).The most convenient way to generate an instance of an `OmniObject` is to build it from a `config.yaml` file:``` python## modulesfrom omnibenchmark.utils.build_omni_object import get_omni_object_from_yaml## Load objectomni_obj = get_omni_object_from_yaml('src/config.yaml')```The `config.yaml` defines all module specific information as inputs, outputs, script to run the module, benchmark that the module belongs to and much more. A simple `config.yaml` file could look like this (see [The config.yaml file](#the-config.yaml-file) for more details):```sh---data:    name: &quot;module-name&quot;    title: &quot;A new module&quot;    description: &quot;A new module for omnibenchmark, e.g., a dataset, method, metric,...&quot;    keywords: [&quot;module-type-key&quot;]script: &quot;path/to/module_script&quot;outputs:    template: &quot;data/${name}/${name}_${out_name}.${out_end}&quot;    files:        counts:             end: &quot;mtx.gz&quot;        data_info:            end: &quot;json&quot;        meta:            end: &quot;json&quot;benchmark_name: &quot;an-omnibenchmark&quot;```Once you have an instance of an `OmniObject` you can check if it looks as you expected like this:```python## Check objectprint(omni_obj.__dict__)print(omni_obj.outputs.file_mapping)print(omni_obj.command.command_line)``` If all inputs, outputs and the command line call look as you expected you can run your module:```python## create output dataset that stores all result/output filesomni_obj.create_dataset()## Update inputs from other modules omni_obj.update_obj()## Run your script with all defined inputs and outputs.## This also generates a workflow description (plan) and is tracked as activity.omni_obj.run_renku()## Link output files to output dataset omni_obj.update_result_dataset()## Save and commit to gitlabrenku_save()```Once these steps ran successfully and your outputs were generated the module is ready to be [submitted to become a part of omnibenchmark](#Submit-your-module).### What is renku?[Renku](https://renkulab.io) is a platform and tools for reproducible and collaborative data analysis from the [Swiss Data Science Centre](https://datascience.ch/). Besides other functionalities, renku provides a framework to create and run data analysis projects, which come with their own Docker container, datasets and workflows. By storing the metadata of projects and datasets on a knowledge graph, renku facilitates provenance tracking and project interactions. To do so renku combines a set of microservices:- GitLab, for version control and project management- GitLFS, for file storage- Kubernetes/Docker, to manage containerized environments- Jupyter server, to provide interactive sessions- Apache Jena, to generate, store and manage triplets and the triplet store (knowledge graph) Details on how to use renku can be found in their [Documentation](https://renku.readthedocs.io/en/latest/index.html). Omnibenchmark uses renku to build and run collaborative and continuous benchmarks. #### Create a new renku projectOmnibenchmark modules are built as separate renku projects. Contributions to one of the existing benchmarks start by creating a new project using the [renku platform](https://renkulab.io). This can be done by registering directly or using a Github account, an ORCID or a Switch-EDU ID.A new project can be created by a few clicks as described [here](https://renku.readthedocs.io/en/latest/tutorials/first_steps/01_create_project.html). Templates can be chosen depending on the projects code or the Basic Python template. Project can then be populated/changed in an interactive renku session (see session tab of the project) or within the GitLab instance or clone of the project (Overview tab --&gt; View in GitLab). ### Project requirementsProject requirements can be defined by adapting the `Dockerfile` and specifying the all required R packages (with their versions) in the `install.R` file and all required python modules (with their versions) in the `requirements.txt` file. The latter needs to contain at least `omnibenchmark`. If you work in an interactive session, you need to save/commit your changes either by running `renku save` or `git add/commit/push` and close and restart the session once the new Docker image has been built. The build of the docker image is triggered automatically after committing changes, but can take a while depending on the requirments (and the runner used).### The config.yaml fileAll specific information about a benchmark component (= renkulab project) can be specified in a `config.yaml` file. Below we show an example with all standard fields and explanations to them. Many fields are optional and do not apply to all modules. All unneccessary fields can be skipped. There are further optional fields for specfic edge cases, that are described in an extra `config.yaml` file. In general, the `config.yaml` file consists of a data, an input, an output and a parameter section as well as a few extra fields to define the main benchmark script and benchmark type. Except for the data section, the other sections are optional. Multiple values can be parsed as lists.```yaml# Data section to describe the object and the associated (result) datasetdata:    # Name of the dataset    name: &quot;out_dataset&quot;    # Title of the dataset (Optional)    title: &quot;Output of an example OmniObject&quot;    # Description of the dataset (Optional)    description: &quot;This dataset is supposed to store the output files from the example omniobject&quot;    # Dataset keyword(s) to make this dataset reachable for other projects/benhcmark components    keywords: [&quot;example_dataset&quot;]# Script to be run by the workflow associated to the projectscript: &quot;path/to/method/dataset/metric/script.py&quot;# Interpreter to run the script (Optional, automatic detection)interpreter: &quot;python&quot;# Benchmark that the object is associated to.benchmark_name: &quot;omni_celltype&quot;# Orchestrator url of the benchmark (Optional, automatic detection)orchestrator: &quot;https://www.orchestrator_url.com&quot;# Input section to describe output file types. (Optional)inputs:    # Keyword to find input datasets, that shall be imported     keywords: [&quot;import_this&quot;, &quot;import_that&quot;]    # Input file types    files: [&quot;count_file&quot;, &quot;dim_red_file&quot;]    # Prefix (part of the filename is sufficient) to automatically detect file types by their names    prefix:        count_file: &quot;counts&quot;        dim_red_file: [&quot;features&quot;, &quot;genes&quot;]# Output section to describe output file types. (Optional)outputs:    # Output filetypes and their endings    files:        corrected_counts:             end: &quot;.mtx.gz&quot;        meta:            end: &quot;.json&quot;# Parameter section to describe the parameter dataset, values and filter. (Optional)parameter:    # Names of the parameter to use    names: [&quot;param1&quot;, &quot;param2&quot;]    # Keyword(s) used to import the parameter dataset    keywords: [&quot;param_dataset&quot;]    # Filter that specify limits, values or combinations to exclude    filter:        param1:            upper: 50            lower: 3            exclude: 12    param2:        &quot;path/to/file/with/parameter/combinations/to/exclude.json&quot;```Below gives specific fields that are only relevant for edge cases. These fields have their counterparts in the generated [OmniObject](#omnibenchmark-classes).Changes of the attributes of the OmniObject instance have the same effects, but come with the flexibility of running from python. ```yaml# Command to generate the workflow with (Optional, automatic detection)command_line: &quot;python path/to/method/dataset/metric/script.py --count_file data/import_this_dataset/...mtx.gz&quot;inputs:    # Datasets and manual file type specifications (automatic detection!)    input_files:        import_this_dataset:            count_file: &quot;data/import_this_dataset/import_this_dataset__counts.mtx.gz&quot;            dim_red_file: &quot;data/import_this_dataset/import_this_dataset__dim_red_file.json&quot;    # (Dataset) name that default input files belong to (Optional, automatic detection)    default: &quot;import_this_dataset&quot;    # Input dataset names that should be ignored (even if they have one of the specified input keywords assciated)    filter_names: [&quot;data1&quot;, &quot;data2&quot;]outputs:    # Template to automatically generate output filenames (Optional - recommended for advanced user only)    template: &quot;data/${name}/${name}_${unique_values}_${out_name}.${out_end}&quot;    # Variables used for automatic output filename generation (Optional - recommended for advanced user only)    template_vars:        vars1: &quot;random&quot;        vars2: &quot;variable&quot;    # Manual specification of mapping for output files and their corresponding input files and parameter values (automatic detection!)    file_mapping:        mapping1:             output_files:                corrected_counts: &quot;data/out_dataset/out_dataset_import_this__param1_10__param2_test_corrected_counts.mtx.gz&quot;                meta: &quot;data/out_dataset/out_dataset_import_this__param1_10__param2_test_meta.json&quot;        input_files:            count_file: &quot;data/import_this_dataset/import_this_dataset__counts.mtx.gz&quot;            dim_red_file: &quot;data/import_this_dataset/import_this_dataset__dim_red_file.json&quot;        parameter:            param1: 10            param2: &quot;test&quot;    # Default output files (Optional, automatic detection)    default:        corrected_counts: &quot;data/out_dataset/out_dataset_import_this__param1_10__param2_test_corrected_counts.mtx.gz&quot;        meta: &quot;data/out_dataset/out_dataset_import_this__param1_10__param2_test_meta.json&quot;parameter:    default:        param1: 10        param2: &quot;test&quot;```### Omnibenchmark classesClasses to manage omnibenchmark modules and their interactions. The main class is the [OmniObject](#omniobject), that consolidates all relevant information and functions of a module. This object has further subclasses that define inputs, outputs, commands and the workflow.---#### OmniObjectMain class to manage an omnibenchmark module. It takes the following arguments:* **`name (str)`**: Module name * **`keyword (Optional[List[str]], optional)`**: Keyword associated to the modules output dataset.* **`title (Optional[str], optional)`**: Title of the modules output dataset.* **`description (Optional[str], optional)`**: Description of the modules output dataset.* **`script (Optional[PathLike], optional)`**: Script to generate the modules workflow for.* **`command (Optional[OmniCommand], optional)`**: Workflow command - will be automatically generated if missing.* **`inputs (Optional[OmniInput], optional)`**: Definitions of the workflow inputs.* **`parameter (Optional[OmniParameter], optional)`**: Definitions of the workflow parameter.* **`outputs (Optional[OmniOutput], optional)`**: Definitions of the workflow outputs.* **`omni_plan (Optional[OmniPlan], optional)`**: The workflow description.* **`benchmark_name (Optional[str], optional)`**: Name of the associated benchmark.* **`orchestrator (Optional[str], optional)`**: Orchestrator URL of the associated benchmark. Automatic detection.* **`wflow_name (Optional[str], optional)`**: Workflow name. Will be set to the module name if none.* **`dataset_name (Optional[str], optional)`**: Dataset name. Will be set to the module name if none.The following methods can be run on an instance of an OmniObject:* **`create_dataset()`**: Creates a renku dataset with the specified attributes in the current renku project. * **`update_object()`**: Checks for new imports or updates in the input and parameter datasets. Will update object attributes accordingly.* **`run_renku()`**: Generates and updates the workflow and all output files as specified in the object.* **`update_result_dataset()`**: Updates and adds all output datasets to the dataset specified in the object.* **`clean_revert_run()`**: Clean/Remove all outputs, workflows and activities associated with the object (including KG connections).* **`check_updates()`**: Dry run option for update_object().* **`check_run()`**: Dry run option for run_renku().---#### OmniInputClass to manage inputs of an omnibenchmark module.This class has the following attributes:* **`names (List[str])`**: Names of the input filetypes* **`prefix (Optional[Mapping[str, List[str]]], optional)`**: Prefixes (or substrings) of the input filetypes.* **`input_files (Optional[Mapping[str, Mapping[str, str]]], optional)`**: Input files ordered by file types.* **`keyword (Optional[List[str]], optional)`**: Keyword to define which datasets are imported as input datasets.* **`default (Optional[str], optional)`**: Default input name (e.g., dataset).* **`filter_names (Optional[List[str]], optional)`**: Input dataset names to be ignored.* **`multi_data_matching (Optional[bool])`**: If file matching across renku datasets should be allowed (defaults to False).The following class methods can be run on an instance of an OmniInput:* **`update_inputs()`**: Method to import new and update existing input datasets and update the object accordingly---#### OmniOutputClass to manage outputs of an omnibenchmark module. This class has the following attributes:* **`name (str)`**: Name that is specific for all outputs. Typically the module name/OmniObject name.* **`out_names (List[str])`**: Names of the output file types* **`output_end (Optional[Mapping[str, str]], optional)`**: Endings of the output filetypes.* **`out_template (str, optional)`**: Template to generate output file names.* **`file_mapping (Optional[List[OutMapping]], optional)`**: Mapping of input files, parameter values and output files.* **`inputs (Optional[OmniInput], optional)`**: Object specifying all valid inputs.* **`parameter (Optional[OmniParameter], optional)`**: Object speccifying the parameter space.* **`default (Optional[Mapping], optional)`**: Default output files.* **`filter_json(Optional[str], optional)`**: Path to json file with filter combinations.* **`template_fun (Optional[Callable[..., Mapping]], optional)`**: Function to use to automatically generate output filenames.* **`template_vars (Optional[Mapping], optional)`**: Variables that are used by template_fun.The following class methods can be run on an instance of an OmniInput:* **`update_outputs()`**: Method to update the output definitions according to the objects attributes.---#### OmniParameterClass to manage parameter of an omnibenchmark module.This class has the following attributes:* **`names (List[str])`**: Name of all valid parameter* **`values (Optional[Mapping[str, List]], optional)`**: Parameter values - usually automatically detected.* **`default (Optional[Mapping[str, str]], optional)`**: Default parameter values.* **`keyword (Optional[List[str]], optional)`**: Keyword to import the parameter dataset with.* **`filter (Optional[Mapping[str, str]], optional)`**: Filter to use for the parameter space.* **`combinations (Optional[List[Mapping[str, str]]], optional)`**: All possible parameter combinations.The following class methods can be run on an instance of an OmniInput:* **`update_parameter()`**: Method to import and update parameter datasets and update the object/parameter space accordingly.---#### OmniCommandClass to manage the main workflow command of an omnibenchmark module. This class has the following attributes:* **`script (Union[PathLike, str])`**: Path to the script run by the command* **`interpreter (str, optional)`**: Interpreter to run the script with.* **`command_line (str, optional)`**: Command line to be run.* **`outputs (OmniOutput, optional)`**: Object specifying all outputs.* **`input_val (Optional[Mapping], optional)`**: Input file tyoes and paths to run the command on.* **`parameter_val (Optional[Mapping], optional)`**: Parameter names and values to run the command with.The following class methods can be run on an instance of an OmniInput:* **`update_command()`**: Method to update the command according to the outputs,inputs,parameter.---#### OmniPlanClass to manage the workflow of an omnibenchmark module.This class has the following attributes:* **`plan (PlanViewModel)`**: A plan view model as defined in renku* **`param_mapping (Optional[Mapping[str, str]], optional)`**: A mapping between the component names of the plan and the OmniObject.The following class methods can be run on an instance of an OmniInput:* **`predict_mapping_from_file_dict()`**: Method to predict the mapping from the (input-, output-, parameter) file mapping used to generate the command.---### Submit your moduleOnce a module is complete and works it can be included into the omnibenchmark orchestrator of the associated benchmark. This means it will be automatically run, continously updated and it's result will automatically be used as inputs by downstream modules. Please open an issue on the corresponding orchestrator GitLab project linking to the project to get the project taken up. You can find the corresponding GitLab project at the [omnibenchmark website](https://omnibenchmark.pages.uzh.ch/omni_dash/benchmarks/).## Release History* 0.0.42    * Adapt to renku version 2.3.2    * Enable parallel execution of activities* 0.0.41    * New input argument &quot;multi_data_matching&quot; to explicitly allow matching files from multiple datasets.    * New function to link files to a dataset by prefix and keyword.    * FIX:    * Name checking returns conflicting dataset names.* 0.0.40    * FIX:    * file name matching for strings as file_type_dict values.* 0.0.39    * add sort_keys argument to omni_output (defaults to true -&gt; alphabetically sorted parameter keys in out names)    * FIX:    * remove duplicated outputs independent of parameter order    * clear project context in revert_run    * use the next best match for equal matches in file name matching* 0.0.37    * Enable import of only one dataset by adding an all flag    * FIX:    * Match files by longest sequence instead of ratio    * Workaround for bug in renku.api.Dataset.list()* 0.0.35    * Automatic input files matching prefixes for the same file type    * Add all parameter to renku_run only for ne activity and plan    * Adapt to renku 1.10.0* 0.0.34    * FIX:    * Enable project queries to ignore missing projects, instead of breaking * 0.0.33    * FIX:    * Add flag to actively push/save successfully finished activities after generation.* 0.0.32    * Add meaningful commit message to renku_save() after updating/generating activities    * Adjust to renku 1.9.1    * Adapt to mypy no_implicit_optional=True* 0.0.31    * Adapt to renku-python 1.8.1:    * Replace context manager by renku api to get plan and activity gateways    * Adjust project attributes     * FIX:    * Use url path in renku api lineage call     * Enable multipage results in renku api queries * 0.0.30    * FIX:    * Get a stable name hash used to automatically generate output names by fixing the order using sorted input file names    * Use files that generated the workflow to do the file mapping  * 0.0.29    * Add check_status and check_run to omni_obj class methods    * FIX:    * Export these most important functionalities * 0.0.28    * Commit after generating/updating each activity    * Add argument to disable orchestrator check    * FIX:    * Include latest pipelines with optional numbers into orchestrator check * 0.0.27    * Change automatic output naming mechanism    * Ensure stable output names independent of other inputs* 0.0.26    * Add revert_run function    * Remove outputs and activties with non existing inputs    * Remove datasets with non matching keywords* 0.0.23    * FIX:    * Adapt changes to renku 1.7.1* 0.0.22    * FIX:    * Ignore datasets with broken urls* 0.0.17-19    * FIX:    * Update defaults after filtering* 0.0.16    * Add filter for input/parameter combinations* 0.0.15    * FIX:    * Replace command error with warning to allow to build an object before inputs are imported* 0.0.14    * FIX:    * Change benchmark url* 0.0.13    * Add function docstrings    * Add name filter for importing input datasets    * Add Documentation in Readme    * FIX:    * Adapt renku_update_activities to handle skip_update_metadata argument in renku 1.5.0* 0.0.12    * FIX:    * accept float as parameter values and keep after filtering  * 0.0.9    * FIX:    * add common sequence to auto file matching  * 0.0.8    * FIX:    * add update command to omni_obj.update_object()  * 0.0.4 - 0.0.7    * FIX:    * convert defaults to string to generate plan     * adapt output default    * dependency between command line call and renku input definitions    * ignore not existing defaults* 0.0.3    * FIX:    * automatic input detection from prefixes for files from the same dataset * 0.0.2    * FIX:    * automatic command detection, file_mapping.input_files structure* 0.0.1    * First version of all main functionalities## MetaAlmut Lütge – [@Almut30618742](https://twitter.com/Almut30618742)Anthony Sonrel – [@AnthonySonrel](https://twitter.com/AnthonySonrel)Mark Robinson – [@markrobinsonca](https://twitter.com/markrobinsonca)Distributed under the Apache 2.0 license. See ``LICENSE`` for more information.[https://github.com/almutlue/omnibenchmark-py](https://github.com/almutlue/omnibenchmark-py)## Contributing1. Fork it (&lt;https://github.com/almutlue/omnibenchmark-py/fork&gt;)2. Create your feature branch (`git checkout -b feature/fooBar`)3. Commit your changes (`git commit -am 'Add some fooBar'`)4. Push to the branch (`git push origin feature/fooBar`)5. Create a new Pull Request</longdescription>
</pkgmetadata>