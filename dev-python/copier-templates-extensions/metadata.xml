<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Copier Templates Extensions[![ci](https://github.com/pawamoy/copier-templates-extensions/workflows/ci/badge.svg)](https://github.com/pawamoy/copier-templates-extensions/actions?query=workflow%3Aci)[![documentation](https://img.shields.io/badge/docs-mkdocs%20material-blue.svg?style=flat)](https://pawamoy.github.io/copier-templates-extensions/)[![pypi version](https://img.shields.io/pypi/v/copier-templates-extensions.svg)](https://pypi.org/project/copier-templates-extensions/)[![gitpod](https://img.shields.io/badge/gitpod-workspace-blue.svg?style=flat)](https://gitpod.io/#https://github.com/pawamoy/copier-templates-extensions)[![gitter](https://badges.gitter.im/join%20chat.svg)](https://gitter.im/copier-templates-extensions/community)Special Jinja2 extension for Copier that allows to load extensions using file paths relative to the template root instead of Python dotted paths.## InstallationWith `pip`:```bashpip install copier-templates-extensions```With [`pipx`](https://github.com/pipxproject/pipx):```bashpip install --user pipxpipx install copierpipx inject copier copier-templates-extensions```## UsageIn your template configuration,first add our loader extension,then add your templates extensionsusing relative file paths,and the class name after a colon:```yaml_jinja_extensions:- copier_templates_extensions.TemplateExtensionLoader- extensions/context.py:ContextUpdater- extensions/slugify.py:SlugifyExtension```With this example, you are supposed to have an `extensions`directory at the root of your template containing two modules:`context.py` and `slugify.py`.```ğŸ“ template_rootâ”œâ”€â”€ ğŸ“„ abc.txt.jinjaâ”œâ”€â”€ ğŸ“„ copier.ymlâ””â”€â”€ ğŸ“ extensions Â Â  â”œâ”€â”€ ğŸ“„ context.py Â Â  â””â”€â”€ ğŸ“„ slugify.py```See [Context hook extension](#context-hook-extension)to see how the `ContextUpdater` class can be written.The `SlugifyExtension` class could be written like this:```pythonimport reimport unicodedatafrom jinja2.ext import Extension# taken from Django# https://github.com/django/django/blob/main/django/utils/text.pydef slugify(value, allow_unicode=False):    &quot;&quot;&quot;    Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated    dashes to single dashes. Remove characters that aren't alphanumerics,    underscores, or hyphens. Convert to lowercase. Also strip leading and    trailing whitespace, dashes, and underscores.    &quot;&quot;&quot;    value = str(value)    if allow_unicode:        value = unicodedata.normalize('NFKC', value)    else:        value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')    value = re.sub(r'[^\w\s-]', '', value.lower())    return re.sub(r'[-\s]+', '-', value).strip('-_')class SlugifyExtension(Extension):    def __init__(self, environment):        super().__init__(environment)        environment.filters[&quot;slugify&quot;] = slugify```### Context hook extensionThis package also provides a convenient extension classallowing template writers to update the context usedto render templates, in order to add, modify or removeitems of the context.In one of your relative path extensions modules,create a class that inherits from `ContextHook`,and override its `hook` method:```pythonfrom copier_templates_extensions import ContextHookclass ContextUpdater(ContextHook):    def hook(self, context):        new_context = {}        new_context[&quot;say&quot;] = &quot;hello &quot; + context[&quot;name&quot;]        return new_context```Using the above example, your context will be updatedwith the `new_context` returned by the method.If you prefer to modify the context in-place instead,for example to *remove* items from it,set the `update` class attribute to `False`:```pythonfrom copier_templates_extensions import ContextHookclass ContextUpdater(ContextHook):    update = False    def hook(self, context):        context[&quot;say&quot;] = &quot;hello &quot; + context[&quot;name&quot;]        del context[&quot;name&quot;]```In your Jinja templates, you will now have accessto the `{{ say }}` variable directly.This can be extremely useful in template projectswhere you don't want to ask too many questions to the usersand instead infer some values from their answers.Consider the following example:you ask your users if they want to generatea CLI app or a web API.Depending on their answer,the main Python module should be named`cli.py` or `app.py`.Without the context hook,you would need to write a Jinja macro somewhere,or update the context directly in Jinja,and import this file (still using Jinja)*in the filename of the module*:```jinja{# using macros #}{%- macro module_name() %}  {%- if project_type == &quot;webapi&quot; %}app{% else %}cli{% endif %}{%- endmacro %}``````jinja{# or enhancing the context #}{#- Initiate context with a copy of Copier answers -#}{%- set ctx = _copier_answers.copy() -%}{#- Populate our new variables -#}{%- set _ = ctx.update({&quot;module_name&quot;: (&quot;app&quot; if project_type == &quot;webapi&quot; else &quot;cli&quot;) -%}``````ğŸ“ template_rootâ”œâ”€â”€ ğŸ“„ copier.ymlâ”œâ”€â”€ ğŸ“„ macros      # the macros fileâ”œâ”€â”€ ğŸ“„ context     # the context fileâ”œâ”€â”€ ğŸ“ extensionsâ”‚Â Â  â””â”€â”€ ğŸ“„ slugify.pyâ””â”€â”€ ğŸ“ {{project_name|slugify}}    â”‚    â”‚   # using the macros    â”œâ”€â”€ ğŸ“„ {% import 'macros' as macros with context %}{{macros.module_name()}}.py.jinja    â”‚    â”‚   # or using the enhanced context    â””â”€â”€ ğŸ“„ {% from 'context' import ctx with context %}{{ctx.module_name}}.py.jinja```As you can see, both forms are really ugly to write:- the `macros` or `context` can only be placed in the root,  as slashes `/` are not allowed in filenames- you must use spaces and single-quotes  (double-quotes are not valid filename characters on Windows)  in your templated filenames, which is not clean- filenames are very long**Using our context hook instead makes it so easy and clean!**```pythonfrom copier_templates_extensions import ContextHookclass ContextUpdater(ContextHook):    def hook(self, context):        return {&quot;module_name&quot;: &quot;app&quot; if context[&quot;project_type&quot;] == &quot;webapi&quot; else &quot;cli&quot;}``````ğŸ“ template_rootâ”œâ”€â”€ ğŸ“„ copier.ymlâ”œâ”€â”€ ğŸ“ extensionsâ”‚Â Â  â”œâ”€â”€ ğŸ“„ slugify.pyâ”‚Â Â  â””â”€â”€ ğŸ“„ context.pyâ””â”€â”€ ğŸ“ {{project_name|slugify}}    â””â”€â”€ ğŸ“„ {{module_name}}.py.jinja```## How does it work?Beware the ugly hack!Upon loading the special *loader* extension,the function responsible for importinga Python object using its dotted-path (a string)is patched in the `jinja.environment` module,where it's used to load extensions.The patched version adds supportfor loading extensions using relative file paths.The file system loader of the Jinja environmentand its `searchpaths` attribute are used tofind the local clone of the template and determinethe absolute path of the extensions to load.</longdescription>
</pkgmetadata>