<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># CLIP[[Blog]](https://openai.com/blog/clip/) [[Paper]](https://arxiv.org/abs/2103.00020) [[Model Card]](model-card.md) [[Colab]](https://colab.research.google.com/github/openai/clip/blob/master/notebooks/Interacting_with_CLIP.ipynb)CLIP (Contrastive Language-Image Pre-Training) is a neural network trained on a variety of (image, text) pairs. It can be instructed in natural language to predict the most relevant text snippet, given an image, without directly optimizing for the task, similarly to the zero-shot capabilities of GPT-2 and 3. We found CLIP matches the performance of the original ResNet50 on ImageNet “zero-shot” without using any of the original 1.28M labeled examples, overcoming several major challenges in computer vision.This repo is a fork maintaining a PYPI package for clip. Changes from the main repo:* remove the strict torch dependency* add [truncate_text](https://github.com/openai/CLIP/pull/126) option to tokenize to be able to handle longer sequencesYou will need to disable JIT by doing `model, preprocess = clip.load(&quot;ViT-B/32&quot;, device=device, jit=False)` if not using torch 1.7.1.Run `pip install clip-anytorch` to install this package.One benefit of not depending on an old torch version is installing clip on colab is super fast, try [this colab](https://colab.research.google.com/drive/1q-YgGtk5IeU3-uTvfKF63vI8ntU9k3Cw#scrollTo=ctt1dsV18smF) to see it for yourself.## Approach![CLIP](CLIP.png)## Installation## With pip`pip install clip-anytorch`. Yes that's it!## With condaFirst, [install PyTorch 1.7.1](https://pytorch.org/get-started/locally/) and torchvision, as well as small additional dependencies, and then install this repo as a Python package. On a CUDA GPU machine, the following will do the trick:```bash$ conda install --yes -c pytorch pytorch=1.7.1 torchvision cudatoolkit=11.0$ pip install ftfy regex tqdm$ pip install git+https://github.com/openai/CLIP.git```Replace `cudatoolkit=11.0` above with the appropriate CUDA version on your machine or `cpuonly` when installing on a machine without a GPU.## Usage```pythonimport torchimport clipfrom PIL import Imagedevice = &quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;model, preprocess = clip.load(&quot;ViT-B/32&quot;, device=device)image = preprocess(Image.open(&quot;CLIP.png&quot;)).unsqueeze(0).to(device)text = clip.tokenize([&quot;a diagram&quot;, &quot;a dog&quot;, &quot;a cat&quot;]).to(device)with torch.no_grad():    image_features = model.encode_image(image)    text_features = model.encode_text(text)    logits_per_image, logits_per_text = model(image, text)    probs = logits_per_image.softmax(dim=-1).cpu().numpy()print(&quot;Label probs:&quot;, probs)  # prints: [[0.9927937  0.00421068 0.00299572]]```## APIThe CLIP module `clip` provides the following methods:#### `clip.available_models()`Returns the names of the available CLIP models.#### `clip.load(name, device=..., jit=False)`Returns the model and the TorchVision transform needed by the model, specified by the model name returned by `clip.available_models()`. It will download the model as necessary. The `name` argument can also be a path to a local checkpoint.The device to run the model can be optionally specified, and the default is to use the first CUDA device if there is any, otherwise the CPU. When `jit` is `False`, a non-JIT version of the model will be loaded.#### `clip.tokenize(text: Union[str, List[str]], context_length=77)`Returns a LongTensor containing tokenized sequences of given text input(s). This can be used as the input to the model---The model returned by `clip.load()` supports the following methods:#### `model.encode_image(image: Tensor)`Given a batch of images, returns the image features encoded by the vision portion of the CLIP model.#### `model.encode_text(text: Tensor)`Given a batch of text tokens, returns the text features encoded by the language portion of the CLIP model.#### `model(image: Tensor, text: Tensor)`Given a batch of images and a batch of text tokens, returns two Tensors, containing the logit scores corresponding to each image and text input. The values are cosine similarities between the corresponding image and text features, times 100.## More Examples### Zero-Shot PredictionThe code below performs zero-shot prediction using CLIP, as shown in Appendix B in the paper. This example takes an image from the [CIFAR-100 dataset](https://www.cs.toronto.edu/~kriz/cifar.html), and predicts the most likely labels among the 100 textual labels from the dataset.```pythonimport osimport clipimport torchfrom torchvision.datasets import CIFAR100# Load the modeldevice = &quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;model, preprocess = clip.load('ViT-B/32', device)# Download the datasetcifar100 = CIFAR100(root=os.path.expanduser(&quot;~/.cache&quot;), download=True, train=False)# Prepare the inputsimage, class_id = cifar100[3637]image_input = preprocess(image).unsqueeze(0).to(device)text_inputs = torch.cat([clip.tokenize(f&quot;a photo of a {c}&quot;) for c in cifar100.classes]).to(device)# Calculate featureswith torch.no_grad():    image_features = model.encode_image(image_input)    text_features = model.encode_text(text_inputs)# Pick the top 5 most similar labels for the imageimage_features /= image_features.norm(dim=-1, keepdim=True)text_features /= text_features.norm(dim=-1, keepdim=True)similarity = (100.0 * image_features @ text_features.T).softmax(dim=-1)values, indices = similarity[0].topk(5)# Print the resultprint(&quot;\nTop predictions:\n&quot;)for value, index in zip(values, indices):    print(f&quot;{cifar100.classes[index]:&gt;16s}: {100 * value.item():.2f}%&quot;)```The output will look like the following (the exact numbers may be slightly different depending on the compute device):```Top predictions:           snake: 65.31%          turtle: 12.29%    sweet_pepper: 3.83%          lizard: 1.88%       crocodile: 1.75%```Note that this example uses the `encode_image()` and `encode_text()` methods that return the encoded features of given inputs.### Linear-probe evaluationThe example below uses [scikit-learn](https://scikit-learn.org/) to perform logistic regression on image features.```pythonimport osimport clipimport torchimport numpy as npfrom sklearn.linear_model import LogisticRegressionfrom torch.utils.data import DataLoaderfrom torchvision.datasets import CIFAR100from tqdm import tqdm# Load the modeldevice = &quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;model, preprocess = clip.load('ViT-B/32', device)# Load the datasetroot = os.path.expanduser(&quot;~/.cache&quot;)train = CIFAR100(root, download=True, train=True, transform=preprocess)test = CIFAR100(root, download=True, train=False, transform=preprocess)def get_features(dataset):    all_features = []    all_labels = []    with torch.no_grad():        for images, labels in tqdm(DataLoader(dataset, batch_size=100)):            features = model.encode_image(images.to(device))            all_features.append(features)            all_labels.append(labels)    return torch.cat(all_features).cpu().numpy(), torch.cat(all_labels).cpu().numpy()# Calculate the image featurestrain_features, train_labels = get_features(train)test_features, test_labels = get_features(test)# Perform logistic regressionclassifier = LogisticRegression(random_state=0, C=0.316, max_iter=1000, verbose=1)classifier.fit(train_features, train_labels)# Evaluate using the logistic regression classifierpredictions = classifier.predict(test_features)accuracy = np.mean((test_labels == predictions).astype(np.float)) * 100.print(f&quot;Accuracy = {accuracy:.3f}&quot;)```Note that the `C` value should be determined via a hyperparameter sweep using a validation split.</longdescription>
</pkgmetadata>