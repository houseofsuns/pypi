<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pipeline APIsAcceldata Torch is a complete solution to observe the quality of the data present in your data lake and warehouse. Using Torch, you can ensure that high-quality data backs your business decisions. Torch provides you with tools to measure the quality of data in a data catalog and to never miss significant data sources. All users including analysts, data scientists, and developers, can rely on Torch to observe the data flowing in the warehouse or data lake and can rest assured that there is no loss of data. &lt;br /&gt;Acceldata SDK is used to trigger torch catalog and pipeline APIs. By creating a Torch client, all the torch apis can be accessed. Install `acceldata-sdk` pypi package in a python environment.```bashpip install acceldata-sdk```## Create Torch ClientTorch client is used to send data to the torch servers. It consists of various methods to communicate with the torch server. Torch client have access to catalog and pipeline APIs. To create a torch client, torch url and API keys are required. To create torch API keys, go to torch ui’s settings and generate keys for the client.While creating a TorchClient connection to torch by default version compatibility checks between torch and sdk is enabled. If we want we can disable that check by passing `do_version_check` as `False.```pythonfrom acceldata_sdk.torch_client import TorchClienttorch_client = TorchClient(url='https://acceldata.host.dev:9999', access_key='******',                         secret_key='*****************', do_version_check=True)```## Pipeline API There are various pipeline APIs are supported through Acceldata SDK. Pipeline APIs like create pipeline, add jobs and spans, initiate pipeline run et cetera. Acceldata sdk is able to send various event during span life cycle. Hence, Acceldata sdk has full control over the pipelines.##### Create Pipeline And Job and span to bound the job`Pipeline` represents the ETL pipeline in its entirety and will contain Asset nodes and Jobs associated. The complete pipeline definition forms the Lineage graph for all the data assets.&lt;/br&gt;`Job Node` or `Process Node` represents an entity that does some job in the ETL workflow. From this representation, `Job’s input` is some assets or some other Jobs, and output is few other assets or few other Jobs.Torch will use the set of Jobs definition in the workflow to create the Lineage, and also track version changes for the Pipeline.Acceldata sdk provides `CreateJob` class which need to be passed to `create_job` function as a parameter to create a job.Params for `CreateJob`:`uid`: uid of the job. It should be unique for the job. It is a mandatory parameter.&lt;br/&gt;`name`: name of the job. It is a mandatory parameter.#### NOTE: This changed in 2.4.1 release`pipeline_run_id`: id of the pipeline_run for which you want to add a job. It is a mandatory parameter if `job` is being created using `pipeline`. Its is not needed if job is being created using `pipeline_run`.&lt;br/&gt;`description`: description of the job &lt;/br&gt;`inputs`: (list[Node]) input for the job. This can be uid of an asset specified using asset_uid parameter of Node object        or it can be uid of another job specified using job_uid parameter of Node object.&lt;/br&gt;`outputs`: (list[Node]) output for the job.This can be uid of an asset specified using asset_uid parameter of Node object        or it can be uid of another job specified using job_uid parameter of Node object.&lt;/br&gt;`meta`: Metadata of the Job&lt;/br&gt;`context`: context of the job&lt;/br&gt;`bounded_by_span`: (Boolean) This has to be set to True if the job has to be bounded with a span. Default value is false. It is an optional parameter.`span_uid`: (String) This is uid of new span to be created. This is a mandatory parameter if bounded_by_span is set to True.```pythonfrom acceldata_sdk.torch_client import TorchClientfrom acceldata_sdk.models.job import CreateJob, JobMetadata, Nodefrom acceldata_sdk.models.pipeline import CreatePipeline, PipelineMetadata, PipelineRunResult, PipelineRunStatus# Create pipelinepipeline = CreatePipeline(    uid='monthly_reporting_pipeline',    name='Monthly reporting Pipeline',    description='Pipeline to create monthly reporting tables',    meta=PipelineMetadata('Vaishvik', 'acceldata_sdk_code', '...'),    context={'key1': 'value1'})torch_client = TorchClient(url=&quot;https://torch.acceldata.local&quot;, access_key=&quot;*******&quot;,                          secret_key=&quot;******************************&quot;,do_version_check=False)pipeline_response = torch_client.create_pipeline(pipeline=pipeline)pipeline_run = pipeline_response.create_pipeline_run()# Create a job using pipeline object.# Passing of pipeline_run_id is mandatoryjob = CreateJob(    uid='monthly_sales_aggregate',    name='Monthly Sales Aggregate',    description='Generates the monthly sales aggregate tables for the complete year',    inputs=[Node(asset_uid='datasource-name.database.schema.table_1')],    outputs=[Node(job_uid='job2_uid')],    meta=JobMetadata('vaishvik', 'backend', 'https://github.com/'),    context={'key21': 'value21'},    bounded_by_span=True,    pipeline_run_id=pipeline_run.id,    span_uid=&quot;test_shubh&quot;)job_response = pipeline_response.create_job(job)# Create a job using pipeline_run object.# Passing of pipeline_run_id is not neededjob = CreateJob(        uid='monthly_sales_aggregate',        name='Monthly Sales Aggregate',        description='Generates the monthly sales aggregate tables for the complete year',        inputs=[Node(asset_uid='datasource-name.database.schema.table_1')],        outputs=[Node(job_uid='job2_uid')],        meta=JobMetadata('vaishvik', 'backend', 'https://github.com/'),        context={'key21': 'value21'})job_response_using_run = pipeline_run.create_job(job)```##### Create Pipeline Run And Generate Spans And Send Span EventsPipeline run indicates the execution of the pipeline. The same pipeline can be executed multiple times and each execution (run) has new snapshot version. Each pipeline run has hierarchical span's group. A `Span` is a way to group a bunch of metrics, and they are hierarchical. It can be as granular as possible. The APIs will support creating a span object from a pipeline object, and then hierarchical spans are started from parent spans. A Span typically encompasses a process or a task and can be granular. This hierarchical system is powerful enough to model extremely complex pipeline observability flows. Optionally, a span can also be associated with a Job. This way, we can track starting and completion of Job, including the failure tracking. Start and stop are implicitly tracked for a span.Acceldata sdk also has support for create new pipeline run, add spans in it. During the span life cycle, sdk is able to send some customs and standard span events to collect pipeline run metrics for observability.Params for `create_span` function which is available under a `pipeline_run``uid`: uid of the span being created. This should be unique. This is a mandatory parameter.&lt;br/&gt;`associatedJobUids`: List of job uids with which the span needs to be associated with.&lt;br/&gt;`context_data`: This is dict of key-value pair providing custom context information related to a span.&lt;br/&gt;Params for `create_child_span` function which is available under `span_context`. This is used to create hierarchy of span by creating a span under another span`uid`: uid of the span being created. This should be unique. This is a mandatory parameter.&lt;br/&gt;`context_data`: This is dict of key-value pair providing custom context information related to a span.&lt;br/&gt;`associatedJobUids`: List of job uids with which the span needs to be associated with.```pythonfrom acceldata_sdk.events.generic_event import GenericEventfrom datetime import datetime# create a pipeline run of the pipelinepipeline_run = pipeline_response.create_pipeline_run()# get root span of a pipeline runroot_span = pipeline_run.get_root_span()# create span in the pipeline runspan_context = pipeline_run.create_span(uid='monthly.generate.data.span')# check current span is root or notspan_context.is_root()# end the span span_context.end()# check if the current span has children or notspan_context.has_children()# create a child spanchild_span_context = span_context.create_child_span('monthly.generate.customer.span')# send custom eventchild_span_context.send_event(    GenericEvent(context_data={'client_time': str(datetime.now()), 'row_count': 100},                  event_uid=&quot;order.customer.join.result&quot;))# abort spanchild_span_context.abort()# failed spanchild_span_context.failed()# update a pipeline run of the pipelineupdatePipelineRunRes = pipeline_run.update_pipeline_run(context_data={'key1': 'value2', 'name': 'backend'},                                                               result=PipelineRunResult.SUCCESS,                                                               status=PipelineRunStatus.COMPLETED)```##### Get Latest Pipeline RunAcceldata sdk can get the latest pipeline run of the pipeline. With use of the latest pipeline run instance, user can continue ETL pipeline and add spans, jobs, events too. Hence, Acceldata sdk has complete access on the torch pipeline service.Params for `get_pipeline`:`pipeline_identity`: String parameter used to filter pipeline. It can be either id or uid of the pipeline.```pythonpipeline = torch_client.get_pipeline('monthly.reporting.pipeline')pipeline_run = pipeline.get_latest_pipeline_run()```##### Get Pipeline Run with a particular pipeline run idAcceldata sdk can get a pipeline run of the pipeline with a particular pipeline run id. With use of the pipeline run instance, user can continue ETL pipeline and add spans, jobs, events too. Hence, Acceldata sdk has complete access on the torch pipeline service.Params for `get_pipeline_run`:`pipeline_run_id`: run id of the pipeline run&lt;br/&gt;`continuation_id`: continuation id of the pipeline run&lt;br/&gt;`pipeline_id`: id of the pipeline to which the run belongs to&lt;br/&gt;```pythonpipeline_run = torch_client.get_pipeline_run(pipeline_run_id=pipeline_run_id)pipeline = torch_client.get_pipeline(pipeline_id=pipeline_id)pipeline_run = torch_client.get_pipeline_run(continuation_id=continuation_id, pipeline_id=pipeline.id)pipeline_run = pipeline.get_run(continuation_id=continuation_id)```##### Get Pipeline details for a particular pipeline run idAcceldata sdk can get Pipeline details for a particular pipeline run.```pythonpipeline_details = pipeline_run.get_details()```##### Get all spans for a particular pipeline run idAcceldata sdk can get all spans for a particular pipeline run id.```pythonpipeline_run_spans = pipeline_run.get_spans()```##### Get Pipeline Runs for a pipelineAcceldata sdk can get all pipeline runs.Params for `get_pipeline_runs`:`pipeline_id`: id of the pipeline```pythonruns = torch_client.get_pipeline_runs(pipeline_id)runs = pipeline.get_runs()```##### Get all PipelinesAcceldata sdk can get all pipelines.```pythonpipelines = torch_client.get_pipelines()```##### Delete a PipelineAcceldata sdk can delete a pipeline.```pythondelete_response = pipeline.delete()```##### Execute policy synchronously and asynchronouslyAcceldata sdk provides utility function `execute_policy` to execute policies synchronously and asynchronously. This will return an object on which `get_result` and `get_status` can be called to get result and status of the execution respectively.Params for `execute_policy`:`sync`: Boolean parameter used to decide if the policy should be executed synchronously or asynchronously. It is a mandatory parameter. If its is set to  `True` it will return only after the execution ends. If it is set to `False` it will return immediately after starting the execution.`policy_type`: Enum parameter used to specify the policy type. It is a mandatory parameter. It is a enum which will take values from constants as PolicyType.DATA_QUALITY or PolicyType.RECONCILIATION.`policy_id`: String parameter used to specify the policy id to be executed. It is a mandatory parameter. `incremental`: Boolean parameter used to specify if the policy execution should be incremental or full. Default value is False.`pipeline_run_id`: Long parameter used to specify Run id of the pipeline run where the policy is being executed. This canbe used to link the policy execution with a particular pipeline run.`failure_strategy`: Enum parameter used to decide the behaviour in case of failure. Default value is DoNotFail.* `failure_strategy` takes enum of type `FailureStrategy` which can have 3 values DoNotFail, FailOnError and FailOnWarning.* DoNotFail will never throw. In case of failure it will log the error.* FailOnError will Throw exception only if it's an error. In case of warning it return without any errors.* FailOnWarning will Throw exception on warning as well as error.To get the execution result we can call `get_policy_execution_result` on torch_client or call `get_result` on execution object which will return a result object.Params for `get_policy_execution_result`:`policy_type`: Enum parameter used to specify the policy type. It is a mandatory parameter. It is a enum which will take values from constants as PolicyType.DATA_QUALITY or PolicyType.RECONCILIATION.`execution_id`: String parameter used to specify the execution id to be queried for rsult. It is a mandatory parameter. `failure_strategy`: Enum parameter used to decide the behaviour in case of failure. Default value is DoNotFail.Params for `get_result`:`failure_strategy`: Enum parameter used to decide the behaviour in case of failure. Default value is DoNotFail.To get the current status we can call `get_policy_status` on torch_client or call `get_status` on execution object which will get the current `resultStatus` of the execution. params for `get_policy_status` :`policy_type`: Enum parameter used to specify the policy type. It is a mandatory parameter. It is a enum which will take values from constants as PolicyType.DATA_QUALITY or PolicyType.RECONCILIATION.`execution_id`: String parameter used to specify the execution id to be queried for rsult. It is a mandatory parameter. `get_status` does not take any parameter.Asynchronous execution example```pythonfrom acceldata_sdk.torch_client import TorchClientimport acceldata_sdk.constants as consttorch_credentials = {    'url':  'https://torch.acceldata.local:5443/torch',    'access_key':'PJSAJALFHSHU',    'secret_key': 'E6LLJHKGSHJJTRHGK540E5',    'do_version_check': 'True'}torch_client = TorchClient(**torch_credentials)async_executor = torch_client.execute_policy(const.PolicyType.DATA_QUALITY, 46, sync=False, failure_strategy=const.FailureStrategy.DoNotFail, pipeline_run_id=None)# Wait for execution to get final resultexecution_result = async_executor.get_result(failure_strategy=const.FailureStrategy.DoNotFail)# Get the current statusexecution_status = async_executor.get_status()```Synchronous execution example.```pythonfrom acceldata_sdk.torch_client import TorchClientimport acceldata_sdk.constants as consttorch_credentials = {    'url':  'https://torch.acceldata.local:5443/torch',    'access_key':'PJSAJALFHSHU',    'secret_key': 'E6LLJHKGSHJJTRHGK540E5',    'do_version_check': 'True'}torch_client = TorchClient(**torch_credentials)# This will wait for execution to get final resultsync_executor = torch_client.execute_policy(const.PolicyType.DATA_QUALITY, 46, sync=True, failure_strategy=const.FailureStrategy.DoNotFail, pipeline_run_id=None)# Wait for execution to get final resultexecution_result = sync_executor.get_result(failure_strategy=const.FailureStrategy.DoNotFail)# Get the current statusexecution_status = sync_executor.get_status()```Cancel execution example.```pythonexecution_result = sync_executor.cancel()```Example of continuing the same pipeline run across multiple ETL scripts using continuation_idETL1 - Here a new pipeline_run is created using a continuation_id but pipeline_run is not closed```pythonfrom acceldata_sdk.torch_client import TorchClientfrom acceldata_sdk.models.pipeline import CreatePipeline, PipelineMetadata, PipelineRunResult, PipelineRunStatus# Create pipelinepipeline_uid = 'monthly_reporting_pipeline'pipeline = CreatePipeline(    uid=pipeline_uid,    name='Monthly reporting Pipeline',    description='Pipeline to create monthly reporting tables',    meta=PipelineMetadata('Vaishvik', 'acceldata_sdk_code', '...'),    context={'key1': 'value1'})torch_client = TorchClient(url=&quot;https://torch.acceldata.local&quot;, access_key=&quot;*******&quot;,                          secret_key=&quot;******************************&quot;,do_version_check=False)pipeline_response = torch_client.create_pipeline(pipeline=pipeline)# A new continuation id should be generated on every run. Same continuation id cannot be reused.cont_id = &quot;continuationid_demo_1&quot;pipeline_run = pipeline_response.create_pipeline_run(continuation_id=cont_id)# Make sure pipeline_run is not ended using the update_pipeline_run call so that same run can be used in next ETL script```ETL2 - This script will continue the same pipeline run from ETL1```pythonfrom acceldata_sdk.torch_client import TorchClientfrom acceldata_sdk.models.pipeline import PipelineRunResult, PipelineRunStatustorch_client = TorchClient(url=&quot;https://torch.acceldata.local&quot;, access_key=&quot;*******&quot;,                          secret_key=&quot;******************************&quot;,do_version_check=False)pipeline_uid = 'monthly_reporting_pipeline'# First get the same pipeline using the previously used UID. Then we will get the previously started pipeline_run using the continuation_idpipeline = torch_client.get_pipeline(pipeline_uid)# continuation_id should be a same ID used in ETL1 script so that same pipeline_run is continued in the pipeline.cont_id = &quot;continuationid_demo_1&quot;pipeline_run = pipeline.get_run(continuation_id=cont_id)# Use this pipeline run to create span and jobs# At the end of this script close the pipeline run using update_pipeline_run if we do not want to continue the same pipeline_run furtherupdatePipelineRunRes = pipeline_run.update_pipeline_run(context_data={'key1': 'value2', 'name': 'backend'},                                                               result=PipelineRunResult.SUCCESS,                                                               status=PipelineRunStatus.COMPLETED)```# Datasource APIsAcceldata SDK has full access on catalog APIs as well. ##### Datasource APITorch has support for more 15+ datasource crawling support. ```python# Get datasourceds_res = torch_client.get_datasource('snowflake_ds_local')ds_res = torch_client.get_datasource(5, properties=True)# Get datasources based on typedatasources = torch_client.get_datasources(const.AssetSourceType.SNOWFLAKE)```##### Assets APIsAcceldata sdk has methods to get assets in the given datasource.```pythonfrom acceldata_sdk.models.create_asset import AssetMetadata# Get asset by id/uidasset = torchclient.get_asset(1)asset = torch_client.get_asset('Feature_bag_datasource.feature_1')```##### Asset's tags, labels, metadata and sample dataUser can add tags, labels custom metadata and also get sample data of the asset using sdk.Tags and labels can be used to filter out asset easily.```python# asset metadatafrom acceldata_sdk.models.tags import AssetLabel, CustomAssetMetadataasset = torch_client.get_asset(asset_id)# Get metadata of an assetasset.get_metadata()# Get all tagstags = asset.get_tags()# Add tag assettag_add = asset.add_tag(tag='asset_tag')# Add asset labelslabels = asset.add_labels(labels=[AssetLabel('test1', 'demo1'), AssetLabel('test2', 'demo2')])# Get asset labelslabels = asset.get_labels()# Add custom metadataasset.add_custom_metadata(custom_metadata=[CustomAssetMetadata('testcm1', 'democm1'), CustomAssetMetadata('testcm2', 'democm2')])```##### Crawler OperationsUser can start crawler as well as check for running crawler status.```python# Start a crawlerdatasource.start_crawler()torch_client.start_crawler('datasource_name')# Get running crawler statusdatasource.get_crawler_status()torch_client.get_crawler_status('datasource_name')```##### Trigger policies, Profiling and sampling of an assetCrawled assets can be profiled and sampled with use of spark jobs running on the livy. Furthermore, Created policies (Recon + DQ) can be triggered too.```pythonimport acceldata_sdk.constants as const# profile an asset, get profile req details, cancel profileprofile_res = asset.start_profile(profiling_type=ProfilingType.FULL)profile_req_details = profile_res.get_status()cancel_profile_res = profile_res.cancel()profile_res = asset.get_latest_profile_status()profile_req_details_by_req_id = torch_client.get_profile_status(asset_id=profile_req_details.assetId,                                                                req_id=profile_req_details.id)# sample datasample_data = asset.sample_data()# Rule execution and status# Execute policyexecute_dq_rule = torch_client.execute_policy(const.PolicyType.DATA_QUALITY, 1114, incremental=False)failure_strategy = const.FailureStrategy.DoNotFail# Get policy execution resultresult = torch_client.get_policy_execution_result(    policy_type=const.PolicyType.DATA_QUALITY,    execution_id=execute_dq_rule.id,    failure_strategy=failure_strategy)# Get policy and executefrom acceldata_sdk.models.ruleExecutionResult import RuleType, PolicyFilterrule = torch_client.get_policy(const.PolicyType.RECONCILIATION, &quot;auth001_reconciliation&quot;)# Execute policyasync_execution = rule.execute(sync=False)# Get execution resultasync_execution_result = async_execution.get_result()# Get current execution statusasync_execution_status = async_execution.get_status()# Cancel policy execution jobcancel_rule = async_execution.cancel()# List all executions# List executions by iddq_rule_executions = torch_client.policy_executions(1114, RuleType.DATA_QUALITY)# List executions by namedq_rule_executions = torch_client.policy_executions('dq-scala', RuleType.DATA_QUALITY)# List executions by rulerecon_rule_executions = rule.get_executions()filter = PolicyFilter(policyType=RuleType.RECONCILIATION, enable=True)# List all rulesrecon_rules = torch_client.list_all_policies(filter=filter)```Version Log==========0.0.1 (12/09/2022)-------------------- Acceldata python sdk- Support for flow APIs and catalog APIs of the torch</longdescription>
</pkgmetadata>