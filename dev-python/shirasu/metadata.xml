<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Shirasu## Introduction`Shirasu` is a simple bot framework to study the principles, based on  `OneBot v11` (especially `go-cqhttp`).出于练习英语的目的，此 `README` 我就用简单英文写了，我也写了一篇[中文博客](https://blog.kifuan.me/archives/onebot-v11-python-sdk-details)介绍这个项目，内容大体一致但更详细一点（来自寒假末尾最后的倔强，其实是 `Grammarly` 监督才能避免一堆语法错误）。## UsageInstall `shirasu` first. `Python 3.10+` is required.```bash&gt; pip install shirasu```To create a simple bot application, you should create a `.py` file containing` the following code:```pythonimport asynciofrom shirasu import AddonPool, OneBotClientif __name__ == '__main__':    pool = AddonPool.from_modules(        'shirasu.addons.echo',        'shirasu.addons.help',    )    asyncio.run(OneBotClient.listen(pool))```Then, create a `shirasu.yml`, which could be other names configured by specifying the `config` argument of `OneBotClient.listen`.```yaml# The WebSocket server URL(not reverse WebSocket).ws: ws://127.0.0.1:8080# The prefixes of commands.command_prefixes: ['/', '']# Superuser accounts.superusers: [123456, 234567]# The separator of commands, using regex.command_separator: '\s+'# The configurations of addons.addons:  help:    show_addon_list: true```For more information please see the next chapter.## FeaturesThere are some features slightly different from others.### Dependency Injection SystemI'm used to `Spring`'s DI system, like:```java@Autowiredprivate Foo foo;```I know it's better to use a setter or constructor, but let me just keep it simple.However, DI in `FastAPI` is like this:```pythonasync def get_foo() -&gt; Foo:    return Foo()async def use(foo: Foo = Depends(get_foo)) -&gt; None:    await foo.use()```There are other frameworks like `Spring` for sure, but I implemented a simple DI system to study the principles.```pythonimport asynciofrom datetime import datetimefrom shirasu.di import inject, provide@provide('now')async def provide_now() -&gt; datetime:    return datetime.now()@provide('today')async def provide_today(now: datetime) -&gt; int:    await asyncio.sleep(.1)    return now.day@inject()async def use_today(today: int) -&gt; None:    print(today)@inject()async def use_now(now: datetime) -&gt; None:    await asyncio.sleep(.1)    print(now.year)# 1await use_today()# 2023await use_now()```To keep consistent, all functions should be `async`.### Addon SystemAddons in `shirasu` have no business with runtime context when creating them. Therefore you can `import` them from other modules **directly** without ensuring whether they have been imported by `shirasu`.To write an addon, take `shirasu.addons.echo` as an example:```pythonfrom shirasu import Client, Addon, MessageEvent, commandecho = Addon(    name='echo',    usage='/echo text',    description='Sends your text back.',)@echo.receive(command('echo'))async def handle_echo(client: Client, event: MessageEvent) -&gt; None:    await client.send(event.arg)```Note that the receiver(i.e. `handle_echo`) **is injected automatically**, so you don't need to add `@inject()` decorator to it.For configurations, take `shirasu.addons.square` as an example:```pythonfrom pydantic import BaseModelfrom shirasu import Client, Addon, MessageEvent, commandclass SquareConfig(BaseModel):    precision: int = 2square = Addon(    name='square',    usage='/square number',    description='Calculates the square of given number.',    config_model=SquareConfig,)@square.receive(command('square'))async def handle_square(client: Client, event: MessageEvent, config: SquareConfig) -&gt; None:    arg = event.arg    try:        result = round(float(arg) ** 2, config.precision)        await client.send(f'{result:g}')    except ValueError:        await client.reject(f'Invalid number: {arg}')```The configurations should be written in `shirasu.yml`, for example, if you want to set the `precision` to `3`:```yaml# Configurations for addons.addons:  square:    # Configurations for addon square.    precision: 3```### Unit testsIt's hard to write tests for some frameworks, so I tried my best to make it simple for this framework.To start with, you should install `pytest` and `pytest-asyncio` as our framework is designed to be async. Take the `square` addon as an example:```pythonimport pytestfrom shirasu import MockClient, AddonPool@pytest.mark.asyncioasync def test_square():    pool = AddonPool.from_modules('shirasu.addons.square')    client = MockClient(pool)    await client.post_message('/square 2')    square2_msg = await client.get_message()    assert square2_msg.plain_text == '4'    await client.post_message('/square a')    rejected_msg = await client.get_message_event()    assert rejected_msg.is_rejected```However, if your addon does not send any message sometimes, you could assert that the `asyncio.TimeoutError` will be raised. Take the `echo` addon as an example:```pythonimport pytestimport asynciofrom shirasu import MockClient, AddonPool@pytest.mark.asyncioasync def test_echo():    pool = AddonPool.from_modules('shirasu.addons.echo')    client = MockClient(pool)    await client.post_message('/echo hello')    echo_msg = await client.get_message()    assert echo_msg.plain_text == 'hello'    await client.post_message('echo hello')    with pytest.raises(asyncio.TimeoutError):        await client.get_message()```In this case, we tested the `command_prefixes`, not the addon itself.</longdescription>
</pkgmetadata>