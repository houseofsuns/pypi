<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;!-- &lt;h1 align=&quot;center&quot; style=&quot;font-family:Monospace&quot; &gt;PyğŸŒ²Class&lt;/h1&gt; --&gt;&lt;h5 align=&quot;center&quot;&gt;&lt;img width=&quot;250px&quot; src=&quot;https://user-images.githubusercontent.com/48389287/227880173-bf78c02c-d28b-4cf4-95e6-fa49b82a43a1.svg&quot;&gt; &lt;br&gt;&lt;br&gt;[**Installation**](#installation)|[**Description**](#description)|[**Quick Example**](#quick_example)|[**StatefulComputation**](#stateful_computation)|[**More**](#more)|[**Acknowledgements**](#acknowledgements)![Tests](https://github.com/ASEM000/pytreeclass/actions/workflows/tests.yml/badge.svg)![pyver](https://img.shields.io/badge/python-3.8%203.9%203.10%203.11_-red)![pyver](https://img.shields.io/badge/jax-0.4+-red)![codestyle](https://img.shields.io/badge/codestyle-black-black)[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ASEM000/PyTreeClass/blob/main/assets/intro.ipynb)[![Downloads](https://pepy.tech/badge/pytreeclass)](https://pepy.tech/project/pytreeclass)[![codecov](https://codecov.io/gh/ASEM000/pytreeclass/branch/main/graph/badge.svg?token=TZBRMO0UQH)](https://codecov.io/gh/ASEM000/pytreeclass)[![Documentation Status](https://readthedocs.org/projects/pytreeclass/badge/?version=latest)](https://pytreeclass.readthedocs.io/en/latest/?badge=latest)![GitHub commit activity](https://img.shields.io/github/commit-activity/m/ASEM000/pytreeclass)[![DOI](https://zenodo.org/badge/512717921.svg)](https://zenodo.org/badge/latestdoi/512717921)![PyPI](https://img.shields.io/pypi/v/pytreeclass)&lt;/h5&gt;**For previous `PyTreeClass` use v0.1 branch**## ğŸ› ï¸ Installation&lt;a id=&quot;installation&quot;&gt;&lt;/a&gt;```pythonpip install pytreeclass```**Install development version**```pythonpip install git+https://github.com/ASEM000/PyTreeClass```## ğŸ“– Description&lt;a id=&quot;description&quot;&gt;&lt;/a&gt;`PyTreeClass` is a JAX-compatible `dataclass`-like decorator to create and operate on stateful JAX PyTrees.The package aims to achieve _two goals_:1. ğŸ”’ To maintain safe and correct behaviour by using _immutable_ modules with _functional_ API.2. To achieve the **most intuitive** user experience in the `JAX` ecosystem by :   - ğŸ—ï¸ Defining layers similar to `PyTorch` or `TensorFlow` subclassing style.   - â˜ï¸ Filtering\Indexing layer values similar to `jax.numpy.at[].{get,set,apply,...}`   - ğŸ¨ Visualize defined layers in plethora of ways.## â© Quick Example &lt;a id=&quot;quick_example&quot;&gt;### ğŸ—ï¸ Simple Tree example&lt;div align=&quot;center&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Code&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;PyTree representation&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;```pythonimport jaximport jax.numpy as jnpimport pytreeclass as pytc@pytc.treeclassclass Tree:    a:int = 1    b:tuple[float] = (2.,3.)    c:jax.Array = jnp.array([4.,5.,6.])    def __call__(self, x):        return self.a + self.b[0] + self.c + xtree = Tree()```&lt;/td&gt;&lt;td&gt;```python# leaves are parametersTree    â”œâ”€â”€ a=1    â”œâ”€â”€ b:tuple    â”‚   â”œâ”€â”€ [0]=2.0    â”‚   â””â”€â”€ [1]=3.0    â””â”€â”€ c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])```&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;### ğŸ¨ Visualize&lt;a id=&quot;Viz&quot;&gt;&lt;details&gt; &lt;summary&gt; Visualize PyTrees&lt;/summary&gt;&lt;div align=&quot;center&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td align = &quot;center&quot;&gt; tree_summary&lt;/td&gt;  &lt;td align = &quot;center&quot;&gt;tree_diagram&lt;/td&gt; &lt;td align = &quot;center&quot;&gt;[tree_mermaid](https://mermaid.js.org)(Native support in Github/Notion)&lt;/td&gt; &lt;td align= &quot;center&quot;&gt; tree_repr &lt;/td&gt; &lt;td align=&quot;center&quot; &gt; tree_str &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;```pythonprint(pytc.tree_summary(tree, depth=1))â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”â”‚Nameâ”‚Type  â”‚Countâ”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚a   â”‚int   â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚b   â”‚tuple â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚c   â”‚f32[3]â”‚3    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚Î£   â”‚Tree  â”‚5    â”‚â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_diagram(tree, depth=1))Treeâ”œâ”€â”€ a=1â”œâ”€â”€ b=(...)â””â”€â”€ c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])``` &lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_mermaid(tree, depth=1))``````mermaidflowchart LR    id0(&lt;b&gt;Tree&lt;/b&gt;)    id0 --- id1(&quot;&lt;/b&gt;a=1&lt;/b&gt;&quot;)    id0 --- id2(&quot;&lt;/b&gt;b=(...)&lt;/b&gt;&quot;)    id0 --- id3(&quot;&lt;/b&gt;c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])&lt;/b&gt;&quot;)```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_repr(tree, depth=1))Tree(a=1, b=(...), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_str(tree, depth=1))Tree(a=1, b=(...), c=[4. 5. 6.])```&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;```pythonprint(pytc.tree_summary(tree, depth=2))â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”â”‚Nameâ”‚Type  â”‚Countâ”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚a   â”‚int   â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚b[0]â”‚float â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚b[1]â”‚float â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚c   â”‚f32[3]â”‚3    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚Î£   â”‚Tree  â”‚6    â”‚â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_diagram(tree, depth=2))Treeâ”œâ”€â”€ a=1â”œâ”€â”€ b:tupleâ”‚   â”œâ”€â”€ [0]=2.0â”‚   â””â”€â”€ [1]=3.0â””â”€â”€ c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_mermaid(tree, depth=2))``````mermaidflowchart LR    id2 --- id3(&quot;&lt;/b&gt;[0]=2.0&lt;/b&gt;&quot;)    id2 --- id4(&quot;&lt;/b&gt;[1]=3.0&lt;/b&gt;&quot;)    id0(&lt;b&gt;Tree&lt;/b&gt;)    id0 --- id1(&quot;&lt;/b&gt;a=1&lt;/b&gt;&quot;)    id0 --- id2(&quot;&lt;/b&gt;b:tuple&lt;/b&gt;&quot;)    id0 --- id5(&quot;&lt;/b&gt;c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])&lt;/b&gt;&quot;)```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_repr(tree, depth=2))Tree(a=1, b=(2.0, 3.0), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_str(tree, depth=2))Tree(a=1, b=(2.0, 3.0), c=[4. 5. 6.])```&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/details&gt;### ğŸƒ Working with `jax` transformation&lt;details&gt; &lt;summary&gt;Make arbitrary PyTrees work with jax transformations&lt;/summary&gt;Parameters are defined in `Tree` at the top of class definition similar to defining`dataclasses.dataclass` field.Lets optimize our parameters```pythonimport pytreeclass as pytcimport jaximport jax.numpy as jnp@pytc.treeclassclass Tree:    a: int = 1    b: tuple[float] = (2., 3.)    c: jax.Array = jnp.array([4., 5., 6.])    def __call__(self, x):        return self.a + self.b[0] + self.c + xtree = Tree()@jax.graddef loss_func(tree: Tree, x: jax.Array):    tree = tree.at[...].apply(pytc.unfreeze, is_leaf=pytc.is_frozen)  # &lt;--- unfreeze the tree before calling it    preds = jax.vmap(tree)(x)  # &lt;--- vectorize the tree call over the leading axis    return jnp.mean(preds**2)  # &lt;--- return the mean squared error@jax.jitdef train_step(tree: Tree, x: jax.Array):    grads = loss_func(tree, x)    # apply a small gradient step    return jax.tree_util.tree_map(lambda x, g: x - 1e-3 * g, tree, grads)# lets freeze the non-differentiable parts of the tree# in essence any non inexact type should be frozen to# make the tree differentiable and work with jax transformationsjaxable_tree = jax.tree_util.tree_map(lambda x: pytc.freeze(x) if pytc.is_nondiff(x) else x, tree)for epoch in range(1_000):    jaxable_tree = train_step(jaxable_tree, jnp.ones([10, 1]))print(jaxable_tree)# **the `frozen` params have &quot;#&quot; prefix**# Tree(a=#1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])# unfreeze the treetree = jaxable_tree.at[...].apply(pytc.unfreeze, is_leaf=pytc.is_frozen)# the previous line is equivalent to:# &gt;&gt;&gt; tree = jax.tree_util.tree_map(pytc.unfreeze, jaxable_tree, is_leaf=pytc.is_frozen)print(tree)# Tree(a=1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])```&lt;/details&gt;#### â˜ï¸ Advanced Indexing with `.at[]` &lt;a id=&quot;Indexing&quot;&gt;&lt;details&gt; &lt;summary&gt;Out-of-place updates using mask, attribute name or index&lt;/summary&gt;`PyTreeClass` offers 3 means of indexing through `.at[]`1. Indexing by boolean mask.2. Indexing by attribute name.3. Indexing by Leaf index.**Since `treeclass` wrapped class are immutable, `.at[]` operations returns new instance of the tree**#### Index update by boolean mask```pythontree = Tree()# Tree(a=1, b=(2, 3), c=i32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4,6]))# lets create a mask for values &gt; 4mask = jax.tree_util.tree_map(lambda x: x&gt;4, tree)print(mask)# Tree(a=False, b=(False, False), c=[False  True  True])print(tree.at[mask].get())# Tree(a=None, b=(None, None), c=[5 6])print(tree.at[mask].set(10))# Tree(a=1, b=(2, 3), c=[ 4 10 10])print(tree.at[mask].apply(lambda x: 10))# Tree(a=1, b=(2, 3), c=[ 4 10 10])```#### Index update by attribute name```pythontree = Tree()# Tree(a=1, b=(2, 3), c=i32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4,6]))print(tree.at[&quot;a&quot;].get())# Tree(a=1, b=(None, None), c=None)print(tree.at[&quot;a&quot;].set(10))# Tree(a=10, b=(2, 3), c=[4 5 6])print(tree.at[&quot;a&quot;].apply(lambda x: 10))# Tree(a=10, b=(2, 3), c=[4 5 6])```#### Index update by integer index```pythontree = Tree()# Tree(a=1, b=(2, 3), c=i32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4,6]))print(tree.at[1].at[0].get())# Tree(a=None, b=(2.0, None), c=None)print(tree.at[1].at[0].set(10))# Tree(a=1, b=(10, 3.0), c=[4. 5. 6.])print(tree.at[1].at[0].apply(lambda x: 10))# Tree(a=1, b=(10, 3.0), c=[4. 5. 6.])```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;## ğŸ“œ Stateful computations&lt;a id=&quot;stateful_computation&quot;&gt;&lt;/a&gt; &lt;/summary&gt;First, [Under jax.jit jax requires states to be explicit](https://jax.readthedocs.io/en/latest/jax-101/07-state.html?highlight=state), this means that for any class instance; variables needs to be separated from the class and be passed explictly. However when using @pytc.treeclass no need to separate the instance variables ; instead the whole instance is passed as a state.Using the following pattern,Updating state **functionally** can be achieved under `jax.jit````pythonimport jaximport pytreeclass as pytc@pytc.treeclassclass Counter:    calls : int = 0    def increment(self):        self.calls += 1counter = Counter() # Counter(calls=0)```Here, we define the update function. Since the increment method mutate the internal state, thus we need to use the functional approach to update the state by using `.at`. To achieve this we can use `.at[method_name].__call__(*args,**kwargs)`, this functional call will return the value of this call and a _new_ model instance with the update state.```python@jax.jitdef update(counter):    value, new_counter = counter.at[&quot;increment&quot;]()    return new_counterfor i in range(10):    counter = update(counter)print(counter.calls) # 10```&lt;/details&gt;## â• More&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;details&gt;&lt;summary&gt;[Advanced] Register custom user-defined classes to work with visualization and indexing tools. &lt;/summary&gt;Similar to [`jax.tree_util.register_pytree_node`](https://jax.readthedocs.io/en/latest/pytrees.html#extending-pytrees), `PyTreeClass` register common data structures and `treeclass` wrapped classes to figure out how to define the names, types, and index of certain leaf along its path.Here is an example of registering```pythonclass Tree:    def __init__(self, a, b):        self.a = a        self.b = b    def __repr__(self) -&gt; str:        return f&quot;{self.__class__.__name__}(a={self.a}, b={self.b})&quot;# jax flatten ruledef tree_flatten(tree):    return (tree.a, tree.b), None# jax unflatten ruledef tree_unflatten(_, children):    return Tree(*children)# PyTreeClass flatten ruledef pytc_tree_flatten(tree):    names = (&quot;a&quot;, &quot;b&quot;) # or (`None`, `None`) if name is not defined    types = (type(tree.a), type(tree.b))    indices = (0,1)  # or (`None`, `None`) if index is not defined    return [*zip(names, types, indices)]# Register with `jax`jax.tree_util.register_pytree_node(Tree, tree_flatten, tree_unflatten)# Register the `Tree` class trace function to support indexingpytc.register_pytree_node_trace(Tree, pytc_tree_flatten)tree = Tree(1, 2)# works with jaxjax.tree_util.tree_leaves(tree)  # [1, 2]# works with PyTreeClass viz toolsprint(pytc.tree_summary(tree))# â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”# â”‚Nameâ”‚Typeâ”‚Countâ”‚Size  â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤# â”‚a   â”‚int â”‚1    â”‚28.00Bâ”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤# â”‚b   â”‚int â”‚1    â”‚28.00Bâ”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤# â”‚Î£   â”‚Treeâ”‚2    â”‚56.00Bâ”‚# â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜```After registeration, you can use internal tools like- `pytc.tree_map_with_trace`- `pytc.tree_leaves_with_trace`- `pytc.tree_flatten_with_trace`More details on that soon.&lt;/details&gt;&lt;details&gt; &lt;summary&gt;Validate or convert inputs using callbacks&lt;/summary&gt;`PyTreeClass` includes `callbacks` in the `field` to apply a sequence of functions on input at setting the attribute stage. The callback is quite useful in several cases, for instance, to ensure a certain input type within a valid range. See example:```pythonimport jaximport pytreeclass as pytcdef positive_int_callback(value):    if not isinstance(value, int):        raise TypeError(&quot;Value must be an integer&quot;)    if value &lt;= 0:        raise ValueError(&quot;Value must be positive&quot;)    return value@pytc.treeclassclass Tree:    in_features:int = pytc.field(callbacks=[positive_int_callback])tree = Tree(1)# no errortree = Tree(0)# ValueError: Error for field=`in_features`:# Value must be positivetree = Tree(1.0)# TypeError: Error for field=`in_features`:# Value must be an integer```&lt;/details&gt;&lt;details&gt;  &lt;summary&gt; Add leafwise math operations to PyTreeClass wrapped class&lt;/summary&gt;```pythonimport functools as ftimport pytreeclass as pytcimport jaximport jax.tree_util as jtuimport jax.numpy as jnp@ft.partial(pytc.treeclass, leafwise=True)class Tree:    a: int = 1    b: tuple[float] = (2., 3.)    c: jax.Array = jnp.array([4., 5., 6.])    def __call__(self, x):        return self.a + self.b[0] + self.c + xtree = Tree()tree + 100# Tree(a=101, b=(102.0, 103.0), c=f32[3](Î¼=105.00, Ïƒ=0.82, âˆˆ[104.00,106.00]))@jax.graddef loss_func(tree: Tree, x: jax.Array):    tree = jtu.tree_map(pytc.unfreeze, tree, is_leaf=pytc.is_frozen)  # &lt;--- unfreeze the tree before calling it    preds = jax.vmap(tree)(x)  # &lt;--- vectorize the tree call over the leading axis    return jnp.mean(preds**2)  # &lt;--- return the mean squared error@jax.jitdef train_step(tree: Tree, x: jax.Array):    grads = loss_func(tree, x)    return tree - grads * 1e-3  # &lt;--- eliminate `tree_map`# lets freeze the non-differentiable parts of the tree# in essence any non inexact type should be frozen to# make the tree differentiable and work with jax transformationsjaxable_tree = jax.tree_util.tree_map(lambda x: pytc.freeze(x) if pytc.is_nondiff(x) else x, tree)for epoch in range(1_000):    jaxable_tree = train_step(jaxable_tree, jnp.ones([10, 1]))print(jaxable_tree)# **the `frozen` params have &quot;#&quot; prefix**# Tree(a=#1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])# unfreeze the treetree = jax.tree_util.tree_map(pytc.unfreeze, jaxable_tree, is_leaf=pytc.is_frozen)print(tree)# Tree(a=1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])```&lt;/details&gt;&lt;details&gt; &lt;summary&gt;Eliminate tree_map using bcmap + treeclass(..., leafwise=True) &lt;/summary&gt;TDLR```pythonimport functools as ftimport pytreeclass as pytcimport jax.numpy as jnp@ft.partial(pytc.treeclass, leafwise=True)class Tree:    a:int = 1    b:tuple[float] = (2.,3.)    c:jax.Array = jnp.array([4.,5.,6.])tree = Tree()print(pytc.bcmap(jnp.where)(tree&gt;2, tree+100, 0))# Tree(a=0, b=(0.0, 103.0), c=[104. 105. 106.])````bcmap(func, is_leaf)` maps a function over [PyTrees](https://jax.readthedocs.io/en/latest/pytrees.html) leaves with automatic broadcasting for scalar arguments.`bcmap` is function transformation that broadcast a scalar to match the first argument of the function this enables us to convert a function like `jnp.where` to work with arbitrary tree structures without the need to write a specific function for each broadcasting caseFor example, lets say we want to use `jnp.where` to zeros out all values in an arbitrary tree structure that are less than 0tree = ([1], {&quot;a&quot;:1, &quot;b&quot;:2}, (1,), -1,)we can use `jax.tree_util.tree_map` to apply `jnp.where` to the tree but we need to write a specific function for broadcasting the scalar to the tree```pythondef map_func(leaf):    # here we encoded the scalar `0` inside the function    return jnp.where(leaf&gt;0, leaf, 0)jtu.tree_map(map_func, tree)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(0, dtype=int32, weak_type=True))```However, lets say we want to use `jnp.where` to set a value to a leaf value from another tree that looks like this```pythondef map_func2(lhs_leaf, rhs_leaf):    # here we encoded the scalar `0` inside the function    return jnp.where(lhs_leaf&gt;0, lhs_leaf, rhs_leaf)tree2 = jtu.tree_map(lambda x: 1000, tree)jtu.tree_map(map_func2, tree, tree2)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(1000, dtype=int32, weak_type=True))```Now, `bcmap` makes this easier by figuring out the broadcasting case.```pythonbroadcastable_where = pytc.bcmap(jnp.where)mask = jtu.tree_map(lambda x: x&gt;0, tree)```case 1```pythonbroadcastable_where(mask, tree, 0)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(0, dtype=int32, weak_type=True))```case 2```pythonbroadcastable_where(mask, tree, tree2)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(1000, dtype=int32, weak_type=True))```lets then take this a step further to eliminate `mask` from the equationby using `pytreeclass` with `leafwise=True ````python@ft.partial(pytc.treeclass, leafwise=True)class Tree:    tree : tuple = ([1], {&quot;a&quot;:1, &quot;b&quot;:2}, (1,), -1,)tree = Tree()# Tree(tree=([1], {a:1, b:2}, (1), -1))```case 1: broadcast scalar to tree````pythonprint(broadcastable_where(tree&gt;0, tree, 0))# Tree(tree=([1], {a:1, b:2}, (1), 0))case 2: broadcast tree to tree```pythonprint(broadcastable_where(tree&gt;0, tree, tree+100))# Tree(tree=([1], {a:1, b:2}, (1), 99))`````bcmap` also works with all kind of arguments in the wrapped function```pythonprint(broadcastable_where(tree&gt;0, x=tree, y=tree+100))# Tree(tree=([1], {a:1, b:2}, (1), 99))```in concolusion, `bcmap` is a function transformation that can be used toto make functions work with arbitrary tree structures without the need to writea specific function for each broadcasting caseMoreover, `bcmap` can be more powerful when used with `pytreeclass` tofacilitate operation of arbitrary functions on `PyTree` objectswithout the need to use `tree_map`&lt;/details&gt;&lt;details&gt;&lt;summary&gt;Use PyTreeClass vizualization tools with arbitrary PyTrees &lt;/summary&gt;```pythonimport jaximport pytreeclass as pytctree = [1, [2,3], 4]print(pytc.tree_diagram(tree, depth=1))# list# â”œâ”€â”€ [0]=1# â”œâ”€â”€ [1]=[...]# â””â”€â”€ [2]=4print(pytc.tree_diagram(tree, depth=2))# list# â”œâ”€â”€ [0]=1# â”œâ”€â”€ [1]:list# â”‚   â”œâ”€â”€ [0]=2# â”‚   â””â”€â”€ [1]=3# â””â”€â”€ [2]=4print(pytc.tree_summary(tree, depth=1))# â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Nameâ”‚Typeâ”‚Countâ”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[0] â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[1] â”‚listâ”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[2] â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£   â”‚listâ”‚3    â”‚# â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜print(pytc.tree_summary(tree, depth=2))# â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Name  â”‚Typeâ”‚Countâ”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[0]   â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[1][0]â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[1][1]â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[2]   â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£     â”‚listâ”‚4    â”‚# â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;Use PyTreeClass components with other libraries&lt;/summary&gt;```pythonimport jaximport pytreeclass as pytcfrom flax import struct@struct.dataclassclass FlaxTree:    a:int = 1    b:tuple[float] = (2.,3.)    c:jax.Array = jax.numpy.array([4.,5.,6.])    def __repr__(self) -&gt; str:        return pytc.tree_repr(self)    def __str__(self) -&gt; str:        return pytc.tree_str(self)    @property    def at(self):        return pytc.tree_indexer(self)def pytc_flatten_rule(tree):    names =(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)    types = map(type, (tree.a, tree.b, tree.c))    indices = range(3)  # make it indexable like namedtuple    return [*zip(names, types, indices)]pytc.register_pytree_node_trace(FlaxTree, pytc_flatten_rule)flax_tree = FlaxTree()print(f&quot;{flax_tree!r}&quot;)# FlaxTree(a=1, b=(2.0, 3.0), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))print(f&quot;{flax_tree!s}&quot;)# FlaxTree(a=1, b=(2.0, 3.0), c=[4. 5. 6.])print(pytc.tree_diagram(flax_tree))# FlaxTree# â”œâ”€â”€ a=1# â”œâ”€â”€ b:tuple# â”‚   â”œâ”€â”€ [0]=2.0# â”‚   â””â”€â”€ [1]=3.0# â””â”€â”€ c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])print(pytc.tree_summary(flax_tree))# â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Nameâ”‚Type    â”‚Countâ”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚a   â”‚int     â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚b[0]â”‚float   â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚b[1]â”‚float   â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚c   â”‚f32[3]  â”‚3    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£   â”‚FlaxTreeâ”‚6    â”‚# â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜flax_tree.at[0].get()# FlaxTree(a=1, b=(None, None), c=None)flax_tree.at[&quot;a&quot;].set(10)# FlaxTree(a=10, b=(2.0, 3.0), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;Benchmark flatten/unflatten compared to Flax and Equinox &lt;/summary&gt;&lt;a href=&quot;https://colab.research.google.com/github/ASEM000/PyTreeClass/blob/main/assets/benchmark_flatten_unflatten.ipynb&quot; target=&quot;_parent&quot;&gt;&lt;img src=&quot;https://colab.research.google.com/assets/colab-badge.svg&quot; alt=&quot;Open In Colab&quot;/&gt;&lt;/a&gt;&lt;table&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;CPU&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;GPU&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src='assets/benchmark_cpu.png'&gt;&lt;/td&gt;&lt;td&gt;&lt;img src='assets/benchmark_gpu.png'&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/details&gt;&lt;details&gt; &lt;summary&gt;Use tree_map_with_trace&lt;/summary&gt;V0.2 of `PyTreeClass` register common python datatypes and `treeclass` wrapped class to `trace` registry.While `jax` uses `jax.tree_util.register_pytree_node` to define `flatten_rule` for leaves, `PyTreeClass` extends on thisBy registering the `flatten_rule` of (1) names, (2) types, (3) indexingFor demonstration , the following figure contains the 4 variants of the same `Tree` instance define```pythonimport jaximport jax.numpy as jnpimport pytreeclass as pytc@pytc.treeclassclass Tree:    a:int = 1    b:tuple[float] = (2.,3.)    c:jax.Array = jnp.array([4.,5.,6.])```![image](assets/tree_figures.png)1. Value leaves variant.2. Name leaves variant.3. Type leaves variant.4. Indexing leaves variant.The four variants can be accessed using `pytc.tree_map_with_trace` .Similar to `jax.tree_util.tree_map`, `pytc.tree_map_with_trace` accepts the map function, however the first argument must be the `trace` argument.Trace is a four item tuple consists of names,types,indices,metadatas path for each leaf.For example for the previous tree, the reuslting trace path for each leaf is :### Named tree variant```python&gt;&gt;&gt; name_tree = pytc.tree_map_with_trace(lambda trace,x : trace[0], tree)&gt;&gt;&gt; print(name_tree)Tree(a=(a), b=((b, [0]), (b, [1])), c=(c))```### Typed tree variant```python&gt;&gt;&gt; type_tree = pytc.tree_map_with_trace(lambda trace,x : f&quot;{trace[1]!s}&quot;, tree)&gt;&gt;&gt; print(type_tree)Tree(  a=(&lt;class 'int'&gt;,),  b=((&lt;class 'tuple'&gt;, &lt;class 'float'&gt;), (&lt;class 'tuple'&gt;, &lt;class 'float'&gt;)),  c=(&lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;,))```### Index tree variant```python&gt;&gt;&gt; index_tree = pytc.tree_map_with_trace(lambda trace,x : trace[2], tree)&gt;&gt;&gt; print(index_tree)Tree(a=(0), b=((1, 0), (1, 1)), c=(2))```In essence, each leaf contains information about the name path, type path, and indices path. The rules for custom types can be registered using `pytc.register_pytree_node_trace`&lt;/details&gt;&lt;details&gt;&lt;summary&gt; Comparison with dataclass &lt;/summary&gt;&lt;div align=&quot;center&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;  &lt;td&gt;PyTreeClass&lt;/td&gt;  &lt;td&gt;dataclass&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Generated init method&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Generated repr method&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Generated str method&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Generated hash method&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Generated eq method&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…âœ…*&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Support slots&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Keyword-only args&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ… 3.10+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Positional-only args&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Frozen instance&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…**&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Match args support&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Support callbacks&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Support alias name&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;âœ…&lt;/td&gt;  &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;`*` Either compare the whole instance and return `True/False` or treating it leafwise using `treeclass(..., leafwise=True)` and retrurn `Tree(a=True, ....)``**` Always frozen. non-frozen is not supported.`***` `treeclass` decorator is also a bit faster than `dataclasses.dataclass` [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ASEM000/PyTreeClass/blob/main/assets/pytc_dc_benchmark.ipynb)&lt;/details&gt;## ğŸ“™ Acknowledgements&lt;a id=&quot;acknowledgements&quot;&gt;&lt;/a&gt;- [Farid Talibli (for visualization link generation backend)](https://www.linkedin.com/in/frdt98)- [Treex](https://github.com/cgarciae/treex), [Equinox](https://github.com/patrick-kidger/equinox), [tree-math](https://github.com/google/tree-math), [Flax](https://github.com/google/flax), [TensorFlow](https://www.tensorflow.org), [PyTorch](https://pytorch.org)- [Lovely JAX](https://github.com/xl0/lovely-jax)</longdescription>
</pkgmetadata>