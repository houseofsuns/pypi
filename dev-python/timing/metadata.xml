<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. role:: python(code)    :language: python======timing======Simplify logging of timings of selected parts of an application... image:: https://img.shields.io/pypi/v/timing.svg    :target: https://pypi.org/project/timing    :alt: package version from PyPI.. image:: https://github.com/mbdevpl/timing/actions/workflows/python.yml/badge.svg?branch=main    :target: https://github.com/mbdevpl/timing/actions    :alt: build status from GitHub.. image:: https://codecov.io/gh/mbdevpl/timing/branch/main/graph/badge.svg    :target: https://codecov.io/gh/mbdevpl/timing    :alt: test coverage from Codecov.. image:: https://api.codacy.com/project/badge/Grade/5dba9ea9f47e4e86aeed6eddfce42640    :target: https://app.codacy.com/gh/mbdevpl/timing    :alt: grade from Codacy.. image:: https://img.shields.io/github/license/mbdevpl/timing.svg    :target: https://github.com/mbdevpl/timing/blob/v0.5.0/NOTICE    :alt: license.. contents::    :backlinks: noneHow to use==========Recommended initialization is as follows... code:: python    import timing    _TIME = timing.get_timing_group(__name__)  # type: timing.TimingGroupThis follows the conventions of :python:`logging` module... code:: python    import logging    _LOG = logging.getLogger(__name__)Any name can be used instead of :python:`__name__`.However, if names of format :python:`module.sub.sub_sub` are used, this will create a timinghierarchy where each timing data is stored in its proper location and can be queried easier.The resulting :python:`_TIME` object is used to create individual timers,and will handle storing results in cache, which later can be used to obtain timing statistics.You can obtain the timer object directly via :python:`start(name)` method.You'll need to manually call :python:`stop()` in this case... code:: python   timer = _TIME.start('spam')  # type: timing.Timing   spam()   more_spam()   timer.stop()You can also obtain the timer object indirectly via :python:`measure(name)` context manager.The context manager will take care of calling :python:`stop()` at the end... code:: python    with _TIME.measure('ham') as timer:  # type: timing.Timing        ham()        more_ham()And if you want to time many repetitions of the same action (e.g. for statistical significance)you can use :python:`measure_many(name[, samples][, threshold])` generator.You can decide how many times you want to measure via :python:`samples` parameterand how many seconds at most you want to spend on measurements via :python:`threshold` parameter.. code:: python    for timer in _TIME.measure_many('eggs', samples=1000):  # type: timing.Timing        eggs()        more_eggs()    for timer in _TIME.measure_many('bacon', threshold=0.5):  # type: timing.Timing        bacon()        more_bacon()    for timer in _TIME.measure_many('tomatoes', samples=500, threshold=0.5):  # type: timing.Timing        tomatoes()        more_tomatoes()Also, you can use :python:`measure` and :python:`measure(name)` as decorator.In this scenario you cannot access the timings directly, but the results will be storedin the timing group object, as well as in the global cache unless you configure the timingto not use the cache... code:: python    import timing    _TIME = timing.get_timing_group(__name__)    @_TIME.measure    def recipe():        ham()        eggs()        bacon()    @_TIME.measure('the_best_recipe')    def bad_recipe():        spam()        spam()        spam()Then, after calling each function the results can be accessed through :python:`summary` property... code:: python    recipe()    bad_recipe()    bad_recipe()    assert _TIME.summary['recipe']['samples'] == 1    assert _TIME.summary['the_best_recipe']['samples'] == 2The :python:`summary` property is dynamically computed on first access. Subsequent accesseswill not recompute the values, so if you need to access the updated results,call the :python:`summarize()` method... code:: python    recipe()    assert _TIME.summary['recipe']['samples'] == 1    bad_recipe()    bad_recipe()    assert _TIME.summary['the_best_recipe']['samples'] == 2  # will fail    _TIME.summarize()    assert _TIME.summary['the_best_recipe']['samples'] == 2  # okFurther API and documentation are in development.See these examples in action in `examples.ipynb &lt;https://github.com/mbdevpl/timing/blob/v0.5.0/examples.ipynb&gt;`_ notebook.Requirements============Python version 3.11 or later.Python libraries as specified in `requirements.txt &lt;https://github.com/mbdevpl/timing/blob/v0.5.0/requirements.txt&gt;`_.Building and running tests additionally requires packages listed in `&lt;test_requirements.txt&gt;`_.Tested on Linux and OS X.</longdescription>
</pkgmetadata>