<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Run tests](https://github.com/City-of-Helsinki/django-helusers/actions/workflows/test.yml/badge.svg)](https://github.com/City-of-Helsinki/django-helusers/actions/workflows/test.yml)[![codecov](https://codecov.io/gh/City-of-Helsinki/django-helusers/branch/master/graph/badge.svg?token=bOfnYCJsWW)](https://codecov.io/gh/City-of-Helsinki/django-helusers)# Django app for City of Helsinki user infrastructureDjango-helusers is your friendly app for bolting authentication into Django projects for City of Helsinki. Authentication schemes are based on [OAuth2](https://oauth.net/2/) and [OpenID Connect (OIDC)](https://openid.net/connect/).A baseline `User` model is provided that can be used with the various authentication use cases that are supported. The model supports mapping from AD groups to Django groups based on the authentication data.Additionally, there are **optional** functionalities that can be used as needed.Functionalities for server needing (API) access token verification:* For servers using Django REST Framework* For servers not using Django REST FrameworkFunctionalities for server needing to authenticate against OIDC or OAuth2 server:* support Django session login against OIDC or OAuth2 server, including Helsinki Tunnistus service and Azure AD* augmented login template for Django admin, adding OIDC/OAuth2 login button## Adding django-helusers your Django projectAdd `django-helusers` in your project's dependencies.Some optional features of `django-helusers` have additional dependencies.These are mentioned in their relevant sections.### Adding django-helusers Django appsDjango-helusers provides two Django apps: `HelusersConfig` provides themodels and templates needed for helusers to work and `HelusersAdminConfig`reconfigures Django admin to work with helusers.Before adding the apps, you will need to remove `django.contrib.admin`, as`HelusersAdminConfig` is implementation of same functionality. You will get`django.core.exceptions.ImproperlyConfigured: Application labels aren't unique, duplicates:admin`-error, if you forget this step.Then proceed by adding these apps to your `INSTALLED_APPS` in settings.py:```pythonINSTALLED_APPS = (    'helusers.apps.HelusersConfig',    'helusers.apps.HelusersAdminConfig',    ...)```Us usual with `INSTALLED_APPS`, ordering matters. `HelusersConfig` must comebefore `HelusersAdminConfig` and anything else providing admin templates.Unless, of course, you wish to override the admin templates provided here.One possible gotcha is, if you've added custom views to admin withoutforwarding context from `each_context` to the your template.  Heluserstemplates expect variables from `each_context` and will break if they aremissing.### Adding user modelhelusers provides a baseline user model adding fields for Helsinkispecific information. As per Django [best practice](https://docs.djangoproject.com/en/3.0/topics/auth/customizing/#using-a-custom-user-model-when-starting-a-project)you should subclass this model to make future customization easier:```python# users/models.pyfrom helusers.models import AbstractUserclass User(AbstractUser):    pass```and reference it in settings.py:```python# myproject/settings.pyAUTH_USER_MODEL = 'users.User'```## Optional features### Django REST Framework API authentication using JWTIf you have a REST API implemented using Django REST Framework and you want to authorize access to your API using JWTs, then this might be useful to you.API token authentication is a stateless authentication method, where every request isauthenticated by checking the signature of the included JWT token. It stillcreates a persistent Django user, which is updated with the informationfrom the token with every request.- Configure REST framework to use the `ApiTokenAuthentication` class in `settings.py`:```pythonREST_FRAMEWORK = {    'DEFAULT_AUTHENTICATION_CLASSES': (        'helusers.oidc.ApiTokenAuthentication',    ),}```- Set your deployment-specific variables in your project settings. See [Token authentication settings](#token-authentication-settings)### API authentication using JWT in any setupIf you want to authorize access to your API using JWTs, but you are not using Django REST Framework, then this might be useful to you.API token authentication is a stateless authentication method, where every request is authenticated by checking the signature of the included JWT token.It still creates a persistent Django user, which is updated with the information from the token with every request.Django-helusers contains a `helusers.oidc.RequestJWTAuthentication` class.It has a method called `authenticate` that takes a [Django HttpRequest](https://docs.djangoproject.com/en/3.1/ref/request-response/#django.http.HttpRequest) as an argument, looks for a JWT from that request and performs authentication.User of this class can use it in any way they need to perform authentication and/or authorization.Check the class documentation for more details.### Token authentication settingsSome settings are needed (and some are optional) that affect how the `ApiTokenAuthentication` and `RequestJWTAuthentication` classes work.```pythonOIDC_API_TOKEN_AUTH = {    # Audience that must be present in the token for it to be    # accepted. Value must be agreed between your SSO service and your    # application instance. Essentially this allows your application to    # know that the token is meant to be used with it.    # Multiple acceptable audiences are supported,    # so this setting can also be a list of strings.    # This setting is required.    'AUDIENCE': 'https://api.hel.fi/auth/projects',    # Who we trust to sign the tokens. The library will request the    # public signature keys from standard locations below this URL.    # Multiple issuers are supported, so this    # setting can also be a list of strings.    # Default is https://tunnistamo.hel.fi.    'ISSUER': 'https://api.hel.fi/sso/openid',    # The following can be used if you need certain scopes for any    # functionality of the API. Usually this is not needed, as checking    # the audience is enough. Default is False.    'REQUIRE_API_SCOPE_FOR_AUTHENTICATION': True,    # The name of the claim that is used to read in the scopes from the JWT.    # Supports multiple fields as a list. If the field is deeper in the claims    # use dot notation. e.g. &quot;authorization.permissions.scopes&quot;    # Default is https://api.hel.fi/auth.    'API_AUTHORIZATION_FIELD': 'scope_field',    # The request will be denied if scopes don't contain anything starting    # with the value provided here. Supports multiple scope prefixes as a list.    # Only one scope needs to match if multiple prefixes are provided.    'API_SCOPE_PREFIX': 'projects',    # In order to do the authentication the token authentication classes need    # some facts from the authorization server, mainly its public keys for    # verifying the JWT's signature. This setting controls the time how long    # authorization server configuration and public keys are &quot;remembered&quot;.    # The value is in seconds. Default is 24 hours.    'OIDC_CONFIG_EXPIRATION_TIME': 600,}```### OIDC back channel logout endpointDjango-helusers provides an [OIDC back channel logout](https://openid.net/specs/openid-connect-backchannel-1_0.html) endpoint implementation.By default the OIDC back channel logout endpoint is disabled. You can enable it in your project's settings:```python# myproject/settings.pyHELUSERS_BACK_CHANNEL_LOGOUT_ENABLED = True# These settings specify which authentication server(s) are trusted# to send back channel logout requests.OIDC_API_TOKEN_AUTH = {    # Who we trust to sign the logout tokens. The library will request    # the public signature keys from standard locations below this URL.    # Multiple issuers are supported, so this setting can also be a list    # of strings. Default is https://tunnistamo.hel.fi.    'ISSUER': 'https://api.hel.fi/sso/openid',    # Audience that must be present in the logout token for it to    # be accepted. Value must be agreed between your SSO service    # and your application instance. Essentially this allows your    # application to know that the token is meant to be used with    # it. Multiple acceptable audiences are supported, so this    # setting can also be a list of strings. This setting is required.    'AUDIENCE': 'https://api.hel.fi/auth/projects',}```You will also need to add Django-helusers URLs to your URL dispatcher configuration:```python# myproject/urls.pyurlpatterns = [    ...    # You can adjust the prefix as you want    path('helauth/', include('helusers.urls')),    ...]```With these settings your project now provides an endpoint at `https://&lt;your-domain&gt;/helauth/logout/oidc/backchannel/` that responds to the OIDC back channel logout requests.When the endpoint receives a valid request, it stores information about the logout event to the database. This information is used when authentication for other requests is performed. The `helusers.oidc.RequestJWTAuthentication` class that performs authentication based on a JWT bearer token, checks if the token's session has been terminated (by a logout event), and if that's the case, it doesn't authenticate the caller.#### Logout event callbackThe project using the OIDC back channel logout functionality has an option to attach a callback into the logout event handler. This is done by telling Django-helusers where this callback is located. Configure it in your project's settings:```python# myproject/settings.pyHELUSERS_BACK_CHANNEL_LOGOUT_CALLBACK = &quot;myproject.utils.logout_callback&quot;```When a valid logout event is received, the callback is called. The callback receives two keyword arguments:* `request`: the [HttpRequest](https://docs.djangoproject.com/en/2.2/ref/request-response/#httprequest-objects) object describing the request to the logout endpoint* `jwt`: a `helusers.jwt.JWT` instance of the logout tokenThe callback can affect the result of the back channel logout event handling by returning an [HttpResponse](https://docs.djangoproject.com/en/2.2/ref/request-response/#httpresponse-objects) instance with a status code between 400 and 599 inclusive. If such a response object is returned by the callback, the logout event handling is terminated and the response is sent to the requester. Any other kind of return value from the callback is ignored.### Adding Tunnistamo authenticationdjango-helusers ships with backend for authenticating against Tunnistamousing OIDC. Configuring this includes a Tunnistamo login button to the admin login screen.There is also a deprecated legacy OAuth2 backend usingallauth framework.Include `social-auth-app-django` in your project's dependencies.Add `social_django` into your `INSTALLED_APPS` setting:```python# myproject/settings.pyINSTALLED_APPS = (    ...    'social_django',    ...)```Typically you would want to support authenticating using both OIDC and localdatabase tables. Local users are useful for initial django admin login, beforeyou've delegated permissions to users coming through OIDC.Add backend configuration to your `settings.py`:```pythonAUTHENTICATION_BACKENDS = [    'helusers.tunnistamo_oidc.TunnistamoOIDCAuth',    'django.contrib.auth.backends.ModelBackend',]LOGIN_REDIRECT_URL = '/'LOGOUT_REDIRECT_URL = '/'````LOGIN_REDIRECT_URL` is the default landing URL after succesful login, if yourform did not specify anything else.`LOGOUT_REDIRECT_URL` is the same for logout. django-helusers requires thisto be set.Configure `social_django` [authentication pipeline](https://python-social-auth.readthedocs.io/en/latest/pipeline.html)to handle the users. Django-helusers provides a default pipeline that could wellsuit your needs. Use it by importing it into your `settings.py`:```pythonfrom helusers.defaults import SOCIAL_AUTH_PIPELINE```If the default pipeline isn't suitable for your needs as is, build your pipelineby hand and set the `SOCIAL_AUTH_PIPELINE` setting to it. You can use the defaultpipeline as an inspiration and use the functions from `helusers.pipeline` in yourown pipeline.You will also need to add URLs for `social_django` &amp; `helusers` to your URLdispatcher configuration (`urls.py`):```pythonurlpatterns = [    ...    path('pysocial/', include('social_django.urls', namespace='social')),    path('helauth/', include('helusers.urls')),    ...]```You can change the paths if they conflict with your application.Finally, you will need to configure your SESSION_SERIALIZER. helusers storesthe access token expiration time as a datetime which is not serializableto JSON, so Django needs to be configured to use the built-inPickleSerializer:```pythonSESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'```#### Django session loginDjango session login is the usual login to Django that sets up a sessionand is typically implemented using a browser cookie. This is usually doneusing form with username &amp; password fields. Django-helusers adds anotherpath that delegates the login to an OIDC provider. User logs in at theprovider and, upon successful return, a Django session is created for them.For us, the main use case has been allowing logins to Django admin.To support session login Django-helusers needs three settings that mustbe configured both at Helsinki OIDC provider and your project instance.The settings are:* client ID* client secret* Tunnistamo OIDC endpoint`Client` is OAuth2 / OIDC name for anything wanting to authenticateusers. Thus your application would be a `client`Additionally you will need to provide your &quot;callback URL&quot; to the folksconfiguring Tunnistamo. This is implemented by `python-social-auth` andwill, by default, be `https://app.domain/auth/complete/tunnistamo/`. Duringdevelopment on your own laptop your `app.domain` would be `localhost`.After you've received your client ID, client secret and Tunnistamo OIDCendpoint you would configure them as follows:```pythonSOCIAL_AUTH_TUNNISTAMO_KEY = 'https://i/am/clientid/in/url/style'SOCIAL_AUTH_TUNNISTAMO_SECRET = 'iamyoursecret'SOCIAL_AUTH_TUNNISTAMO_OIDC_ENDPOINT = 'https://tunnistamo.example.com/'```Note that `client ID` becomes `KEY` and `client secret` becomes `SECRET`.#### Active Directory groupsHelusers can sync users AD groups to local Django groups when using an AD login method in Tunnistamo. To enable groups sync you should add &quot;ad_groups&quot; scope to the Tunnistamo OIDC authorize call. It can be done by addingthe following to the settings:```pythonSOCIAL_AUTH_TUNNISTAMO_SCOPE = 'ad_groups'```That setting will add &quot;ad_groups&quot; scope to the default social auth scopes&quot;openid profile email&quot;. If you would like to modify the default socialauth scopes you can set all of the scopes in the `SOCIAL_AUTH_TUNNISTAMO_SCOPE` setting and set `SOCIAL_AUTH_TUNNISTAMO_IGNORE_DEFAULT_SCOPE` to `True`.Additionally, the client in Tunnistamo should be configured with AD groupsenabled.When the users returns from Tunnistamo with &quot;ad_groups&quot; claim set Helusers will add all of the groups as an instance of `ADGroup` model to the database.Then, Helusers will add any missing ADGroups to the users' ad_groups-relationand remove any ADGroups the user is not a member of anymore.To use groups in Django permissions, you should use the Django admin view (HELSINKI USERS &gt; AD Group Mappings) to set mappings between ADGroups and Groups. Helusers will then add the user to Django groups that are mappedto their AD Groups.Note that after creating mappings you cannot manually add a user to a mappedgroup if they are not a member of the corresponding AD group because thegroup will be removed the next time the user logs in.#### Adding tunnistamo URL to template contextIf you need to access the Tunnistamo API from your JS code, you can includethe Tunnistamo base URL in your template context using helusers's context processor:```pythonTEMPLATES = [    {        'OPTIONS': {            'context_processors': [                'helusers.context_processors.settings'            ]        }    }]```#### Carrying language preference from your application to TunnistamoTunnistamo (per the OIDC specs) allows clients to specify the language used forthe login process. This allows you to carry your applications language settingto the login screens presented by Tunnistamo.Configure `python-social-auth` to pass the necessary argument through itslogin view:```pythonSOCIAL_AUTH_TUNNISTAMO_AUTH_EXTRA_ARGUMENTS = {'ui_locales': 'fi'}````fi` there is the language code that will be used when no language is requested, so change it if you you prefer someother default language. If you don't want to set a default language at all, use an empty string `&quot;&quot;` as the languagecode.When this setting is in place, languages can be requested using query param `ui_locales=&lt;language code&gt;` when startingthe login process, for example in your template```&lt;a href=&quot;{% url 'helusers:auth_login' %}?next=/foobar/&amp;ui_locales=en&quot;&gt;Login in English&lt;/a&gt;```#### Disabling password loginsIf you're not allowing users to log in with passwords, you may disable theusername/password form from Django admin login page by setting `HELUSERS_PASSWORD_LOGIN_DISABLED`to `True`.# DevelopmentVirtual Python environment can be used. For example:```bashpython3 -m venv .venvsource .venv/bin/activate```Install package requirements:```bashpip install -e .```Install development requirements:```bashpip install -r requirements-test.txt```## Running tests```bashpytest```You can run the tests against multiple environments by using [tox](https://tox.readthedocs.io/en/latest/).Install `tox` globally and run:```bashtox```</longdescription>
</pkgmetadata>