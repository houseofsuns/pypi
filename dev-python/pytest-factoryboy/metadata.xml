<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>factory_boy_ integration with the pytest_ runner================================================.. image:: https://img.shields.io/pypi/v/pytest-factoryboy.svg   :target: https://pypi.python.org/pypi/pytest-factoryboy.. image:: https://img.shields.io/pypi/pyversions/pytest-factoryboy.svg  :target: https://pypi.python.org/pypi/pytest-factoryboy.. image:: https://github.com/pytest-dev/pytest-factoryboy/actions/workflows/main.yml/badge.svg    :target: https://github.com/pytest-dev/pytest-factoryboy/actions?query=workflow%3Amain.. image:: https://readthedocs.org/projects/pytest-factoryboy/badge/?version=latest    :target: https://readthedocs.org/projects/pytest-factoryboy/?badge=latest    :alt: Documentation Statuspytest-factoryboy makes it easy to combine ``factory`` approach to the test setup with the ``dependency`` injection,heart of the `pytest fixtures`_... _factory_boy: https://factoryboy.readthedocs.io.. _pytest: https://pytest.org.. _pytest fixtures: https://pytest.org/latest/fixture.html.. _overridden: https://docs.pytest.org/en/latest/how-to/fixtures.html#overriding-fixtures-on-various-levelsInstall pytest-factoryboy-------------------------::    pip install pytest-factoryboyConcept-------Library exports a function to register factories as fixtures. Fixtures are contributedto the same module where register function is called.Model Fixture-------------Model fixture implements an instance of a model created by the factory. Name convention is model's lowercase-underscoreclass name... code-block:: python    import factory    from pytest_factoryboy import register    @register    class AuthorFactory(factory.Factory):        class Meta:            model = Author        name = &quot;Charles Dickens&quot;    def test_model_fixture(author):        assert author.name == &quot;Charles Dickens&quot;Attributes are Fixtures-----------------------There are fixtures created automatically for factory attributes. Attribute names are prefixed with the model fixture name anddouble underscore (similar to the convention used by factory_boy)... code-block:: python    @pytest.mark.parametrize(&quot;author__name&quot;, [&quot;Bill Gates&quot;])    def test_model_fixture(author):        assert author.name == &quot;Bill Gates&quot;Multiple fixtures-----------------Model fixtures can be registered with specific names. For example, if you address instances of some collectionby the name like &quot;first&quot;, &quot;second&quot; or of another parent as &quot;other&quot;:.. code-block:: python    register(AuthorFactory)  # author    register(AuthorFactory, &quot;second_author&quot;)  # second_author    @register  # book    @register(_name=&quot;second_book&quot;)  # second_book    @register(_name=&quot;other_book&quot;)  # other_book, book of another author    class BookFactory(factory.Factory):        class Meta:            model = Book    @pytest.fixture    def other_book__author(second_author):        &quot;&quot;&quot;Make the relation of the `other_book.author` to `second_author`.&quot;&quot;&quot;        return second_author    def test_book_authors(book, second_book, other_book, author, second_author):        assert book.author == second_book.author == author        assert other_book.author == second_authorSubFactory----------Sub-factory attribute points to the model fixture of the sub-factory.Attributes of sub-factories are injected as dependencies to the model fixture and can be overridden_ viathe parametrization.Related Factory---------------Related factory attribute points to the model fixture of the related factory.Attributes of related factories are injected as dependencies to the model fixture and can be overridden_ viathe parametrization.post-generation---------------Post-generation attribute fixture implements only the extracted value for the post generation function.Factory Fixture---------------`pytest-factoryboy` also registers factory fixtures, to allow their use without importing them. The fixture name convention is to use the lowercase-underscore form of the class name... code-block:: python    import factory    from pytest_factoryboy import register    class AuthorFactory(factory.Factory):        class Meta:            model = Author    register(AuthorFactory)  # =&gt; author_factory    def test_factory_fixture(author_factory):        author = author_factory(name=&quot;Charles Dickens&quot;)        assert author.name == &quot;Charles Dickens&quot;Integration-----------An example of factory_boy_ and pytest_ integration... code-block:: python    # tests/factories.py    import factory    from app import models    from faker import Factory as FakerFactory    faker = FakerFactory.create()    class AuthorFactory(factory.django.DjangoModelFactory):        class Meta:            model = models.Author        name = factory.LazyFunction(lambda: faker.name())    class BookFactory(factory.django.DjangoModelFactory):        class Meta:            model = models.Book        title = factory.LazyFunction(lambda: faker.sentence(nb_words=4))        author = factory.SubFactory(AuthorFactory).. code-block:: python    # tests/conftest.py    from pytest_factoryboy import register    from . import factories    register(factories.AuthorFactory)    register(factories.BookFactory).. code-block:: python    # tests/test_models.py    from app.models import Book    from .factories import BookFactory    def test_book_factory(book_factory):        &quot;&quot;&quot;Factories become fixtures automatically.&quot;&quot;&quot;        assert book_factory is BookFactory    def test_book(book):        &quot;&quot;&quot;Instances become fixtures automatically.&quot;&quot;&quot;        assert isinstance(book, Book)    @pytest.mark.parametrize(&quot;book__title&quot;, [&quot;PyTest for Dummies&quot;])    @pytest.mark.parametrize(&quot;author__name&quot;, [&quot;Bill Gates&quot;])    def test_parametrized(book):        &quot;&quot;&quot;You can set any factory attribute as a fixture using naming convention.&quot;&quot;&quot;        assert book.title == &quot;PyTest for Dummies&quot;        assert book.author.name == &quot;Bill Gates&quot;Fixture partial specialization------------------------------There is a possibility to pass keyword parameters in order to override factory attribute values during fixtureregistration. This comes in handy when your test case is requesting a lot of fixture flavors. Too much for theregular pytest parametrization.In this case, you can register fixture flavors in the local test module and specify value deviations inside ``register``function calls... code-block:: python    register(AuthorFactory, &quot;male_author&quot;, gender=&quot;M&quot;, name=&quot;John Doe&quot;)    register(AuthorFactory, &quot;female_author&quot;, gender=&quot;F&quot;)    @pytest.fixture    def female_author__name():        &quot;&quot;&quot;Override female author name as a separate fixture.&quot;&quot;&quot;        return &quot;Jane Doe&quot;    @pytest.mark.parametrize(&quot;male_author__age&quot;, [42])  # Override even more    def test_partial(male_author, female_author):        &quot;&quot;&quot;Test fixture partial specialization.&quot;&quot;&quot;        assert male_author.gender == &quot;M&quot;        assert male_author.name == &quot;John Doe&quot;        assert male_author.age == 42        assert female_author.gender == &quot;F&quot;        assert female_author.name == &quot;Jane Doe&quot;Fixture attributes------------------Sometimes it is necessary to pass an instance of another fixture as an attribute value to the factory.It is possible to override the generated attribute fixture where desired values can be requested asfixture dependencies. There is also a lazy wrapper for the fixture that can be used in the parametrizationwithout defining fixtures in a module.LazyFixture constructor accepts either existing fixture name or callable with dependencies:.. code-block:: python    import pytest    from pytest_factoryboy import register, LazyFixture    @pytest.mark.parametrize(&quot;book__author&quot;, [LazyFixture(&quot;another_author&quot;)])    def test_lazy_fixture_name(book, another_author):        &quot;&quot;&quot;Test that book author is replaced with another author by fixture name.&quot;&quot;&quot;        assert book.author == another_author    @pytest.mark.parametrize(&quot;book__author&quot;, [LazyFixture(lambda another_author: another_author)])    def test_lazy_fixture_callable(book, another_author):        &quot;&quot;&quot;Test that book author is replaced with another author by callable.&quot;&quot;&quot;        assert book.author == another_author    # Can also be used in the partial specialization during the registration.    register(BookFactory, &quot;another_book&quot;, author=LazyFixture(&quot;another_author&quot;))Generic container classes as models-----------------------------------It's often useful to create factories for ``dict`` or other common generic container classes.In that case, you should wrap the container class around ``named_model(...)``, so that pytest-factoryboy can correctly determine the model name when using it in a SubFactory or RelatedFactory.Pytest-factoryboy will otherwise raise a warning.For example:.. code-block:: python    import factory    from pytest_factoryboy import named_model, register    @register    class JSONPayload(factory.Factory):        class Meta:            model = named_model(&quot;JSONPayload&quot;, dict)        name = &quot;foo&quot;    def test_foo(json_payload):        assert json_payload.name == &quot;foo&quot;As a bonus, factory is automatically registering the ``json_payload`` fixture (rather than ``dict``), so there is no need to override ``@register(_name=&quot;json_payload&quot;))``.Post-generation dependencies============================Unlike factory_boy which binds related objects using an internal container to store results of lazy evaluations,pytest-factoryboy relies on the PyTest request.Circular dependencies between objects can be resolved using post-generation hooks/related factories in combination withpassing the SelfAttribute, but in the case of PyTest request fixture functions have to return values in order to be cachedin the request and to become available to other fixtures.That's why evaluation of the post-generation declaration in pytest-factoryboy is deferred until callingthe test function.This solves circular dependency resolution for situations like:::    o-&gt;[ A ]--&gt;[ B ]&lt;--[ C ]-o    |                        |    o----(C depends on A)----oOn the other hand, deferring the evaluation of post-generation declarations evaluation makes their result unavailable during the generationof objects that are not in the circular dependency, but they rely on the post-generation action.pytest-factoryboy is trying to detect cycles and resolve post-generation dependencies automatically... code-block:: python    from pytest_factoryboy import register    class Foo(object):        def __init__(self, value):            self.value = value    class Bar(object):        def __init__(self, foo):            self.foo = foo    @register    class FooFactory(factory.Factory):        class Meta:            model = Foo        value = 0        @factory.post_generation        def set1(foo, create, value, **kwargs):            foo.value = 1    @register    class BarFactory(factory.Factory):        class Meta:            model = Bar        foo = factory.SubFactory(FooFactory)        @classmethod        def _create(cls, model_class, foo):            assert foo.value == 1  # Assert that set1 is evaluated before object generation            return super(BarFactory, cls)._create(model_class, foo=foo)    # Forces 'set1' to be evaluated first.    def test_depends_on_set1(bar):        &quot;&quot;&quot;Test that post-generation hooks are done and the value is 2.&quot;&quot;&quot;        assert bar.foo.value == 1Hooks-----pytest-factoryboy exposes several `pytest hooks &lt;http://pytest.org/latest/plugins.html#well-specified-hooks&gt;`_which might be helpful for e.g. controlling database transaction, for reporting etc:* pytest_factoryboy_done(request) - Called after all factory-based fixtures and their post-generation actions have been evaluated.License-------This software is licensed under the `MIT license &lt;http://en.wikipedia.org/wiki/MIT_License&gt;`_.Â© 2015 Oleg Pidsadnyi, Anatoly Bubenkov and others</longdescription>
</pkgmetadata>