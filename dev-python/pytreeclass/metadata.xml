<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;!-- &lt;h1 align=&quot;center&quot; style=&quot;font-family:Monospace&quot; &gt;PyğŸŒ²Class&lt;/h1&gt; --&gt;&lt;h5 align=&quot;center&quot;&gt;&lt;img width=&quot;250px&quot; src=&quot;https://user-images.githubusercontent.com/48389287/227880173-bf78c02c-d28b-4cf4-95e6-fa49b82a43a1.svg&quot;&gt; &lt;br&gt;&lt;br&gt;[**Installation**](#installation)|[**Description**](#description)|[**Quick Example**](#quick_example)|[**StatefulComputation**](#stateful_computation)|[**More**](#more)|[**Acknowledgements**](#acknowledgements)![Tests](https://github.com/ASEM000/pytreeclass/actions/workflows/tests.yml/badge.svg)![pyver](https://img.shields.io/badge/python-3.8%203.9%203.10%203.11_-red)![pyver](https://img.shields.io/badge/jax-0.4.7+-red)![codestyle](https://img.shields.io/badge/codestyle-black-black)[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ASEM000/PyTreeClass/blob/main/assets/intro.ipynb)[![Downloads](https://pepy.tech/badge/pytreeclass)](https://pepy.tech/project/pytreeclass)[![codecov](https://codecov.io/gh/ASEM000/pytreeclass/branch/main/graph/badge.svg?token=TZBRMO0UQH)](https://codecov.io/gh/ASEM000/pytreeclass)[![Documentation Status](https://readthedocs.org/projects/pytreeclass/badge/?version=latest)](https://pytreeclass.readthedocs.io/en/latest/?badge=latest)![GitHub commit activity](https://img.shields.io/github/commit-activity/m/ASEM000/pytreeclass)[![DOI](https://zenodo.org/badge/512717921.svg)](https://zenodo.org/badge/latestdoi/512717921)![PyPI](https://img.shields.io/pypi/v/pytreeclass)&lt;/h5&gt;**For previous `PyTreeClass` use v0.1 branch**## ğŸ› ï¸ Installation&lt;a id=&quot;installation&quot;&gt;&lt;/a&gt;```pythonpip install pytreeclass```**Install development version**```pythonpip install git+https://github.com/ASEM000/PyTreeClass```## ğŸ“– Description&lt;a id=&quot;description&quot;&gt;&lt;/a&gt;`PyTreeClass` is a JAX-compatible class builder to create and operate on stateful JAX PyTrees.The package aims to achieve _two goals_:1. ğŸ”’ To maintain safe and correct behaviour by using _immutable_ modules with _functional_ API.2. To achieve the **most intuitive** user experience in the `JAX` ecosystem by :   - ğŸ—ï¸ Defining layers similar to `PyTorch` or `TensorFlow` subclassing style.   - â˜ï¸ Filtering\Indexing layer values similar to `jax.numpy.at[].{get,set,apply,...}`   - ğŸ¨ Visualize defined layers in plethora of ways.## â© Quick Example &lt;a id=&quot;quick_example&quot;&gt;### ğŸ—ï¸ Simple Tree example&lt;div align=&quot;center&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;```pythonimport jaximport jax.numpy as jnpimport pytreeclass as pytcclass Tree(pytc.TreeClass):    a: int = 1    b: tuple = (2, 3.)    c: jax.Array = jnp.array([4., 5., 6.])    def __call__(self, x):        return self.a + self.b[0] + self.c + xtree = Tree()mask = jax.tree_map(lambda x: x &gt; 5, tree)tree = tree \       .at[&quot;a&quot;].set(10) \       .at[&quot;b&quot;].at[0].set(10) \       .at[mask].set(100)print(tree)# Tree(a=10, b=(10, 3.0), c=[  4.   5. 100.])print(pytc.tree_diagram(tree))# Tree# â”œâ”€â”€ .a=10# â”œâ”€â”€ .b:tuple# â”‚   â”œâ”€â”€ [0]=10# â”‚   â””â”€â”€ [1]=3.0# â””â”€â”€ .c=f32[3](Î¼=36.33, Ïƒ=45.02, âˆˆ[4.00,100.00])print(pytc.tree_summary(tree))# â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Name â”‚Type  â”‚Countâ”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.a   â”‚int   â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.b[0]â”‚int   â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.b[1]â”‚float â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.c   â”‚f32[3]â”‚3    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£    â”‚Tree  â”‚6    â”‚# â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜# ** pass it to jax transformations **# freeze all non-differentiable parameters to make it# work with jax trnasformationsmask = jax.tree_map(pytc.is_nondiff, tree)tree = tree.at[mask].apply(pytc.freeze)@jax.jit@jax.graddef sum_tree(tree:Tree, x):    # unfreeze before calling tree    tree = tree.at[...].apply(pytc.unfreeze, is_leaf=pytc.is_frozen)    return sum(tree(x))print(sum_tree(tree, 1.0))# Tree(a=#10, b=(#10, 0.0), c=[1. 1. 1.])```&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;### ğŸ¨ Visualize&lt;a id=&quot;Viz&quot;&gt;&lt;details&gt; &lt;summary&gt; Visualize PyTrees&lt;/summary&gt;&lt;div align=&quot;center&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td align = &quot;center&quot;&gt; tree_summary&lt;/td&gt;  &lt;td align = &quot;center&quot;&gt;tree_diagram&lt;/td&gt; &lt;td align = &quot;center&quot;&gt;[tree_mermaid](https://mermaid.js.org)(Native support in Github/Notion)&lt;/td&gt; &lt;td align= &quot;center&quot;&gt; tree_repr &lt;/td&gt; &lt;td align=&quot;center&quot; &gt; tree_str &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;```pythonprint(pytc.tree_summary(tree, depth=1))â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”â”‚Nameâ”‚Type  â”‚Countâ”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.a  â”‚int   â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.b  â”‚tuple â”‚1    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.c  â”‚f32[3]â”‚3    â”‚â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚Î£   â”‚Tree  â”‚5    â”‚â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_diagram(tree, depth=1))Treeâ”œâ”€â”€ .a=1â”œâ”€â”€ .b=(...)â””â”€â”€ .c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])``` &lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_mermaid(tree, depth=1))``````mermaidflowchart LR    id0(&lt;b&gt;Tree&lt;/b&gt;)    id0 --- id1(&quot;&lt;/b&gt;.a=1&lt;/b&gt;&quot;)    id0 --- id2(&quot;&lt;/b&gt;.b=(...)&lt;/b&gt;&quot;)    id0 --- id3(&quot;&lt;/b&gt;.c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])&lt;/b&gt;&quot;)```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_repr(tree, depth=1))Tree(a=1, b=(...), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_str(tree, depth=1))Tree(a=1, b=(...), c=[4. 5. 6.])```&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;```pythonprint(pytc.tree_summary(tree, depth=2))â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”â”‚Name â”‚Type  â”‚Countâ”‚â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.a   â”‚int   â”‚1    â”‚â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.b[0]â”‚int   â”‚1    â”‚â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.b[1]â”‚float â”‚1    â”‚â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚.c   â”‚f32[3]â”‚3    â”‚â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤â”‚Î£    â”‚Tree  â”‚6    â”‚â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_diagram(tree, depth=2))Treeâ”œâ”€â”€ .a=1â”œâ”€â”€ .b:tupleâ”‚   â”œâ”€â”€ [0]=2.0â”‚   â””â”€â”€ [1]=3.0â””â”€â”€ .c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_mermaid(tree, depth=2))``````mermaidflowchart LR    id2 --- id3(&quot;&lt;/b&gt;[0]=2.0&lt;/b&gt;&quot;)    id2 --- id4(&quot;&lt;/b&gt;[1]=3.0&lt;/b&gt;&quot;)    id0(&lt;b&gt;Tree&lt;/b&gt;)    id0 --- id1(&quot;&lt;/b&gt;.a=1&lt;/b&gt;&quot;)    id0 --- id2(&quot;&lt;/b&gt;.b:tuple&lt;/b&gt;&quot;)    id0 --- id5(&quot;&lt;/b&gt;.c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])&lt;/b&gt;&quot;)```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_repr(tree, depth=2))Tree(a=1, b=(2.0, 3.0), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))```&lt;/td&gt;&lt;td&gt;```pythonprint(pytc.tree_str(tree, depth=2))Tree(a=1, b=(2.0, 3.0), c=[4. 5. 6.])```&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/details&gt;### ğŸƒ Working with `jax` transformation&lt;details&gt; &lt;summary&gt;Make arbitrary PyTrees work with jax transformations&lt;/summary&gt;Parameters are defined in `Tree` at the top of class definition similar to defining`dataclasses.dataclass` field.Lets optimize our parameters```pythonimport pytreeclass as pytcimport jaximport jax.numpy as jnpclass Tree(pytc.TreeClass)    a: int = 1    b: tuple[float] = (2., 3.)    c: jax.Array = jnp.array([4., 5., 6.])    def __call__(self, x):        return self.a + self.b[0] + self.c + xtree = Tree()@jax.graddef loss_func(tree: Tree, x: jax.Array):    tree = tree.at[...].apply(pytc.unfreeze, is_leaf=pytc.is_frozen)  # &lt;--- unfreeze the tree before calling it    preds = jax.vmap(tree)(x)  # &lt;--- vectorize the tree call over the leading axis    return jnp.mean(preds**2)  # &lt;--- return the mean squared error@jax.jitdef train_step(tree: Tree, x: jax.Array):    grads = loss_func(tree, x)    # apply a small gradient step    return jax.tree_util.tree_map(lambda x, g: x - 1e-3 * g, tree, grads)# lets freeze the non-differentiable parts of the tree# in essence any non inexact type should be frozen to# make the tree differentiable and work with jax transformationsjaxable_tree = jax.tree_util.tree_map(lambda x: pytc.freeze(x) if pytc.is_nondiff(x) else x, tree)for epoch in range(1_000):    jaxable_tree = train_step(jaxable_tree, jnp.ones([10, 1]))print(jaxable_tree)# **the `frozen` params have &quot;#&quot; prefix**# Tree(a=#1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])# unfreeze the treetree = jaxable_tree.at[...].apply(pytc.unfreeze, is_leaf=pytc.is_frozen)# the previous line is equivalent to:# &gt;&gt;&gt; tree = jax.tree_util.tree_map(pytc.unfreeze, jaxable_tree, is_leaf=pytc.is_frozen)print(tree)# Tree(a=1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])```&lt;/details&gt;#### â˜ï¸ Advanced Indexing with `.at[]` &lt;a id=&quot;Indexing&quot;&gt;&lt;details&gt; &lt;summary&gt;Out-of-place updates using mask, attribute name or index&lt;/summary&gt;`PyTreeClass` offers 3 means of indexing through `.at[]`1. Indexing by boolean mask.2. Indexing by attribute name.3. Indexing by Leaf index.**Since `treeclass` wrapped class are immutable, `.at[]` operations returns new instance of the tree**#### Index update by boolean mask```pythontree = Tree()# Tree(a=1, b=(2, 3), c=i32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4,6]))# lets create a mask for values &gt; 4mask = jax.tree_util.tree_map(lambda x: x&gt;4, tree)print(mask)# Tree(a=False, b=(False, False), c=[False  True  True])print(tree.at[mask].get())# Tree(a=None, b=(None, None), c=[5 6])print(tree.at[mask].set(10))# Tree(a=1, b=(2, 3), c=[ 4 10 10])print(tree.at[mask].apply(lambda x: 10))# Tree(a=1, b=(2, 3), c=[ 4 10 10])```#### Index update by attribute name```pythontree = Tree()# Tree(a=1, b=(2, 3), c=i32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4,6]))print(tree.at[&quot;a&quot;].get())# Tree(a=1, b=(None, None), c=None)print(tree.at[&quot;a&quot;].set(10))# Tree(a=10, b=(2, 3), c=[4 5 6])print(tree.at[&quot;a&quot;].apply(lambda x: 10))# Tree(a=10, b=(2, 3), c=[4 5 6])```#### Index update by integer index```pythontree = Tree()# Tree(a=1, b=(2, 3), c=i32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4,6]))print(tree.at[1].at[0].get())# Tree(a=None, b=(2.0, None), c=None)print(tree.at[1].at[0].set(10))# Tree(a=1, b=(10, 3.0), c=[4. 5. 6.])print(tree.at[1].at[0].apply(lambda x: 10))# Tree(a=1, b=(10, 3.0), c=[4. 5. 6.])```### Mix, match , and chain index update```pythonimport jaximport jax.numpy as jnpimport pytreeclass as pytcclass Tree(pytc.TreeClass):    a: int = 1    b: str = &quot;b&quot;    c: float = 1.0    d: bool = True    e: tuple = (1, 2, 3)    f: jax.Array = jax.numpy.array([1, 2, 3])tree = Tree()integer_mask = jax.tree_util.tree_map(lambda x: isinstance(x, int), tree)tree = (    tree    .at[&quot;a&quot;].set(10)    .at[&quot;b&quot;].set(&quot;B&quot;)    .at[&quot;c&quot;].set(10.0)    .at[&quot;d&quot;].set(False)    .at[&quot;e&quot;].at[0].set(10)  # set first element of tuple to 10    .at[&quot;f&quot;].apply(jnp.sin)  # apply to all elements in array    .at[integer_mask].apply(float)  # cast all `int` to `float`)print(tree)# Tree(#   a=10.0,#   b=B,#   c=10.0,#   d=0.0,#   e=(10.0, 2.0, 3.0),#   f=[0.841471  0.9092974 0.14112  ]# )```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;## ğŸ“œ Stateful computations&lt;a id=&quot;stateful_computation&quot;&gt;&lt;/a&gt; &lt;/summary&gt;First, [Under jax.jit jax requires states to be explicit](https://jax.readthedocs.io/en/latest/jax-101/07-state.html?highlight=state), this means that for any class instance; variables needs to be separated from the class and be passed explictly. However when using `TreeClass` no need to separate the instance variables ; instead the whole instance is passed as a state.Using the following pattern,Updating state **functionally** can be achieved under `jax.jit````pythonimport jaximport pytreeclass as pytcclass Counter(pytc.TreeClass):    calls : int = 0    def increment(self):        self.calls += 1counter = Counter() # Counter(calls=0)```Here, we define the update function. Since the increment method mutate the internal state, thus we need to use the functional approach to update the state by using `.at`. To achieve this we can use `.at[method_name].__call__(*args,**kwargs)`, this functional call will return the value of this call and a _new_ model instance with the update state.```python@jax.jitdef update(counter):    value, new_counter = counter.at[&quot;increment&quot;]()    return new_counterfor i in range(10):    counter = update(counter)print(counter.calls) # 10```&lt;/details&gt;## â• More&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;details&gt; &lt;summary&gt;Validate or convert inputs using callbacks&lt;/summary&gt;`PyTreeClass` includes `callbacks` in the `field` to apply a sequence of functions on input at setting the attribute stage. The callback is quite useful in several cases, for instance, to ensure a certain input type within a valid range. See example:```pythonimport jaximport pytreeclass as pytcdef positive_int_callback(value):    if not isinstance(value, int):        raise TypeError(&quot;Value must be an integer&quot;)    if value &lt;= 0:        raise ValueError(&quot;Value must be positive&quot;)    return valueclass Tree(pytc.TreeClass):    in_features:int = pytc.field(callbacks=[positive_int_callback])tree = Tree(1)# no errortree = Tree(0)# ValueError: Error for field=`in_features`:# Value must be positivetree = Tree(1.0)# TypeError: Error for field=`in_features`:# Value must be an integer```&lt;/details&gt;&lt;details&gt;  &lt;summary&gt; Add leafwise math operations to PyTreeClass wrapped class&lt;/summary&gt;```pythonimport functools as ftimport pytreeclass as pytcimport jaximport jax.tree_util as jtuimport jax.numpy as jnpclass Tree(pytc.TreeClass, leafwise=True):    a: int = 1    b: tuple[float] = (2., 3.)    c: jax.Array = jnp.array([4., 5., 6.])    def __call__(self, x):        return self.a + self.b[0] + self.c + xtree = Tree()tree + 100# Tree(a=101, b=(102.0, 103.0), c=f32[3](Î¼=105.00, Ïƒ=0.82, âˆˆ[104.00,106.00]))@jax.graddef loss_func(tree: Tree, x: jax.Array):    tree = jtu.tree_map(pytc.unfreeze, tree, is_leaf=pytc.is_frozen)  # &lt;--- unfreeze the tree before calling it    preds = jax.vmap(tree)(x)  # &lt;--- vectorize the tree call over the leading axis    return jnp.mean(preds**2)  # &lt;--- return the mean squared error@jax.jitdef train_step(tree: Tree, x: jax.Array):    grads = loss_func(tree, x)    return tree - grads * 1e-3  # &lt;--- eliminate `tree_map`# lets freeze the non-differentiable parts of the tree# in essence any non inexact type should be frozen to# make the tree differentiable and work with jax transformationsjaxable_tree = jax.tree_util.tree_map(lambda x: pytc.freeze(x) if pytc.is_nondiff(x) else x, tree)for epoch in range(1_000):    jaxable_tree = train_step(jaxable_tree, jnp.ones([10, 1]))print(jaxable_tree)# **the `frozen` params have &quot;#&quot; prefix**# Tree(a=#1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])# unfreeze the treetree = jax.tree_util.tree_map(pytc.unfreeze, jaxable_tree, is_leaf=pytc.is_frozen)print(tree)# Tree(a=1, b=(-4.2826524, 3.0), c=[2.3924797 2.905778  3.4190805])```&lt;/details&gt;&lt;details&gt; &lt;summary&gt;Eliminate tree_map using bcmap + treeclass(..., leafwise=True) &lt;/summary&gt;TDLR```pythonimport functools as ftimport pytreeclass as pytcimport jax.numpy as jnpclass Tree(pytc.TreeClass, leafwise=True):    a:int = 1    b:tuple[float] = (2.,3.)    c:jax.Array = jnp.array([4.,5.,6.])tree = Tree()print(pytc.bcmap(jnp.where)(tree&gt;2, tree+100, 0))# Tree(a=0, b=(0.0, 103.0), c=[104. 105. 106.])````bcmap(func, is_leaf)` maps a function over [PyTrees](https://jax.readthedocs.io/en/latest/pytrees.html) leaves with automatic broadcasting for scalar arguments.`bcmap` is function transformation that broadcast a scalar to match the first argument of the function this enables us to convert a function like `jnp.where` to work with arbitrary tree structures without the need to write a specific function for each broadcasting caseFor example, lets say we want to use `jnp.where` to zeros out all values in an arbitrary tree structure that are less than 0tree = ([1], {&quot;a&quot;:1, &quot;b&quot;:2}, (1,), -1,)we can use `jax.tree_util.tree_map` to apply `jnp.where` to the tree but we need to write a specific function for broadcasting the scalar to the tree```pythondef map_func(leaf):    # here we encoded the scalar `0` inside the function    return jnp.where(leaf&gt;0, leaf, 0)jtu.tree_map(map_func, tree)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(0, dtype=int32, weak_type=True))```However, lets say we want to use `jnp.where` to set a value to a leaf value from another tree that looks like this```pythondef map_func2(lhs_leaf, rhs_leaf):    # here we encoded the scalar `0` inside the function    return jnp.where(lhs_leaf&gt;0, lhs_leaf, rhs_leaf)tree2 = jtu.tree_map(lambda x: 1000, tree)jtu.tree_map(map_func2, tree, tree2)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(1000, dtype=int32, weak_type=True))```Now, `bcmap` makes this easier by figuring out the broadcasting case.```pythonbroadcastable_where = pytc.bcmap(jnp.where)mask = jtu.tree_map(lambda x: x&gt;0, tree)```case 1```pythonbroadcastable_where(mask, tree, 0)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(0, dtype=int32, weak_type=True))```case 2```pythonbroadcastable_where(mask, tree, tree2)# ([Array(1, dtype=int32, weak_type=True)],#  {'a': Array(1, dtype=int32, weak_type=True),#   'b': Array(2, dtype=int32, weak_type=True)},#  (Array(1, dtype=int32, weak_type=True),),#  Array(1000, dtype=int32, weak_type=True))```lets then take this a step further to eliminate `mask` from the equationby using `pytreeclass` with `leafwise=True ````pythonclass Tree(pytc.TreeClass, leafwise=True):    tree : tuple = ([1], {&quot;a&quot;:1, &quot;b&quot;:2}, (1,), -1,)tree = Tree()# Tree(tree=([1], {a:1, b:2}, (1), -1))```case 1: broadcast scalar to tree````pythonprint(broadcastable_where(tree&gt;0, tree, 0))# Tree(tree=([1], {a:1, b:2}, (1), 0))case 2: broadcast tree to tree```pythonprint(broadcastable_where(tree&gt;0, tree, tree+100))# Tree(tree=([1], {a:1, b:2}, (1), 99))`````bcmap` also works with all kind of arguments in the wrapped function```pythonprint(broadcastable_where(tree&gt;0, x=tree, y=tree+100))# Tree(tree=([1], {a:1, b:2}, (1), 99))```in concolusion, `bcmap` is a function transformation that can be used toto make functions work with arbitrary tree structures without the need to writea specific function for each broadcasting caseMoreover, `bcmap` can be more powerful when used with `pytreeclass` tofacilitate operation of arbitrary functions on `PyTree` objectswithout the need to use `tree_map`&lt;/details&gt;&lt;details&gt;&lt;summary&gt;Use PyTreeClass vizualization tools with arbitrary PyTrees &lt;/summary&gt;```pythonimport jaximport pytreeclass as pytctree = [1, [2,3], 4]print(pytc.tree_diagram(tree, depth=1))# list# â”œâ”€â”€ [0]=1# â”œâ”€â”€ [1]=[...]# â””â”€â”€ [2]=4print(pytc.tree_diagram(tree, depth=2))# list# â”œâ”€â”€ [0]=1# â”œâ”€â”€ [1]:list# â”‚   â”œâ”€â”€ [0]=2# â”‚   â””â”€â”€ [1]=3# â””â”€â”€ [2]=4print(pytc.tree_summary(tree, depth=1))# â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Nameâ”‚Typeâ”‚Countâ”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[0] â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[1] â”‚listâ”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[2] â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£   â”‚listâ”‚3    â”‚# â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜print(pytc.tree_summary(tree, depth=2))# â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Name  â”‚Typeâ”‚Countâ”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[0]   â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[1][0]â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[1][1]â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚[2]   â”‚int â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£     â”‚listâ”‚4    â”‚# â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;Use PyTreeClass components with other libraries&lt;/summary&gt;```pythonimport jaximport pytreeclass as pytcfrom flax import structimport jaximport pytreeclass as pytcfrom flax import struct# note that flax is registered with `jax.tree_util.register_pytree_with_keys`# otherwise for arbitrary objects you need to do the key registration@struct.dataclassclass FlaxTree:    a:int = 1    b:tuple[float] = (2.,3.)    c:jax.Array = jax.numpy.array([4.,5.,6.])    def __repr__(self) -&gt; str:        return pytc.tree_repr(self)    def __str__(self) -&gt; str:        return pytc.tree_str(self)    @property    def at(self):        return pytc.tree_indexer(self)flax_tree = FlaxTree()print(f&quot;{flax_tree!r}&quot;)# FlaxTree(a=1, b=(2.0, 3.0), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))print(f&quot;{flax_tree!s}&quot;)# FlaxTree(a=1, b=(2.0, 3.0), c=[4. 5. 6.])print(pytc.tree_diagram(flax_tree))# FlaxTree# â”œâ”€â”€ .a=1# â”œâ”€â”€ .b:tuple# â”‚   â”œâ”€â”€ [0]=2.0# â”‚   â””â”€â”€ [1]=3.0# â””â”€â”€ .c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00])print(pytc.tree_summary(flax_tree))# â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”# â”‚Name â”‚Type    â”‚Countâ”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.a   â”‚int     â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.b[0]â”‚float   â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.b[1]â”‚float   â”‚1    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚.c   â”‚f32[3]  â”‚3    â”‚# â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤# â”‚Î£    â”‚FlaxTreeâ”‚6    â”‚# â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜flax_tree.at[0].get()# FlaxTree(a=1, b=(None, None), c=None)flax_tree.at[&quot;a&quot;].set(10)# FlaxTree(a=10, b=(2.0, 3.0), c=f32[3](Î¼=5.00, Ïƒ=0.82, âˆˆ[4.00,6.00]))```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;Benchmark flatten/unflatten compared to Flax and Equinox &lt;/summary&gt;&lt;a href=&quot;https://colab.research.google.com/github/ASEM000/PyTreeClass/blob/main/assets/benchmark_flatten_unflatten.ipynb&quot; target=&quot;_parent&quot;&gt;&lt;img src=&quot;https://colab.research.google.com/assets/colab-badge.svg&quot; alt=&quot;Open In Colab&quot;/&gt;&lt;/a&gt;&lt;table&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;CPU&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;GPU&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src='assets/benchmark_cpu.png'&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/details&gt;## ğŸ“™ Acknowledgements&lt;a id=&quot;acknowledgements&quot;&gt;&lt;/a&gt;- [Farid Talibli (for visualization link generation backend)](https://www.linkedin.com/in/frdt98)- [Treex](https://github.com/cgarciae/treex), [Equinox](https://github.com/patrick-kidger/equinox), [tree-math](https://github.com/google/tree-math), [Flax](https://github.com/google/flax), [TensorFlow](https://www.tensorflow.org), [PyTorch](https://pytorch.org)- [Lovely JAX](https://github.com/xl0/lovely-jax)</longdescription>
</pkgmetadata>