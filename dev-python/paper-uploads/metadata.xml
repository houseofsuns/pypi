<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># paper-uploadsАсинхронная загрузка файлов для административного интерфейса Django.[![PyPI](https://img.shields.io/pypi/v/paper-uploads.svg)](https://pypi.org/project/paper-uploads/)[![Build Status](https://github.com/dldevinc/paper-uploads/actions/workflows/tests.yml/badge.svg)](https://github.com/dldevinc/paper-uploads)[![Software license](https://img.shields.io/pypi/l/paper-uploads.svg)](https://pypi.org/project/paper-uploads/)## Requirements-   Python &gt;= 3.8-   Django &gt;= 2.2-   [paper-admin][paper-admin] &gt;= 6.0-   [variations][variations]## Features-   Каждый файл представлен своей моделью. Это позволяет хранить    вместе с файлом дополнительные данные. Например, `alt` для изображений.-   Загрузка файлов происходит асинхронно и начинается сразу    при выборе файла в интерфейсе администратора.-   Поля модели, предоставляемые библиотекой `paper-uploads`,    являются производными от `OneToOneField` и не используют    `&lt;input type=&quot;file&quot;&gt;`. Благодаря этому, при ошибках валидации формы    прикрепленные файлы не сбрасываются.-   Загруженные картинки можно нарезать на множество вариаций.    Каждая вариация гибко настраивается. Можно указать размеры,    качество сжатия, формат, добавить дополнительные    [pilkit][pilkit]-процессоры, распознавание лиц и прочее.    &lt;br&gt;См. [variations][variations].-   Совместим с [django-storages][django-storages].-   Опциональная интеграция с [django-rq][django-rq]    для отложенной нарезки картинок на вариации.-   Возможность создавать коллекции файлов. В частности, галерей    изображений с возможностью сортировки элементов.## Table of Contents-   [Installation](#Installation)-   [Описание](#Описание)-   [FileField и ImageField](#FileField-и-ImageField)    -   [Поля моделей загруженных файлов](#Поля-моделей-загруженных-файлов)    -   [Storage](#Storage)    -   [Каталог загрузки файла](#Каталог-загрузки-файла)    -   [Валидаторы](#Валидаторы)    -   [Программная загрузка файлов](#Программная-загрузка-файлов)    -   [Вариации](#Вариации)        -   [Версии вариаций](#Версии-вариаций)        -   [Redis Queue](#Redis-Queue)-   [SVGFileField](#SVGFileField)-   [Коллекции](#Коллекции)    -   [Элементы коллекции](#Элементы-коллекции)        -   [Storage и каталог загрузки файлов](#Storage-и-каталог-загрузки-файлов)        -   [Валидаторы](#Валидаторы-2)        -   [Программное создание элемента коллекции](#Программное-создание-элемента-коллекции)        -   [Вариации](#Вариации-2)    -   [HTML Template Example](#HTML-Template-Example)-   [Management команды](#Management-команды)-   [Settings](#Settings)## InstallationInstall `paper-uploads`:```shellpip install paper-uploads[full]```Add `paper_uploads` to `INSTALLED_APPS` in `settings.py`:```pythonINSTALLED_APPS = [    # ...    &quot;paper_uploads&quot;,    # ...]```Configure `paper-uploads` in django's `settings.py`:```pythonPAPER_UPLOADS = {    &quot;VARIATION_DEFAULTS&quot;: {        &quot;jpeg&quot;: dict(            quality=80,            progressive=True,        ),        &quot;webp&quot;: dict(            quality=75,        )    }}# Add JS translationsPAPER_LOCALE_PACKAGES = [   &quot;paper_admin&quot;,   &quot;paper_uploads&quot;,   &quot;django.contrib.admin&quot;,]```## ОписаниеВ состав библиотеки входит два поля &amp;mdash; `FileField` и `ImageField` &amp;mdash;и модель `Collection`, предназначенная для группировки загруженных файловс целью создания, к примеру, фотогалерей.С примерами использования библиотеки вы можете ознакомиться[здесь](https://github.com/dldevinc/paper-uploads/tree/master/tests/examples).## FileField и ImageField```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import FileField, ImageFieldclass Page(models.Model):    file = FileField(        _(&quot;file&quot;),        blank=True    )    image = ImageField(        _(&quot;image&quot;),        blank=True    )```![image](https://user-images.githubusercontent.com/6928240/154901303-be8a6a26-c0c1-4bb1-a9cc-ece14f5b04d2.png)Эти поля используются для тех же целей, что и одноимённые стандартные поля Django&amp;mdash; для загрузки файлов и изображений &amp;mdash; но имеют ряд существенных отличий.Главное отличие заключается в том, что поля `FileField` и `ImageField` являютсяпроизводными от стандартного `OneToOneField`. Соответственно, загруженные файлыпредставлены экземплярами полноценных моделей.### Поля моделей загруженных файловФайлы, загруженные с помощью полей `FileField` и `ImageField`, хранятся вэкземплярах моделей `UploadedFile` и `UploadedImage` соответственно.В следующих таблицах перечислены общие поля и свойства обеих моделей:| Поле          | Описание                                                                               ||---------------|----------------------------------------------------------------------------------------|| resource_name | Имя файла без пути, суффикса и расширения.&lt;br&gt;Пример: `report2020`.                    || extension     | Расширение файла в нижнем регистре без точки.&lt;br&gt;Пример: `pdf`.                        || size          | Размер файла в байтах.                                                                 || checksum      | Контрольная сумма содержимого файла.&lt;br&gt;Используется для отслеживания изменений файла. || uploaded_at   | Дата и время загрузки файла.                                                           || created_at    | Дата и время создания экземпляра модели.                                               || modified_at   | Дата и время изменения экземпляра модели.                                              || Свойство | Описание                                                                                    ||----------|---------------------------------------------------------------------------------------------|| name     | Полное имя файла.&lt;br&gt;Пример: `files/report2020_19sc2Kj.pdf`.                                || url      | URL-адрес файла.&lt;br&gt;Пример: `/media/files/report2020_19sc2Kj.pdf`.                          || path     | Абсолютный путь к файлу.&lt;br&gt;Пример: `/home/www/django/media/files/report2020_19sc2Kj.pdf`.  |Ниже перечислены поля и свойства, специфичные для каждой модели.Специфичные поля `UploadedFile`:| Поле         | Описание                                                                                                                                  ||--------------|-------------------------------------------------------------------------------------------------------------------------------------------|| display_name | Удобочитаемое название файла для вывода на сайте.&lt;br&gt;Заполняется в диалоговом окне редактирования файла.&lt;br&gt;Пример: `Annual report 2020`. |Специфичные поля `UploadedImage`:| Поле        | Описание                                                                     ||-------------|------------------------------------------------------------------------------|| title       | Название изображения, которое можно вставить в атрибут `title` тэга `&lt;img&gt;`. || description | Описание изображения, которое можно вставить в атрибут `alt` тэга `&lt;img&gt;`.   || width       | Ширина загруженного изображения.                                             || height      | Высота загруженного изображения.                                             || ratio       | Отношение ширины изображения к высоте в формате `Decimal`.                   || hw_ratio    | Отношение высоте изображения к ширине в формате `Decimal`.                   || srcset      | Строка формата `[URL] [WIDTH]w`.                                             |Большинство полей заполняются автоматически при загрузке файла и предназначенытолько для чтения. Но такие поля, как `display_name` или `title`, заполняютсяпользователем в диалоговом окне редактирования файла:![image](https://user-images.githubusercontent.com/6928240/154904780-5d365952-ce75-4491-952e-6b2992e35309.png)![image](https://user-images.githubusercontent.com/6928240/154910567-991bc27c-e7c6-40e7-883e-f3120897c197.png)### StorageПо умолчанию все поля `paper-uploads` используют единый экземпляр хранилища,определяемый настройками `STORAGE` и `STORAGE_OPTIONS`:```python# settings.pyPAPER_UPLOADS = {    &quot;STORAGE&quot;: &quot;django.core.files.storage.FileSystemStorage&quot;,    &quot;STORAGE_OPTIONS&quot;: {},    # ...}```Вы можете указать экземпляр хранилища для конкретного поля:```pythonfrom django.db import modelsfrom django.core.files.storage import FileSystemStoragefrom django.utils.translation import gettext_lazy as _from paper_uploads.models import FileFieldclass Page(models.Model):    report = FileField(        _(&quot;report&quot;),        blank=True,        storage=FileSystemStorage(location=&quot;uploads/&quot;),        upload_to=&quot;reports/%Y/%m&quot;    )```### Каталог загрузки файлаВсе поля используют единые значения, указанные в настройках`FILES_UPLOAD_TO` и `IMAGES_UPLOAD_TO`:```python# settings.pyPAPER_UPLOADS = {    # ...    &quot;FILES_UPLOAD_TO&quot;: &quot;files/%Y/%m/%d&quot;,    &quot;IMAGES_UPLOAD_TO&quot;: &quot;images/%Y/%m/%d&quot;,    # ...}```Для конкретного поля каталог сохранения можно указать в параметре поля `upload_to`.Параметр поддерживает форматирование `strftime()`, которое будет заменено надату/время загруженного файла (и загружаемые файлы не заполнят один каталог).```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import FileFieldclass Page(models.Model):    report = FileField(        _(&quot;report&quot;),        blank=True,        upload_to=&quot;pdf/reports/%Y&quot;    )```Обратите внимание, что в параметр `upload_to` _нельзя передать вызываемый объект_.Если вам требуется динамическое определение каталога или имени загруженного файла,создайте proxy-модель и переопрелите метод `generate_filename()`:```pythonimport osimport datetimefrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import FileField, UploadedFileclass UploadedFileProxy(UploadedFile):    class Meta:        proxy = True    def generate_filename(self, filename: str) -&gt; str:        _, ext = os.path.splitext(filename)        filename = &quot;proxy-files/file-%Y-%m-%d_%H%M%S{}&quot;.format(ext)        filename = datetime.datetime.now().strftime(filename)        storage = self.get_file_storage()        return storage.generate_filename(filename)class Page(models.Model):    file = FileField(        _(&quot;file&quot;),        to=UploadedFileProxy,        blank=True,    )```### ВалидаторыНа загружаемые файлы можно наложить ограничения с помощью валидаторов.Модуль `paper-uploads.validators` предоставляет следующие классы для валидации файлов:-   `MaxSizeValidator` - задает максимально допустимый размер файла.    &lt;br&gt;Максимальный размер можно указать как в виде числа (в байтах),    так и в виде строки.    &lt;br&gt;Например: `4 * 10 ** 6`, `4mb`, `4MB`, `4M`.-   `ExtensionValidator` - задает допустимые расширения файлов.-   `MimeTypeValidator` - задает допустимые MIME-типы файлов.-   `ImageMinSizeValidator` - устанавливает минимальный размер загружаемых изображений.-   `ImageMaxSizeValidator` - устанавливает максимальный размер загружаемых изображений.Пример:```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import FileFieldfrom paper_uploads.validators import ExtensionValidator, MaxSizeValidatorclass Page(models.Model):    report = FileField(        _(&quot;file&quot;),        blank=True,        validators=[            ExtensionValidator([&quot;.pdf&quot;, &quot;.doc&quot;, &quot;.docx&quot;]),            MaxSizeValidator(&quot;10MB&quot;)        ]    )```Ограничения, наложенные этими валидаторами, отображаются в виджете:![image](https://user-images.githubusercontent.com/6928240/152322863-33108ef9-061c-4af5-8d0c-aeb5b467e04b.png)### Программная загрузка файлов```pythonfrom paper_uploads.models import *report = UploadedFile()report.set_owner_field(Page, &quot;report&quot;)report.attach(&quot;/tmp/file.doc&quot;)report.save()page = Page.objects.create(    report=report)```В метод `set_owner_field()` передаётся модель и имя поля модели, в которое будетсохранен экземпляр модели файла. Эти данные необходимы для выявления файлов, которыенигде не используются.Метод `attach()` производит непосредственное сохранение файла и заполняет экземплярдополнительными данными. В метод можно передать как путь к локальному файлу, таки файловый объект.### Вариации`ImageField` позволяет создавать вариации для загруженного изображения.Вариация - это изображение, полученное из исходного по _заранее_ объявленным правилам.Для создания вариаций используется библиотека [variations][variations].```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import *class Page(models.Model):    image = ImageField(        _(&quot;image&quot;),        blank=True,        variations=dict(            desktop=dict(                size=(800, 0),                clip=False,            ),            mobile=dict(                size=(600, 0),                clip=False,            ),        )    )```К файлам вариаций можно обратиться через модель `UploadedImage` используя их имена:```pythonprint(page.image.desktop.url)# /media/images/2022/02/21/sample.desktop.jpg```Создание файлов вариаций происходит в момент загрузки изображения на сервер.Поэтому изменение настроек вариаций не окажет никакого эффекта на уже загруженныеизображения.Для того, чтобы создать файлы для новых вариаций (либо перезаписать существующие файлывариаций) можно поступить одним из ниже описанных способов.1. Вызвать метод `recut()`:    ```python    page.image.recut()    ```    При вызове этого метода все файлы вариаций для текущего экземпляра    создаются заново.    &lt;br&gt;    &lt;br&gt;    Можно явно указать имена вариаций, которые необходимо перезаписать:    ```python    page.image_group.recut([&quot;desktop&quot;, &quot;mobile&quot;])    ```2. Выполнить management-команду `recreate_variations`:    ```shell    python3 manage.py recreate_variations app.page \            --field image            --variations desktop mobile    ```    Эта команда сгенерирует вариации для всех экземпляров указанной модели.#### Версии вариацийДопустим, у нас есть изображение, которое нужно отобразить в трехвариантах: `desktop`, `tablet` и `mobile`. Если мы хотим поддерживатьдисплеи Retina, нам нужно добавить ещё три вариации для размера `2x`.Если мы также хотим использовать формат `WebP` (сохранив исходный форматдля обратной совместимости), то общее количество вариаций достигает **12**.Поскольку Retina-вариации отличаются от обычных только увеличеннымна постоянный коэффициент размером, а `WebP`-вариации — добавлениемпараметра `format = &quot;webp&quot;`, мы можем создавать эти вариацииавтоматически. Это и есть версии вариации.Перечень версий, которые нужно сгенерировать, указываются в параметревариации `versions`. Поддерживаются следующие значения:`webp`, `2x`, `3x`, `4x`.```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import *class Page(models.Model):    image = ImageField(        _(&quot;image&quot;),        blank=True,        variations=dict(            desktop=dict(                # ...                versions={&quot;webp&quot;, &quot;2x&quot;, &quot;3x&quot;}            )        )    )```Приведенный выше код создаст следующие вариации:-   `desktop` - оригинальная вариация-   `desktop_webp` - `WebP`-версия оригинальной вариации-   `desktop_2x` - Retina 2x-   `desktop_webp_2x` - `WebP`-версия Retina 2x-   `desktop_3x` - Retina 3x-   `desktop_webp_3x` - `WebP`-версия Retina 3x**NOTE**: Retina-суффикс всегда следует после суффикса `webp`, еслион есть.Если необходимо переопределить какие-то параметры дополнительнойвариации, то придётся объявлять вариацию явно:```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import *class Page(models.Model):    image = ImageField(        _('image'),        blank=True,        variations=dict(            desktop=dict(                size=(800, 600),                versions={'webp', '2x', '3x'}            ),            desktop_2x=dict(                size=(1600, 1200),                jpeg=dict(                    quality=72                )            )        )    )```#### Redis QueueПри загрузке большого количества изображений процесс создания вариаций может заниматьзначительное время. Эту работу можно вынести в отдельный процесс с помощью[django-rq][django-rq]:```shellpip install django-rq``````python# settings.pyPAPER_UPLOADS = {    &quot;RQ_ENABLED&quot;: True,    &quot;RQ_QUEUE_NAME&quot;: &quot;default&quot;,    # ...}```Теперь при загрузке изображений, в очередь под именем `default` будет добавлятьсязадача, которая создаст все необходимые вариации.## SVGFileFieldПоле `SVGFileField` предназначено для загрузки SVG-файлов. Оно идентично `FileField`,но связанная с ним модель `UploadedSVGFile` включает несколько дополнительных полей:| Поле        | Описание                                                                     ||-------------|------------------------------------------------------------------------------|| width       | Ширина изображения в формате `Decimal`. Может быть вещественным числом.      || height      | Высота изображения в формате `Decimal`. Может быть вещественным числом.      || title       | Название изображения, которое можно вставить в атрибут `title` тэга `&lt;img&gt;`. || description | Описание изображения, которое можно вставить в атрибут `alt` тэга `&lt;img&gt;`.   |```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import SVGFileFieldclass Page(models.Model):    svg = SVGFileField(        _(&quot;svg&quot;),        blank=True    )```## КоллекцииКоллекция — это модель, группирующая экземпляры других моделей (элементов коллекции).В частности, с помощью коллекции можно создать фотогалерею или список файлов.Для создания коллекции необходимо объявить класс, унаследованный от `Collection`и указать модели элементов, которые могут входить в коллекцию с помощью псевдо-поля`CollectionItem`:```pythonfrom django.db import modelsfrom paper_uploads.models import *# Collection modelclass PageFiles(Collection):    svg = CollectionItem(SVGItem)    image = CollectionItem(ImageItem)    file = CollectionItem(FileItem)class Page(models.Model):    files = CollectionField(PageFiles)```Класс `Collection` обладает особенным свойством: _любой дочерний класс, унаследованныйот `Collection`, является proxy-моделью для `Collection`_.В большинстве случаев коллекции отличаются друг от друга только набором элементов,которые могут входить в коллекцию. Использование proxy-моделей предотвращает созданиемножества одинаковых таблиц в БД.Если же для коллекции необходима отдельная таблица (например, если вы решили добавитьв неё новое поле), то необходимо явно установить свойство `Meta.proxy` в значение `False`:```pythonfrom django.db import modelsfrom paper_uploads.models import *class CustomCollection(Collection):    name = models.CharField(&quot;name&quot;, max_length=128, blank=True)    file = CollectionItem(FileItem)    class Meta:        proxy = False```### Элементы коллекцииПсевдо-поле `CollectionItem` регистрирует модель элемента коллекции под заданным именем.```pythonfrom paper_uploads.models import *class PageFiles(Collection):    svg = CollectionItem(SVGItem)    image = CollectionItem(ImageItem)    file = CollectionItem(FileItem)```В приведённом примере, коллекция `PageFiles` может включать элементы трех моделей:`SVGItem`, `ImageItem` и `FileItem`.Порядок объявления элементов коллекции важен: первый класс модели, чей метод `accept()`вернет `True`, определит модель загруженного файла. По этой причине _`FileItem` долженуказываться последним_, т.к. он принимает любые файлы.Получить элементы определённого типа можно с помощью метода `get_items()`:```pythonfor item in page.files.get_items(&quot;image&quot;):    # ...```---В состав библиотеки входят следующие модели элементов:-   `ImageItem`&lt;br&gt;    Для хранения изображения с возможностью нарезки на [вариации](#Вариации).    Допускются только те файлы, которые можно открыть с помощью [Pillow](https://pillow.readthedocs.io/en/stable/).-   `SVGItem`&lt;br&gt;    Для хранения SVG иконок.-   `FileItem`&lt;br&gt;    Может хранить любой файл.#### Storage и каталог загрузки файловПо умолчанию элементы коллекции используют тот же экземпляр хранилища,что используется полями `FileField` и `ImageField`.Каталоги загрузки файлов для элементов коллекций указываются в настройках`COLLECTION_FILES_UPLOAD_TO` и `COLLECTION_IMAGES_UPLOAD_TO`:```python# settings.pyPAPER_UPLOADS = {    # ...    &quot;COLLECTION_FILES_UPLOAD_TO&quot;: &quot;collections/files/%Y/%m/%d&quot;,    &quot;COLLECTION_IMAGES_UPLOAD_TO&quot;: &quot;collections/images/%Y/%m/%d&quot;,    # ...}```Для отдельно взятого элемента коллекции экземпляр хранилища и каталог загрузки  можно указать в параметре `options` псевдо-поля `CollectionItem`:```pythonfrom django.core.files.storage import FileSystemStoragefrom paper_uploads.models import *class PageFiles(Collection):    image = CollectionItem(ImageItem, options={        &quot;storage&quot;: FileSystemStorage(location=&quot;uploads/&quot;),        &quot;upload_to&quot;: &quot;gallery&quot;,    })```Как в случае с `FileField` и `ImageField`, значением `upload_to` не может выступатьвызываемый объект.Если вам требуется динамическое определение каталога или имени загруженного файла,создайте proxy-модель и переопрелите метод `generate_filename()`:```pythonimport osimport datetimefrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import *class ProxyImageItem(ImageItem):    class Meta:        proxy = True    def generate_filename(self, filename: str) -&gt; str:        _, ext = os.path.splitext(filename)        filename = &quot;gallery/image-%Y-%m-%d_%H%M%S{}&quot;.format(ext)        filename = datetime.datetime.now().strftime(filename)        storage = self.get_file_storage()        return storage.generate_filename(filename)class PageGallery(Collection):    image = CollectionItem(ProxyImageItem)class Page(models.Model):    gallery = CollectionField(        PageGallery,        verbose_name=_(&quot;gallery&quot;)    )```#### &lt;a id=&quot;Валидаторы-2&quot; /&gt;ВалидаторыНа загружаемые в коллекции файлы можно наложить ограничения с помощью валидаторов:```pythonfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _from paper_uploads.models import *from paper_uploads.validators import ImageMaxSizeValidator, ImageMinSizeValidatorclass PageGallery(Collection):    image = CollectionItem(ImageItem, validators=[        ImageMinSizeValidator(640, 480),        ImageMaxSizeValidator(4000, 3000)    ])class Page(models.Model):    gallery = CollectionField(        PageGallery,        verbose_name=_(&quot;gallery&quot;)    )```#### Программное создание элемента коллекцииЭлементы коллекций создаются почти также, как `UploadedFile` и `UploadedImage`.Разница лишь в том, что вместо вызова метода `set_owner_field()` необходимовызвать метод `attach_to()` для присоединения элемента к коллекции:```pythonfrom paper_uploads.models import *collection = PageGallery.objects.create()item = ImageItem()item.attach_to(collection)item.attach(&quot;/tmp/image.jpg&quot;)item.save()page = Page.objects.create(    gallery=collection)```#### &lt;a id=&quot;Вариации-2&quot; /&gt;ВариацииВариации для изображений коллекции можно указать одним из двух способов:1. Параметр `options` псевдо-поля `CollectionItem`:    ```python    from paper_uploads.models import *    class PageGallery(Collection):        image = CollectionItem(ImageItem, options={            &quot;variations&quot;: dict(                mobile=dict(                    size=(640, 0),                    clip=False                )            )        })    ```2. Атрибут класса коллекции `VARIATIONS`:    ```python    from paper_uploads.models import *    class PageGallery(Collection):        VARIATIONS = dict(            mobile=dict(                size=(640, 0),                clip=False            )        )        image = CollectionItem(ImageItem)    ```### HTML Template Example```html{% if page.gallery %}&lt;div class=&quot;gallery&quot;&gt;    {% for item in page.gallery %} {% if item.type == &quot;image&quot; %}    &lt;div class=&quot;item item--{{ item.type }}&quot;&gt;        &lt;img            src=&quot;{{ item.url }}&quot;            width=&quot;{{ item.width }}&quot;            height=&quot;{{ item.height }}&quot;            title=&quot;{{ item.title }}&quot;            alt=&quot;{{ item.description }}&quot;        /&gt;    &lt;/div&gt;    {% elif item.type == &quot;file&quot; %}}    &lt;div class=&quot;item item--{{ item.type }}&quot;&gt;        &lt;a href=&quot;{{ item.url }}&quot; download&gt; Download file &quot;{{ item.display_name }}&quot; ({{ item.size|filesizeformat }}) &lt;/a&gt;    &lt;/div&gt;    {% endif %}} {% endfor %}&lt;/div&gt;{% endif %}```## Management команды### check_uploadsЗапускает комплексную проверку загруженных файлови выводит результат.Список производимых тестов:-   загруженный файл существует-   класс модели владельца (указанный в `owner_app_label` и `owner_model_name`) существует-   в классе модели владельца существует поле, указанное в `owner_fieldname`-   у элементов коллекций указано корректное значение в поле `type`-   модель элемента коллекции соответствует модели, указанной в классе коллекции```shellpython3 manage.py check_uploads```### clean_uploadsНаходит мусорные записи в БД (например те, у которых нет владельца)и предлагает их удалить.Владелец загруженного файла устанавливается в момент сохранения страницыв интерфейсе администратора. Это происходит позже фактической загрузки файлана сервер. В промежутке времени между этими событиями файл будет являться &quot;сиротой&quot;.Для того, чтобы такие файлы не удалялись, команда `clean_uploads` игнорируетфайлы, загруженные в течение последнего часа.```shellpython3 manage.py clean_uploads```### remove_empty_collectionsУдаление экземпляров коллекций, в которых нет ни одного элемента.```shellpython3 manage.py clean_uploads```### create_missing_variationsСоздаёт отсутствующие файлы вариаций.```shellpython3 manage.py create_missing_variations```### recreate_variationsСоздание/перезапись вариаций для всех экземпляров указанной модели.```shell# for collectionspython3 manage.py recreate_variations --model app.Photos --item-type image# for regular modelspython3 manage.py recreate_variations --model app.Page --field image```По умолчанию перенарезаются все возможные вариации для каждогоэкземпляра указанной модели. Можно указать конкретные вариации,которые нужно перенарезать:```shellpython3 manage.py recreate_variations --model app.Page --field image \        --variations desktop mobile```### remove_variationsУдаление файлов вариаций.Удаляются только файлы объявленных вариаций.Параметры аналогичны параметрам `recreate_variations`.```shell# for collectionspython3 manage.py remove_variations --model app.Photos --item-type image# for regular modelspython3 manage.py remove_variations --model app.Page --field image```## SettingsВсе настройки указываются в словаре `PAPER_UPLOADS`.```pythonPAPER_UPLOADS = {    &quot;STORAGE&quot;: &quot;django.core.files.storage.FileSystemStorage&quot;,    &quot;STORAGE_OPTIONS&quot;: {},    &quot;FILES_UPLOAD_TO&quot;: &quot;files/%Y/%m/%d&quot;,    &quot;IMAGES_UPLOAD_TO&quot;: &quot;images/%Y/%m/%d&quot;,    &quot;COLLECTION_FILES_UPLOAD_TO&quot;: &quot;collections/files/%Y/%m/%d&quot;,    &quot;COLLECTION_IMAGES_UPLOAD_TO&quot;: &quot;collections/images/%Y/%m/%d&quot;,    &quot;RQ_ENABLED&quot;: True,    &quot;RQ_QUEUE_NAME&quot;: &quot;default&quot;,    &quot;VARIATION_DEFAULTS&quot;: {        &quot;jpeg&quot;: dict(            quality=80,            progressive=True,        ),        &quot;webp&quot;: dict(            quality=75,        )    }}```### `STORAGE`Путь к классу [хранилища Django](https://docs.djangoproject.com/en/2.2/ref/files/storage/).Значение по умолчанию: `django.core.files.storage.FileSystemStorage`### `STORAGE_OPTIONS`Параметры инициализации хранилища.Значение по умолчанию: `{}`### `FILES_UPLOAD_TO`Путь к папке, в которую загружаются файлы из FileField.Может содержать параметры для даты и времени (см. [upload_to](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.FileField.upload_to)).Значение по умолчанию: `files/%Y/%m/%d`### `IMAGES_UPLOAD_TO`Путь к папке, в которую загружаются файлы из ImageField.Значение по умолчанию: `images/%Y/%m/%d`### `COLLECTION_FILES_UPLOAD_TO`Путь к папке, в которую загружаются файлы коллекций.Значение по умолчанию: `collections/files/%Y/%m/%d`### `COLLECTION_IMAGES_UPLOAD_TO`Путь к папке, в которую загружаются изображения коллекций.Значение по умолчанию: `collections/images/%Y/%m/%d`### `COLLECTION_ITEM_PREVIEW_WIDTH`, `COLLECTION_ITEM_PREVIEW_HEIGHT`Размеры превью элементов коллекций в админке.Значение по умолчанию: `180` x `135`### `COLLECTION_IMAGE_ITEM_PREVIEW_VARIATIONS`Вариации, добавляемые к каждому классу изображений коллекцийдля отображения превью в админке. Размеры файлов должнысовпадать с `COLLECTION_ITEM_PREVIEW_WIDTH` и`COLLECTION_ITEM_PREVIEW_HEIGHT`.### `RQ_ENABLED`Включает нарезку картинок на вариации через отложенные задачи.Требует наличие установленного пакета [django-rq][django-rq].Значение по умолчанию: `False`### `RQ_QUEUE_NAME`Название очереди, в которую помещаются задачи по нарезке картинок.Значение по умолчанию: `default`### `VARIATION_DEFAULTS`Параметры вариаций по умолчанию.Параметры, указанные в этом словаре, будут применены к каждойвариации &amp;mdash; если только вариация их явно не переопределяет.Значение по умолчанию: `None`## Development and TestingAfter cloning the Git repository, you should install thisin a virtualenv and set up for development:```shell scriptvirtualenv .venvsource .venv/bin/activatepip install -r ./requirements.txtpre-commit install```Install `npm` dependencies and build static files:```shell scriptnpm cinpx webpack```[paper-admin]: https://github.com/dldevinc/paper-admin[variations]: https://github.com/dldevinc/variations[pilkit]: https://github.com/matthewwithanm/pilkit[django-storages]: https://github.com/jschneier/django-storages[django-rq]: https://github.com/rq/django-rq</longdescription>
</pkgmetadata>