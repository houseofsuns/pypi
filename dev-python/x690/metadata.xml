<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Pure Python `X.690`_ implementation===================================.. image:: https://github.com/exhuma/x690/workflows/Testing/badge.svg?branch=main    :alt: Code Style.. image:: https://github.com/exhuma/x690/workflows/Build%20&amp;%20Publish%20Docs/badge.svg?branch=main    :alt: Build &amp; Publish Docs.. _X.690: https://www.itu.int/rec/recommendation.asp?lang=en&amp;parent=T-REC-X.690-201508-IThis module contains a pure Python implementation of the &quot;x690&quot; standard forBER encoding/decoding. Other encodings are currently unsupported butpull-requests are welcome.Supporting New Types--------------------Some applications may need to support types which are not defined in the X.690standard. This is supported by this library but the types must be defined andregistered.To register a type, simply subclass ``x690.types.Type``. This will take care ofthe registration. Make sure that your new type is imported before using it.New types should define the following 3 class-variables:**TYPECLASS**    A value from ``x690.util.TypeClass``**NATURE**    A value from ``x690.util.TypeNature``**TAG**    A numerical identifier for the typeRefer to the x690 standard for more details on these values. As a generalrule-of-thumb you can assume that the class is either &quot;context&quot; or&quot;application&quot; (it might be good to keep the &quot;universal&quot; class reserved forx690). The nature should be &quot;primitive&quot; for simple values and &quot;constructed&quot; forcomposed types. The tag is free to choose as long as you don't overlap with anexisting type.To convert raw-bytes into a Python object, override ``x690.Type.decode_raw``and conversely also ``x690.Type.encode_raw``. Refer to the docstrings for moredetails.Reverse Engineering Bytes-------------------------All types defined in the ``x690`` library provide a ``.pretty()`` method whichreturns a prettyfied string.If you are confronted with a bytes-object encoded using X.690 but don't haveany documentation, you can write the following loop::    from x690 import decode    data = open(&quot;mydatafile.bin&quot;, &quot;rb&quot;).read()    value, nxt = decode(data)    print(value.pretty())    while nxt &lt; len(data):        value, nxt = decode(data, nxt)        print(value.pretty())This should get you started.If the data contain non-standard types, they will get detected as &quot;UnknownType&quot;and will print out the type-class, nature and tag in the pretty-printed block.This will allow you to define your own subclass of ``x690.types.Type`` usingthose values. Override ``decode(...)`` in that class to handle the unknowntype.Examples========Encoding to bytes-----------------Encoding to bytes can be done by simply calling the Python builting ``bytes()``on instances from ``x690.types``:Encoding of a single value~~~~~~~~~~~~~~~~~~~~~~~~~~.. code:: python    &gt;&gt;&gt; import x690.types as t    &gt;&gt;&gt; myvalue = t.Integer(12)    &gt;&gt;&gt; asbytes = bytes(myvalue)    &gt;&gt;&gt; repr(asbytes)    b'\x02\x01\x0c'Encoding of a composite value using Sequence~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.. code:: python    &gt;&gt;&gt; import x690.types as t    &gt;&gt;&gt; myvalue = t.Sequence(    ...     t.Integer(12),    ...     t.Integer(12),    ...     t.Integer(12),    ... )    &gt;&gt;&gt; asbytes = bytes(myvalue)    &gt;&gt;&gt; repr(asbytes)    b'0\t\x02\x01\x0c\x02\x01\x0c\x02\x01\x0c'Decoding from bytes~~~~~~~~~~~~~~~~~~~Decode bytes by calling ``x690.types.decode`` on your byte data. This willreturn a tuple where the first value contains the decoded object, and thesecond one will contain any remaining bytes which were not decoded... code:: python    &gt;&gt;&gt; import x690    &gt;&gt;&gt; data = b'0\t\x02\x01\x0c\x02\x01\x0c\x02\x01\x0c'    &gt;&gt;&gt; decoded, nxt = x690.decode(data)    &gt;&gt;&gt; decoded    Sequence(Integer(12), Integer(12), Integer(12))    &gt;&gt;&gt; nxt    11Type-Hinting &amp; Enforcing~~~~~~~~~~~~~~~~~~~~~~~~**New in 0.3.0**When decoding bytes, it is possible to specify an expcted type which does twothings: Firstly, it tells tools like ``mypy`` what the return type will be andsecondly, it runs an internal type-check which *ensures* that the returnedvalue is of the expected type. ``x690.exc.UnexpectedType`` is raised otherwise.This does of course only work if you know the type in advance... code:: python    &gt;&gt;&gt; import x690    &gt;&gt;&gt; import x690.types as t    &gt;&gt;&gt; data = b'0\t\x02\x01\x0c\x02\x01\x0c\x02\x01\x0c'    &gt;&gt;&gt; decoded, nxt = x690.decode(data, enforce_type=t.Sequence)    &gt;&gt;&gt; decoded    Sequence(Integer(12), Integer(12), Integer(12))    &gt;&gt;&gt; nxt    11Strict Decoding~~~~~~~~~~~~~~~**New in 0.3.0**When decoding using ``decode`` and you don't expect any remaining bytes, use``strict=True`` which will raise ``x690.exc.IncompleteDecoding`` if there's anyremaining data... code:: python    &gt;&gt;&gt; import x690    &gt;&gt;&gt; data = b'0\t\x02\x01\x0c\x02\x01\x0c\x02\x01\x0cjunk-bytes'    &gt;&gt;&gt; decoded, nxt = x690.decode(data, strict=True)    Traceback (most recent call last):      ...    x690.exc.IncompleteDecoding: Strict decoding still had 10 remaining bytes!</longdescription>
</pkgmetadata>