<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Falcon-AutoCRUD===============Makes RESTful CRUD easier.Test status-----------|Codeship Status for garymonson/falcon-autocrud|IMPORTANT CHANGE IN 1.0.0-------------------------Previously, the CollectionResource and SingleResource classes tookdb\_session as a parameter to the constructor. As of 1.0.0, they nowtake db\_engine instead. The reason for this is to keep the sessionsshort-lived and under autocrud's control to explicitly close thesessions.This WILL impact you as your routing should now pass the db\_engineinstead of the db\_session, and if you override these classes, then, ifyou have overridden the constructor, you may also have to update that.Quick start for contributing----------------------------::    virtualenv -p `which python3` virtualenv    source virtualenv/bin/activate    pip install -r requirements.txt    pip install -r dev_requirements.txt    nosetestsThis runs the tests with SQLite. To run the tests with Postgres (usingpg8000), you must have a Postgres server running, and a postgres userwith permission to create databases:::    export AUTOCRUD_DSN=postgresql+pg8000://myuser:mypassword@localhost:5432    nosetestsSome tests are run only when testing on Postgres due to only beingrelevant to Postgres, such as when testing features to do with Postgresdata types.Usage-----Declare your SQLAlchemy models:::    from sqlalchemy.ext.declarative import declarative_base    from sqlalchemy import create_engine, Column, Integer, String    Base = declarative_base()    class Employee(Base):        __tablename__ = 'employees'        id      = Column(Integer, primary_key=True)        name    = Column(String(50))        age     = Column(Integer)Declare your resources:::    from falcon_autocrud.resource import CollectionResource, SingleResource    class EmployeeCollectionResource(CollectionResource):        model = Employee    class EmployeeResource(SingleResource):        model = EmployeeApply them to your app, ensuring you pass an SQLAlchemy engine to theresource classes:::    from sqlalchemy import create_engine    import falcon    from falcon_autocrud.middleware import Middleware    db_engine = create_engine('sqlite:///stuff.db')    app = falcon.API(        middleware=[Middleware()],    )    app.add_route('/employees', EmployeeCollectionResource(db_engine))    app.add_route('/employees/{id}', EmployeeResource(db_engine))This automatically creates RESTful endpoints for your resources:::    http GET http://localhost/employees    http GET http://localhost/employees?name=Bob    http GET http://localhost/employees?age__gt=24    http GET http://localhost/employees?age__gte=25    http GET http://localhost/employees?age__lt=25    http GET http://localhost/employees?age__lte=24    http GET http://localhost/employees?name__contains=John    http GET http://localhost/employees?name__startswith=John    http GET http://localhost/employees?company_id__null=1    http GET http://localhost/employees?company_id__null=0    echo '{&quot;name&quot;: &quot;Jim&quot;}' | http POST http://localhost/employees    http GET http://localhost/employees/100    echo '{&quot;name&quot;: &quot;Jim&quot;}' | http PUT http://localhost/employees/100    echo '{&quot;name&quot;: &quot;Jim&quot;}' | http PATCH http://localhost/employees/100    http DELETE http://localhost/employees/100    # PATCHing a collection to add entities in bulk    echo '{&quot;patches&quot;: [{&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/&quot;, &quot;value&quot;: {&quot;name&quot;: &quot;Jim&quot;}}]}' | http PATCH http://localhost/employeesNote that by default, PUT will only update, and will not insert a newresource if a matching one does not exist at the address. If you wishnew resources to be created, then add the following to your resource:::    allow_put_insert = TrueLimiting methods~~~~~~~~~~~~~~~~By default collections will autogenerate methods GET, POST and PATCH,while single resources will autogenerate methods GET, PUT, PATCH,DELETE.To limit which methods are autogenerated for your resource, simply listmethod names as follows:::    # Able to create and search collection:    class AccountCollectionResource(CollectionResource):        model = Account        methods = ['GET', 'POST']    # Only able to read individual accounts:    class AccountResource(CollectionResource):        model = Account        methods = ['GET']Pre-method functionality.~~~~~~~~~~~~~~~~~~~~~~~~~To do something before a POST or PATCH method is called, add specialmethods as follows:::    class AccountCollectionResource(CollectionResource):        model = Account        def before_post(self, req, resp, db_session, resource, *args, **kwargs):          # Anything you do with db_session is in the same transaction as the          # resource creation.  Resource is the new resource not yet added to the          # database.          pass    class AccountResource(SingleResource):        model = Account        def before_patch(self, req, resp, db_session, resource, *args, **kwargs):          # Anything you do with db_session is in the same transaction as the          # resource update.  Resource is the modified resource not yet saved to          # the database.          pass        def before_delete(self, req, resp, db_session, resource, *args, **kwargs):          # Anything you do with db_session is in the same transaction as the          # resource delete.  Resource is the resource to be deleted (or &quot;marked as          deleted&quot; - see section on &quot;not really deleting&quot;).          passPost-method functionality~~~~~~~~~~~~~~~~~~~~~~~~~To do something after success of a method, add special methods asfollows:::    class AccountCollectionResource(CollectionResource):        model = Account        def after_get(self, req, resp, collection, *args, **kwargs):            # 'collection' is the SQLAlchemy collection resulting from the search            pass        def after_post(self, req, resp, new, *args, **kwargs):            # 'new' is the created SQLAlchemy instance            pass        def after_patch(self, req, resp, *args, **kwargs):            pass    class AccountResource(CollectionResource):        model = Account        def after_get(self, req, resp, item, *args, **kwargs):            # 'item' is the retrieved SQLAlchemy instance            pass        def after_put(self, req, resp, item, *args, **kwargs):            # 'item' is the changed SQLAlchemy instance            pass        def after_patch(self, req, resp, item, *args, **kwargs):            # 'item' is the patched SQLAlchemy instance            pass        def after_delete(self, req, resp, item, *args, **kwargs):            passBe careful not to throw an exception in the above methods, as this willend up propagating a 500 Internal Server Error.Modifying a patch~~~~~~~~~~~~~~~~~If you want to modify the patched resource before it is saved (e.g. toset default values), you can override the default empty method inSingleResource:::    class AccountResource(SingleResource):        model = Account        def modify_patch(self, req, resp, resource, *args, **kwargs):            &quot;&quot;&quot;            Add 'arino' to people's names            &quot;&quot;&quot;            resource.name = resource.name + 'arino'Identification and Authorization~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Define classes that know how to identify and authorize users:::    class TestIdentifier(object):        def identify(self, req, resp, resource, params):            req.context['user'] = req.get_header('Authorization')            if req.context['user'] is None:                raise HTTPUnauthorized('Authentication Required', 'No credentials supplied')    class TestAuthorizer(object):        def authorize(self, req, resp, resource, params):            if 'user' not in req.context or req.context['user'] != 'Jim':                raise HTTPForbidden('Permission Denied', 'User does not have access to this resource')Then declare which class identifies/authorizes what resource or method:::    # Authorizes for all methods    @identify(TestIdentifier)    @authorize(TestAuthorizer)    class AccountCollectionResource(CollectionResource):        model = Account    # Or only some methods    @identify(TestIdentifier)    @authorize(TestAuthorizer, methods=['GET', 'POST'])    @authorize(OtherAuthorizer, methods=['PATCH'])    class OtherAccountCollectionResource(CollectionResource):        model = AccountFilters/Preconditions~~~~~~~~~~~~~~~~~~~~~You may filter on GET, and set preconditions on single resource PATCH orDELETE:::    class AccountCollectionResource(CollectionResource):        model = Account        def get_filter(self, req, resp, query, *args, **kwargs):            # Only allow getting accounts below id 5            return query.filter(Account.id &lt; 5)    class AccountResource(SingleResource):        model = Account        def get_filter(self, req, resp, query, *args, **kwargs):            # Only allow getting accounts below id 5            return query.filter(Account.id &lt; 5)        def patch_precondition(self, req, resp, query, *args, **kwargs):            # Only allow setting owner of non-owned account            if 'owner' in req.context['doc'] and req.context['doc']['owner'] is not None:                return query.filter(Account.owner == None)            else:                return query        def delete_precondition(self, req, resp, query, *args, **kwargs):            # Only allow deletes of non-owned accounts            return query.filter(Account.owner == None)Note that there is an opportunity for a race condition here, whereanother process updates the row AFTER the check triggered bypatch\_precondition is run, but BEFORE the row update. This would leaveinconsistent data in your application if the other update would make theprecondition no longer hold.To prevent this, you can simply add a `versioningcolumn &lt;http://docs.sqlalchemy.org/en/latest/orm/versioning.html&gt;`__ toyour model. When your model contains such a column, then as long as youhave a precondition to check for the correct conditions before updating,you will be guaranteed that if another process changes the row in themeantime, you will fail to update, and a 409 response will be returned.This doesn't necessarily mean the row no longer conforms to theprecondition, so you can try the update again, and it will update if theprecondition still holds.This versioning only helps you on an UPDATE, not a DELETE, so if youwant a delete\_precondition to be protected, you will need to usemark\_deleted to update the row (see &quot;not really deleting&quot;, next),instead of doing a true delete.Not really deleting~~~~~~~~~~~~~~~~~~~If you want to just mark a resource as deleted in the database, but notreally delete the row, define a 'mark\_deleted' in your SingleResourcesubclass:::    class AccountResource(SingleResource):        model = Account        def mark_deleted(self, req, resp, instance, *args, **kwargs):            instance.deleted = datetime.utcnow()This will cause the changed instance to be updated in the databaseinstead of doing a DELETE.Of course, the database row will still be accessible via GET, but youcan automatically filter out &quot;deleted&quot; rows like this:::    class AccountCollectionResource(CollectionResource):        model = Account        def get_filter(self, req, resp, resources, *args, **kwargs):            return resources.filter(Account.deleted == None)    class AccountResource(SingleResource):        model = Account        def get_filter(self, req, resp, resources, *args, **kwargs):            return resources.filter(Account.deleted == None)        def mark_deleted(self, req, resp, instance, *args, **kwargs):            instance.deleted = datetime.utcnow()You could also look at the request to only filter out &quot;deleted&quot; rows forsome users.Joins~~~~~If you want to add query parameters to your collection queries, that donot refer to a resource attribute, but which refer to an attribute in alinked table, you can do this in get\_filter, as with the below example.Ensure that you remove the extra parameter value from req.params beforereturning from get\_filter, as falcon-autocrud will try (and fail) tolook up the parameter in the main resource class.::    class Company(Base):        __tablename__ = 'companies'        id          = Column(Integer, primary_key=True)        name        = Column(String(50), unique=True)        employees   = relationship('Employee')    class Employee(Base):        __tablename__ = 'employees'        id          = Column(Integer, primary_key=True)        name        = Column(String(50), unique=True)        company_id  = Column(Integer, ForeignKey('companies.id'), nullable=True)        company     = relationship('Company', back_populates='employees')    class EmployeeCollectionResource(CollectionResource):        model = Employee        def get_filter(self, req, resp, query, *args, **kwargs):            if 'company_name' in req.params:                company_name = req.params['company_name']                del req.params['company_name']                query = query.join(Employee.company).filter(Company.name == company_name)            return queryAlternatively, for arguments that are part of the URL you may uselookup\_attr\_map directly (note that attr\_map is now deprecated - seebelow):::    class CompanyEmployeeCollectionResource(CollectionResource):        model = Employee        lookup_attr_map = {            'company_id':   lambda req, resp, query, *args, **kwargs: query.join(Employee.company).filter(Company.id == kwargs['company_id'])        }This is useful for the following sort of URL:::    GET /companies/{company_id}/employeesMapping~~~~~~~Mapping used to be done with attr\_map. This is now deprecated in favourof lookup\_attr\_map and inbound\_attr\_map (since attr\_map was usedfor two different purposes before).To look up an entry via part of the URL:::    GET /companies/{company_id}/employeesUse the name of the column to map to:::    class CompanyEmployeeCollectionResource(CollectionResource):        model = Employee        lookup_attr_map = {            'company_id': 'coy_id'        }Or use a lambda to return a modified query:::    class CompanyEmployeeCollectionResource(CollectionResource):        model = Employee        lookup_attr_map = {            'company_id': lambda req, resp, query, *args, **kwargs: query.join(Employee.company).filter(Company.id == kwargs['company_id'])        }You may use inbound\_attr\_map to specify mappings to place the valuefrom a URL component into another field:::    class CompanyEmployeeCollectionResource(CollectionResource):        model = Employee        inbound_attr_map = {            'company_id': 'coy_id'        }Both lookup\_attr\_map and inbound\_attr\_map may have a mapping valueset to None, in which case the mapping key in the URL component isignored.Sorting~~~~~~~You can specify a default sorting of results from the collection search.The below example sorts firstly by name, then by salary descending:::    class EmployeeCollectionResource(CollectionResource):        model = Employee        default_sort = ['name', '-salary']The caller can specify a sort (which overrides the default if defined):::    GET /path/to/collection?__sort=name,-salaryPaging~~~~~~The caller can specify an offset and/or limit to collection GET toprovide paging of search results.::    GET /path/to/collection?__offset=10&amp;limit=10This is generally most useful in combination with \_\_sort to ensureconsistency of sorting.Limiting response fields~~~~~~~~~~~~~~~~~~~~~~~~You can limit which fields are returned to the client like this:::    class EmployeeCollectionResource(CollectionResource):        model = Employee        response_fields = ['id', 'name']Or you can limit them programmatically like this:::    class EmployeeCollectionResource(CollectionResource):        model = Employee        def response_fields(self, req, resp, resource, *args, **kwargs):            # Determine response fields via things such as authenticated user            return fieldsCreating linked resources~~~~~~~~~~~~~~~~~~~~~~~~~The collection POST method allows creation of linked resources in theone POST call. If your model includes a relationship to the linkedresource, you can include the attributes to use in the new linkedresource, and the link will be automatically made in the database:::    class Company(Base):        __tablename__ = 'companies'        id          = Column(Integer, primary_key=True)        name        = Column(String(50), unique=True)        employees   = relationship('Employee')    class Employee(Base):        __tablename__ = 'employees'        id          = Column(Integer, primary_key=True)        name        = Column(String(50), unique=True)        company_id  = Column(Integer, ForeignKey('companies.id'), nullable=True)        company     = relationship('Company', back_populates='employees')    class CompanyCollectionResource(CollectionResource):        model = Company        allow_subresources = True::    cat post.json    {      name: &quot;Initech&quot;,      employees: [        {          name: &quot;Alice&quot;        },        {          name: &quot;Bob&quot;        }      ]    }    cat post.json | http POST http://localhost/companiesThis will create a company called Initech and two employees, who will belinked to Initech via Employee.company\_id. Note the thatCollectionResource subclass must have the attribute allow\_subresourcesand set it to True, for this feature to be enabled.Bulk operations~~~~~~~~~~~~~~~You can bulk add entities using a PATCH method to a collection. If thecollection is defined in the standard way, you are limited to adding toonly that model:::    class EmployeeCollectionResource(CollectionResource):        model = EmployeeTo add to the employee collection, each operation's path must be '/':::    echo '{&quot;patches&quot;: [{&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/&quot;, &quot;value&quot;: {&quot;name&quot;: &quot;Jim&quot;}}]}' | http PATCH http://localhost/employeesIf you would like to be able to add to multiple types of collection inone bulk update, define the path and model for each in a specialcollection:::    class RootResource(CollectionResource):        patch_paths = {          '/employees': Employee,          '/accounts':  Account,        }    app.add_route('/', RootResource(db_engine))To add to the collections, each operation's path must be in the definedpatch\_paths:::    cat patches.json    {      &quot;patches&quot;: [        {&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/employees&quot;, &quot;value&quot;: {&quot;name&quot;: &quot;Jim&quot;}}        {&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/accounts&quot;, &quot;value&quot;: {&quot;name&quot;: &quot;Sales&quot;}}      ]    }    cat patches.json | http PATCH http://localhost/employeesAll the operations done in a single PATCH are performed within atransaction.Naive datetimes~~~~~~~~~~~~~~~Normally a datetime is assumed to be in UTC, so they are expected to bein the format 'YYYY-mm-ddTHH:MM:SSZ', and are also output like that.Sometimes (not often!) you need to store a &quot;naive&quot; datetime, where timezone is not relevant (e.g. to store the datetime of a nationwide publicholiday, where the time zone is not relevant, and the &quot;real&quot; date/timeis simply in the local time zone, whatever that might be - i.e. theclient can treat is as being in their own localtime.For cases such as this, simply list the field among the naive datetimeslike so:::    class PublicHolidayCollectionResource(CollectionResource):        model = PublicHoliday        naive_datetimes = ['start', 'end']These fields will then be parsed and returned in the format'YYYY-mm-ddTHH:MM:SS', i.e. without the 'Z' suffix.Meta-information~~~~~~~~~~~~~~~~To add meta-information to each resource in a collection response,assuming your models are:::    class Team(Base):        __tablename__ = 'teams'        id          = Column(Integer, primary_key=True)        name        = Column(String(50))        characters  = relationship('Character')    class Character(Base):        __tablename__ = 'characters'        id          = Column(Integer, primary_key=True)        name        = Column(String(50))        team_id     = Column(Integer, ForeignKey('teams.id'), nullable=True)        team        = relationship('Team', back_populates='characters')Then include the following:::    catchphrases = {        'Oliver':   'You have failed this city',        'Cisco':    &quot;OK, you don't get to pick the names&quot;,    }    class CharacterCollectionResource(CollectionResource):        model = Character        resource_meta = {            'catchphrase':  lambda resource: catchphrases.get(resource.name, None)        }To add meta-information to the top level of a single resource response,include the following:::    catchphrases = {        'Oliver':   'You have failed this city',        'Cisco':    &quot;OK, you don't get to pick the names&quot;,    }    class CharacterResource(SingleResource):        model = Character        meta = {            'catchphrase':  lambda resource: catchphrases.get(resource.name, None)        }You can join another table to get the meta information:::    class CharacterCollectionResource(CollectionResource):        model = Character        resource_meta = {            'catchphrase':  lambda resource, team_name: catchphrases.get(resource.name, None),            'team_name':    lambda resource, team_name: team_name,        }        extra_select = [Team.name]        def get_filter(self, req, resp, query, *args, **kwargs):            return query.join(Team)    class CharacterResource(SingleResource):        model = Character        meta = {            'catchphrase':  lambda resource, team_name: catchphrases.get(resource.name, None),            'team_name':    lambda resource, team_name: team_name,        }        extra_select = [Team.name]        def get_filter(self, req, resp, query, *args, **kwargs):            return query.join(Team)You can even use SQL functions to calculate the values in themeta-information:::    from sqlalchemy import func    class TeamCollectionResource(CollectionResource):        model = Team        resource_meta = {            'team_size': lambda resource, team_size: team_size,        }        extra_select = [func.count(Character.id)]        def get_filter(self, req, resp, query, *args, **kwargs):            return query.join(Character).group_by(Team.id)    class TeamResource(SingleResource):        model = Team        meta = {            'team_size': lambda resource, team_size: team_size,        }        extra_select = [func.count(Character.id)]        def get_filter(self, req, resp, query, *args, **kwargs):            return query.join(Character).group_by(Team.id)Or you can determine them entirely programmatically like this:::    class TeamCollectionResource(CollectionResource):        model = Team        def resource_meta(self, req, resp, resource, team_size, *args, **kwargs):            return {                'team_size': team_size,            }        extra_select = [func.count(Character.id)]        def get_filter(self, req, resp, query, *args, **kwargs):            return query.join(Character).group_by(Team.id)    class TeamResource(SingleResource):        model = Team        def meta(self, req, resp, resource, team_size, *args, **kwargs):            return {                'team_size': team_size,            }        extra_select = [func.count(Character.id)]        def get_filter(self, req, resp, query, *args, **kwargs):            return query.join(Character).group_by(Team.id)The advantage of using the above method is that the keys can also bedetermined at runtime, and may change in difference circumstances (e.g.according to query parameters, or the permissions of the caller). Toinclude NO meta at all for the resource, return None from``resource_meta`` or ``meta`` functions.Access to submitted data~~~~~~~~~~~~~~~~~~~~~~~~Note that the request body can be accessed (e.g. in pre-methodfunctionality function) either from ``req.context['doc']`` (as JSON), orthe original binary body content is available in``req.context['request_body']`` if you specify that the HTTP methodshould retain it:::    class TeamResource(CollectionResource):      model = Team      keep_request_body = ['POST'].. |Codeship Status for garymonson/falcon-autocrud| image:: https://codeship.com/projects/ed5bb4c0-b517-0133-757f-3e023a4cadff/status?branch=master   :target: https://codeship.com/projects/134046</longdescription>
</pkgmetadata>