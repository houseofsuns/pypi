<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Tests](https://github.com/DataShades/ckanext-flakes/workflows/Tests/badge.svg)](https://github.com/DataShades/ckanext-flakes/actions/workflows/test.yml)# ckanext-flakesTools for creating and managing independent chunks of data.This extension provides a base entity for storing arbitrary data. It can beused in a number of cases, especially, if you don't want yet to create a brandnew model, database migrations and tables, but you have no other options.`ckanext-flakes` gives you a set of actions for creating and managing smalldictionary-like objects(anything, that can be serialized into JSON). If you areusing it and want to add an extra action, feel free to create a PR or an issuewith your suggestion.## Structure* [Examples](#examples)* [Requirements](#definition)* [Installation](#installation)* [Configuration](#configuration)* [Interfaces](#interfaces)* [API](#api)  * [`flakes_flake_create`](#flakes_flake_create)  * [`flakes_flake_show`](#flakes_flake_show)  * [`flakes_flake_list`](#flakes_flake_list)  * [`flakes_flake_update`](#flakes_flake_update)  * [`flakes_flake_override`](#flakes_flake_override)  * [`flakes_flake_delete`](#flakes_flake_delete)  * [`flakes_flake_lookup`](#flakes_flake_lookup)  * [`flakes_flake_validate`](#flakes_flake_validate)  * [`flakes_data_validate`](#flakes_data_validate)  * [`flakes_data_example`](#flakes_data_example)  * [`flakes_flake_materialize`](#flakes_flake_materialize)  * [`flakes_flake_combine`](#flakes_flake_combine)  * [`flakes_flake_merge`](#flakes_flake_merge)  * [`flakes_data_patch`](#flakes_data_patch)  * [`flakes_extras_patch`](#flakes_extras_patch)## Examples### Create a collection of recordsScenario: user needs a todo listFlakes created by any user are visible only to this user so flakes can be usedas a storage for private data.Flakes can have `extras`, that plays a role of tags. `extras` represented by adictionary and whenever user lists his flakes, he has an option to see onlyflakes that contains particular data inside extras.```pythonflake_create = tk.get_action(&quot;flakes_flake_create&quot;)flake_list = tk.get_action(&quot;flakes_flake_create&quot;)# create an urgent taksflake_create(    {&quot;user&quot;: &quot;john&quot;},    {&quot;data&quot;: {&quot;task&quot;: &quot;feed the cat&quot;}, &quot;extras&quot;: {&quot;when&quot;: &quot;today&quot;, &quot;type&quot;: &quot;task&quot;}})# create a couple of tasks that can waitflake_create(    {&quot;user&quot;: &quot;john&quot;},    {&quot;data&quot;: {&quot;task&quot;: &quot;buy food&quot;}, &quot;extras&quot;: {&quot;when&quot;: &quot;tomorrow&quot;, &quot;type&quot;: &quot;task&quot;}})flake_create(    {&quot;user&quot;: &quot;john&quot;},    {&quot;data&quot;: {&quot;task&quot;: &quot;update documentation&quot;}, &quot;extras&quot;: {&quot;when&quot;: &quot;tomorrow&quot;, &quot;type&quot;: &quot;task&quot;}})# list all the tasksflake_list(    {&quot;user&quot;: &quot;john&quot;},    {&quot;extras&quot;: {&quot;type&quot;: &quot;task&quot;}})# list all the urgent tasksflake_list(    {&quot;user&quot;: &quot;john&quot;},    {&quot;extras&quot;: {&quot;type&quot;: &quot;task&quot;, &quot;when&quot;: &quot;today&quot;}})# list all the tasks for tomorrowflake_list(    {&quot;user&quot;: &quot;john&quot;},    {&quot;extras&quot;: {&quot;type&quot;: &quot;task&quot;, &quot;when&quot;: &quot;tomorrow&quot;}})```### Save the value of the option individually for every userScenario: each user can set a theme of application and this theme will be applied only for the current userFlakes are created for the user from the `context`. Flakes of the user A arevisible only to the user A, flakes of the user B exist in the differentnamespace and are visible only to the user B.Each flake **can** have a name. Name must be unique among the flakes of theuser. But different users can use the same names for their flakes, becauseevery user has its own namespace for flakes.Flakes can be created either via `flakes_flake_create` action(accepts**optional** name and raises exception if name is not unique) or`flakes_flake_override`(requires a name and creates a new flake if name is nottaken or updates existing flake if name already used by some flake)In order to get the flake use `flakes_flake_show` with the `id` of the flake or`flakes_flake_lookup` with the `name`.```python# set a theme for Johntk.get_action(&quot;flakes_flake_override&quot;)(    {&quot;user&quot;: &quot;john&quot;},    {&quot;name&quot;: &quot;application:theme&quot;, &quot;data&quot;: {&quot;theme&quot;: &quot;dark&quot;}})# set a theme for Marytk.get_action(&quot;flakes_flake_override&quot;)(    {&quot;user&quot;: &quot;mary&quot;},    {&quot;name&quot;: &quot;application:theme&quot;, &quot;data&quot;: {&quot;theme&quot;: &quot;light&quot;}})# get the value from the flakejohn_theme = tk.get_action(&quot;flakes_flake_lookup&quot;)(    {&quot;user&quot;: &quot;john&quot;},    {&quot;name&quot;: &quot;application:theme&quot;})[&quot;data&quot;][&quot;theme&quot;]mary_theme = tk.get_action(&quot;flakes_flake_lookup&quot;)(    {&quot;user&quot;: &quot;mary&quot;},    {&quot;name&quot;: &quot;application:theme&quot;})[&quot;data&quot;][&quot;theme&quot;]assert john_theme == &quot;dark&quot;assert mary_theme == &quot;light&quot;```### Create and obtain global variableScenario: application requires global option, that can be changed in runtimeBy default flakes are created in the &quot;namespace&quot; of the current user. Only theauthor can see and modify his own flakes.Global values should not be owned by someone, so here we need &quot;unowned&quot; flake -the flake that is not connected to the particular user. Only sysadmin cancreate such flakes, so we are going to use `ignore_auth=True` attribute of thecontext.We'll use `flakes_flake_override` action, that accepts a `name` of the flakeand either updates existing flakes with this name or creates a new one if thisname is free. In this way we'll avoid duplicates of the global flake.```python# create a flaketk.get_action(&quot;flakes_flake_override&quot;)(    {&quot;ignore_auth&quot;: True}, # only syadmin allowed to create unowned flakes with empty author id    {&quot;name&quot;: &quot;global:config:value&quot;, &quot;data&quot;: {&quot;value&quot;: 1}, &quot;author_id&quot;: None})# get the value from the flakevalue = tk.get_action(&quot;flakes_flake_lookup&quot;)(    {&quot;ignore_auth&quot;: True},    {&quot;name&quot;: &quot;global:config:value&quot;, &quot;author_id&quot;: None})[&quot;data&quot;][&quot;value&quot;]```## RequirementsRequires python v3.7 or greater. Python v2 support doesn't require much effort,but it neither worth the time you'll spend on it.Compatibility with core CKAN versions:| CKAN version | Compatible? ||--------------|-------------|| 2.9          | yes         || 2.10         | yes         |## InstallationTo install ckanext-flakes:1. Install it via **pip**:   ```sh   pip install ckanext-flakes   ```1. Add `flakes` to the `ckan.plugins` setting in your CKAN config file.1. Run DB migrations:   ```sh   ckan db upgrade -p flakes   ```## Configuration```ini# Any user can create a new flake.# (optional, default: true)ckanext.flakes.creation.allowed = false# Any user can validate flake or plain data.# (optional, default: false)ckanext.flakes.validation.allowed = true```## InterfacesProvides `ckanext.flakes.interfaces.IFlakes` interface. Always use`inherit=True` when implementing it, because it may change in the future.Currently it provides the following hooks:```pythonclass IFlakes(Interface):    &quot;&quot;&quot;Extend functionality of ckanext-flakes&quot;&quot;&quot;    def get_flake_schemas(self) -&gt; dict[str, dict[str, Any]]:        &quot;&quot;&quot;Register named validation schemas.        Used by `flakes_flake_validate` and `flakes_data_validate` actions.        Returns:            Mapping of names and corresponding validation schemas.        Example:            def get_flake_schemas(self) -&gt; dict[str, dict[str, Any]]:                return {                    &quot;schema-that-requires-name&quot;: {&quot;name&quot;: [not_missing]}                }        &quot;&quot;&quot;        return {}    def get_flake_factories(self) -&gt; dict[str, Callable[[dict[str, Any]], dict[str, Any]]]:        &quot;&quot;&quot;Register named example factories.        Used by `flakes_data_example` action.        Returns:            Mapping of names and corresponding example factories.        Example:            def get_flake_factories(self) -&gt; dict[str, dict[str, Any]]:                def factory(payload: dict[str, Any]):                    return {&quot;field&quot;: &quot;value&quot;}                return {                    &quot;test-factory&quot;: factory                }        &quot;&quot;&quot;        return {}```## API### `flakes_flake_create`Create a flake.Args:    name (str, optional): name of the flake    data (dict): flake's data    parent_id (str, optional): ID of flake to extend    author_id (str, optional): author ID(can be set only by sysadmin)    extras (dict): flake's extra details### `flakes_flake_show`Display existing flakeArgs:    id (str): ID of flake to display    expand (bool, optional): Extend flake using data from the parent flakes### `flakes_flake_list`Display all flakes of the user.If `extras` dictionary passed, show only flakes that contains given extras. Example:    first_flake = Flake(extras={&quot;xxx&quot;: {&quot;yyy&quot;: &quot;hello&quot;}})    second_flake = Flake(extras={&quot;xxx&quot;: {&quot;yyy&quot;: &quot;world&quot;}})    flake_list(context, {&quot;extras&quot;: {&quot;xxx&quot;: {&quot;yyy&quot;: &quot;hello&quot;}})    &gt;&gt;&gt; first_flakeArgs:    expand (bool, optional): Extend flake using data from the parent flakes    extras (dict, optional): Show only flakes whose extras contains passed dict    author_id (str, optional): author ID(can be set only by sysadmin)### `flakes_flake_update`Update existing flakeArgs:    id (str): ID of flake to update    data (dict): flake's data    parent_id (str, optional): ID of flake to extend    extras (dict): flake's extra details### `flakes_flake_override`Update existing flake by name or create a new one.Args:    name (str): Name flake to override    data (dict): template itself    parent_id (str, optional): ID of flake to extend    author_id (str, optional): author ID(can be set only by sysadmin if flake does not exist)    extras (dict): flake's extra details### `flakes_flake_delete`Delete existing flakeArgs:    id (str): ID of flake to delete### `flakes_flake_lookup`Display flake using its name.Args:    name (str): Name of the flake    expand (bool, optional): Extend flake using data from the parent flakes    author_id (str, optional): author ID(can be set only by sysadmin)### `flakes_flake_validate`Validate existing flakeSchemas must be registered via `IFlakes` interface.Args:    id (str): ID of flake to validate    expand (bool, optional): Extend flake using data from the parent flakes    schema(str): validation schema for the flake's data### `flakes_data_validate`Validate arbitrary data against the named schema(registered via IFlakes).Args:    data (dict): data that needs to be validated    schema(str): validation schema for the data### `flakes_data_example`Generate an example of the flake's data using named factory(registered via IFlakes).Factories must be registered via `IFlakes` interface.Args:    factory(str): example factory    data (dict, optional): payload for the example factory### `flakes_flake_materialize`Send flake's data to API action.Args:    id (str): ID of flake to materialize    expand (bool, optional): Extend flake using data from the parent flakes    remove (bool, optional): Remove flake after materialization    action (str): API action to use for materialization### `flakes_flake_combine`Combine data from multiple flakes`id` argument specifies all the flakes that must be combined. All of the flakesmust exist, otherwise `NotFound` error raised. IDs at the start of the list havehigher priority(override matching keys). IDs at the end of the list have lowerpriority(can be shadowed by former flakes).`expand` must be a `dict[str, bool]`. Keys are IDs of the flakes, values areexpand flags for the corresponding flake.Args:    id (list): IDs of flakes.    expand (dict, optional): Extend flake using data from the parent flakes### `flakes_flake_merge`Combine multiple flakes and save the result.Args:    id (list): IDs of flakes.    expand (dict, optional): Extend flake using data from the parent flakes    remove (bool, optional): Remove flakes after the operation.    destination (str, optional): Save data into the specified flake instead of a new one### `flakes_data_patch`Partially overrides data leaving other fields intact.Args:    id (str): ID of flake    data (dict): patch for data### `flakes_extras_patch`Partially overrides extras leaving other fields intact.Args:    id (str): ID of flake    extras (dict): patch for extras## Developer installationTo install ckanext-flakes for development, activate your CKAN virtualenv anddo:    git clone https://github.com/DataShades/ckanext-flakes.git    cd ckanext-flakes    python setup.py develop## TestsTo run the tests, do:    pytest## License[AGPL](https://www.gnu.org/licenses/agpl-3.0.en.html)</longdescription>
</pkgmetadata>