<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;img width=&quot;390&quot; alt=&quot;histolab&quot; src=&quot;https://user-images.githubusercontent.com/4196091/164645273-3d256916-1d5b-46fd-94fd-04358bb0db97.png&quot;&gt;![Open Source Love](https://badges.frapsoft.com/os/v1/open-source.png?v=103)&lt;table&gt;&lt;tr&gt;    &lt;td&gt;Test Status&lt;/td&gt;    &lt;td&gt;        &lt;img src=&quot;https://github.com/histolab/histolab/workflows/CI/badge.svg?branch=master&quot;&gt;        &lt;a href=&quot;https://codecov.io/gh/histolab/histolab&quot;&gt;            &lt;img src=&quot;https://codecov.io/gh/histolab/histolab/branch/master/graph/badge.svg?token=PL3VIM1PGL&quot;/&gt;        &lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Code Quality&lt;/td&gt;    &lt;td&gt;        &lt;img src=&quot;https://github.com/histolab/histolab/actions/workflows/codeql.yml/badge.svg?branch=master&amp;event=push&quot;&gt;        &lt;a href=&quot;https://www.codefactor.io/repository/github/histolab/histolab&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://www.codefactor.io/repository/github/histolab/histolab/badge&quot;&gt;&lt;/a&gt;        &lt;a href=&quot;https://github.com/psf/black&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/code%20style-black-000000.svg&quot;&gt;&lt;/a&gt;        &lt;a href=&quot;https://github.com/PyCQA/bandit&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/security-bandit-yellow.svg&quot;&gt;&lt;/a&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Version Info&lt;/td&gt;    &lt;td&gt;        &lt;a href=&quot;https://pypi.org/project/histolab/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/histolab&quot;&gt;&lt;/a&gt;        &lt;a href=&quot;https://anaconda.org/conda-forge/histolab&quot;&gt;&lt;img src=&quot;https://anaconda.org/conda-forge/histolab/badges/version.svg&quot; /&gt;&lt;/a&gt;        &lt;img src=&quot;https://img.shields.io/pypi/pyversions/histolab&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/wheel/histolab&quot;&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;License&lt;/td&gt;    &lt;td&gt;        &lt;a href=https://github.com/histolab/histolab/blob/master/LICENSE.txt&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/license/histolab/histolab&quot;&gt;&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Documentation&lt;/td&gt;    &lt;td&gt;&lt;a href=&quot;https://histolab.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://readthedocs.org/projects/histolab/badge/?version=latest&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;**Compatibility Details**| Operating System  | Python version  ||-------------------|-----------------||  Linux            | &lt;img src=https://img.shields.io/badge/-3.7%20%7C%203.8%20%7C%203.9%20%7C%203.10-blue&gt;||  MacOs            | &lt;img src=https://img.shields.io/badge/-3.7%20%7C%203.8%20%7C%203.9%20%7C%203.10-blue&gt;||  Windows          | &lt;img src=https://img.shields.io/badge/-3.7%20-blue&gt;|---## Table of Contents- [Motivation](#motivation)- [Quickstart](#quickstart)  - [TCGA data](#tcga-data)  - [Slide initialization](#slide-initialization)  - [Tile extraction](#tile-extraction)    - [Random Extraction](#random-extraction)    - [Grid Extraction](#grid-extraction)    - [Score-based extraction](#score-based-extraction)  - [Versioning](#versioning)  - [Authors](#authors)  - [License](#license)  - [Roadmap](#roadmap)  - [Acknowledgements](#acknowledgements)  - [References](#references)  - [Contribution guidelines](#contribution-guidelines)## MotivationThe histo-pathological analysis of tissue sections is the gold standard to assess the presence of many complex diseases, such as tumors, and understand their nature.In daily practice, pathologists usually perform microscopy examination of tissue slides considering a limited number of regions and the clinical evaluation relies on several factors such as nuclei morphology, cell distribution, and color (staining): this process is time consuming, could lead to information loss, and suffers from inter-observer variability.The advent of digital pathology is changing the way pathologists work and collaborate, and has opened the way to a new era in computational pathology. In particular, histopathology is expected to be at the center of the AI revolution in medicine [1], prevision supported by the increasing success of deep learning applications to digital pathology.Whole Slide Images (WSIs), namely the translation of tissue slides from glass to digital format, are a great source of information from both a medical and a computational point of view. WSIs can be coloured with different staining techniques (e.g. H&amp;E or IHC), and are usually very large in size (up to several GB per slide). Because of WSIs typical pyramidal structure, images can be retrieved at different magnification factors, providing a further layer of information beyond color.However, processing WSIs is far from being trivial. First of all, WSIs can be stored in different proprietary formats, according to the scanner used to digitalize the slides, and a standard protocol is still missing. WSIs can also present artifacts, such as shadows, mold, or annotations (pen marks) that are not useful. Moreover, giving their dimensions, it is not possible to process a WSI all at once, or, for example, to feed a neural network: it is necessary to crop smaller regions of tissues (tiles), which in turns require a tissue detection step.The aim of this project is to provide a tool for WSI processing in a reproducible environment to support clinical and scientific research. histolab is designed to handle WSIs, automatically detect the tissue, and retrieve informative tiles, and it can thus be integrated in a deep learning pipeline.## Getting Started### PrerequisitesPlease see [installation instructions](https://github.com/histolab/histolab/blob/master/docs/installation.rst).### DocumentationRead the full documentation here https://histolab.readthedocs.io/en/latest/.### CommunicationJoin our user group on &lt;img src=https://user-images.githubusercontent.com/4196091/101638148-01522780-3a2e-11eb-8502-f718564ffd43.png&gt; [Slack](https://communityinviter.com/apps/histolab/histolab)### 5 minutes introduction&lt;a href=&quot;https://youtu.be/AdR4JK-Eq60&quot; target=&quot;_blank&quot;&gt;&lt;img src=https://user-images.githubusercontent.com/4196091/105097293-a68a0200-5aa8-11eb-8327-6039940fbdca.png&gt;&lt;/a&gt;# QuickstartHere we present a step-by-step tutorial on the use of `histolab` toextract a tile dataset from example WSIs. The corresponding JupyterNotebook is available at &lt;https://github.com/histolab/histolab-box&gt;:this repository contains a complete `histolab` environment that can beused through [Docker](http://www.docker.com) on all platforms.Thus, the user can decide either to use `histolab` through`histolab-box` or installing it in his/her python virtual environment(using conda, pipenv, pyenv, virtualenv, etc...). In the latter case, asthe `histolab` package has been published on ([PyPi](http://www.pypi.org)),it can be easily installed via the command:```pip install histolab```alternatively, it can be installed via conda:```conda install -c conda-forge histolab```## TCGA dataFirst things first, let’s import some data to work with, for example theprostate tissue slide and the ovarian tissue slide available in the`data` module:```pythonfrom histolab.data import prostate_tissue, ovarian_tissue```**Note:** To use the `data` module, you need to install `pooch`, alsoavailable on PyPI (&lt;https://pypi.org/project/pooch/&gt;). This step isneedless if we are using the Vagrant/Docker virtual environment.The calling to a `data` function will automatically download the WSIfrom the corresponding repository and save the slide in a cacheddirectory:```pythonprostate_svs, prostate_path = prostate_tissue()ovarian_svs, ovarian_path = ovarian_tissue()```Notice that each `data` function outputs the corresponding slide, as anOpenSlide object, and the path where the slide has been saved.## Slide initialization`histolab` maps a WSI file into a `Slide` object. Each usage of a WSIrequires a 1-o-1 association with a `Slide` object contained in the`slide` module:```pythonfrom histolab.slide import Slide```To initialize a Slide it is necessary to specify the WSI path, and the`processed_path` where the tiles will be saved. In ourexample, we want the `processed_path` of each slide to be a subfolder ofthe current working directory:```pythonimport osBASE_PATH = os.getcwd()PROCESS_PATH_PROSTATE = os.path.join(BASE_PATH, 'prostate', 'processed')PROCESS_PATH_OVARIAN = os.path.join(BASE_PATH, 'ovarian', 'processed')prostate_slide = Slide(prostate_path, processed_path=PROCESS_PATH_PROSTATE)ovarian_slide = Slide(ovarian_path, processed_path=PROCESS_PATH_OVARIAN)```**Note:** If the slides were stored in the same folder, this can be donedirectly on the whole dataset by using the `SlideSet` object of the`slide` module.With a `Slide` object we can easily retrieve information about theslide, such as the slide name, the number of available levels, thedimensions at native magnification or at a specified level:```pythonprint(f&quot;Slide name: {prostate_slide.name}&quot;)print(f&quot;Levels: {prostate_slide.levels}&quot;)print(f&quot;Dimensions at level 0: {prostate_slide.dimensions}&quot;)print(f&quot;Dimensions at level 1: {prostate_slide.level_dimensions(level=1)}&quot;)print(f&quot;Dimensions at level 2: {prostate_slide.level_dimensions(level=2)}&quot;)``````Slide name: 6b725022-f1d5-4672-8c6c-de8140345210Levels: [0, 1, 2]Dimensions at level 0: (16000, 15316)Dimensions at level 1: (4000, 3829)Dimensions at level 2: (2000, 1914)``````pythonprint(f&quot;Slide name: {ovarian_slide.name}&quot;)print(f&quot;Levels: {ovarian_slide.levels}&quot;)print(f&quot;Dimensions at level 0: {ovarian_slide.dimensions}&quot;)print(f&quot;Dimensions at level 1: {ovarian_slide.level_dimensions(level=1)}&quot;)print(f&quot;Dimensions at level 2: {ovarian_slide.level_dimensions(level=2)}&quot;)``````Slide name: b777ec99-2811-4aa4-9568-13f68e380c86Levels: [0, 1, 2]Dimensions at level 0: (30001, 33987)Dimensions at level 1: (7500, 8496)Dimensions at level 2: (1875, 2124)```**Note:**    If the native magnification, *i.e.*, the magnification factor used to scan the slide, is provided in the slide properties, it is also possible    to convert the desired level to its corresponding magnification factor with the ``level_magnification_factor`` property.```python   print(        &quot;Native magnification factor:&quot;,        prostate_slide.level_magnification_factor()    )    print(        &quot;Magnification factor corresponding to level 1:&quot;,        prostate_slide.level_magnification_factor(level=1),    )``````    Native magnification factor: 20X    Magnification factor corresponding to level 1: 5.0X```Moreover, we can retrieve or show the slide thumbnail in a separate window:```pythonprostate_slide.thumbnailprostate_slide.show()```![](https://user-images.githubusercontent.com/4196091/92748324-5033e680-f385-11ea-812b-6a9a225ceca4.png)```pythonovarian_slide.thumbnailovarian_slide.show()```![](https://user-images.githubusercontent.com/4196091/92748248-3db9ad00-f385-11ea-846b-a5ce8cf3ca09.png)## Tile extractionOnce that the `Slide` objects are defined, we can proceed to extract thetiles. To speed up the extraction process, `histolab` automaticallydetects the tissue region with the largest connected area and crops thetiles within this field. The `tiler` module implements differentstrategies for the tiles extraction and provides an intuitive interfaceto easily retrieve a tile dataset suitable for our task. In particular,each extraction method is customizable with several common parameters:-   `tile_size`: the tile size;-   `level`: the extraction level (from 0 to the number of available    levels);-   `check_tissue`: if a minimum percentage of tissue is required to    save the tiles;-  `tissue_percent`: number between 0.0 and 100.0 representing the    minimum required percentage of tissue over the total area of the image    (default is 80.0);-   `prefix`: a prefix to be added at the beginning of the tiles’    filename (default is the empty string);-   `suffix`: a suffix to be added to the end of the tiles’ filename    (default is `.png`).### Random ExtractionThe simplest approach we may adopt is to randomly crop a fixed number oftiles from our slides; in this case, we need the `RandomTiler`extractor:```pythonfrom histolab.tiler import RandomTiler```Let us suppose that we want to randomly extract 30 squared tiles at level2 of size 128 from our prostate slide, and that we want to save them onlyif they have at least 80% of tissue inside. We then initialize our`RandomTiler` extractor as follows:```pythonrandom_tiles_extractor = RandomTiler(    tile_size=(128, 128),    n_tiles=30,    level=2,    seed=42,    check_tissue=True, # default    tissue_percent=80.0, # default    prefix=&quot;random/&quot;, # save tiles in the &quot;random&quot; subdirectory of slide's processed_path    suffix=&quot;.png&quot; # default)```Notice that we also specify the random seed to ensure thereproducibility of the extraction process.We may want to check which tiles have been selected by the tiler, before starting the extraction procedure and saving them;the ``locate_tiles`` method of ``RandomTiler`` returns a scaled version of the slide with the corresponding tiles outlined. It is also possible to specifythe transparency of the background slide, and the color used for the border of each tile:```pythonrandom_tiles_extractor.locate_tiles(    slide=prostate_slide,    scale_factor=24,  # default    alpha=128,  # default    outline=&quot;red&quot;,  # default)```![](https://user-images.githubusercontent.com/31658006/104055082-6bf1b100-51ee-11eb-8353-1f5958d521d8.png)Starting the extraction is then as simple as calling the `extract` method on the extractor, passing theslide as parameter:```pythonrandom_tiles_extractor.extract(prostate_slide)```![](https://user-images.githubusercontent.com/31658006/104056327-9ba1b880-51f0-11eb-9a06-7f04ba2bb1dc.jpeg)Random tiles extracted from the prostate slide at level 2.### Grid ExtractionInstead of picking tiles at random, we may want to retrieve all thetiles available. The Grid Tiler extractor crops the tiles following a gridstructure on the largest tissue region detected in the WSI:```pythonfrom histolab.tiler import GridTiler```In our example, we want to extract squared tiles at level 0 of size 512from our ovarian slide, independently of the amount of tissue detected.By default, tiles will not overlap, namely the parameter defining thenumber of overlapping pixels between two adjacent tiles,`pixel_overlap`, is set to zero:```pythongrid_tiles_extractor = GridTiler(   tile_size=(512, 512),   level=0,   check_tissue=False,   pixel_overlap=0, # default   prefix=&quot;grid/&quot;, # save tiles in the &quot;grid&quot; subdirectory of slide's processed_path   suffix=&quot;.png&quot; # default)```Again, we can exploit the ``locate_tiles`` method to visualize the selected tiles on a scaled version of the slide:```pythongrid_tiles_extractor.locate_tiles(    slide=ovarian_slide,    scale_factor=64,    alpha=64,    outline=&quot;#046C4C&quot;,)```![](https://user-images.githubusercontent.com/31658006/104107093-37e3c200-52ba-11eb-8750-67a62bf62ca5.png)```pythongrid_tiles_extractor.extract(ovarian_slide)```and the extraction process starts when the extract method is calledon our extractor:![](https://user-images.githubusercontent.com/4196091/92751173-0993bb80-f388-11ea-9d30-a6cd17769d76.png)Examples of non-overlapping grid tiles extracted from the ovarian slideat level 0.### Score-based extractionDepending on the task we will use our tile dataset for, the extractedtiles may not be equally informative. The `ScoreTiler` allows us to saveonly the &quot;best&quot; tiles, among all the ones extracted with a gridstructure, based on a specific scoring function. For example, let ussuppose that our goal is the detection of mitotic activity on ourovarian slide. In this case, tiles with a higher presence of nuclei arepreferable over tiles with few or no nuclei. We can leverage the`NucleiScorer` function of the `scorer` module to order the extractedtiles based on the proportion of the tissue and of the hematoxylinstaining. In particular, the score is computed as ![formula](https://render.githubusercontent.com/render/math?math=N_t\cdot\mathrm{tanh}(T_t)) where ![formula](https://render.githubusercontent.com/render/math?math=N_t) is the percentage of nuclei and  ![formula](https://render.githubusercontent.com/render/math?math=T_t) the percentage of tissue in the tile *t*First, we need the extractor and the scorer:```pythonfrom histolab.tiler import ScoreTilerfrom histolab.scorer import NucleiScorer```As the `ScoreTiler` extends the `GridTiler` extractor, we also set the`pixel_overlap` as additional parameter. Moreover, we can specify thenumber of the top tiles we want to save with the `n_tile` parameter:```pythonscored_tiles_extractor = ScoreTiler(    scorer = NucleiScorer(),    tile_size=(512, 512),    n_tiles=100,    level=0,    check_tissue=True,    tissue_percent=80.0,    pixel_overlap=0, # default    prefix=&quot;scored/&quot;, # save tiles in the &quot;scored&quot; subdirectory of slide's processed_path    suffix=&quot;.png&quot; # default)```Notice that also the ``ScoreTiler`` implements the ``locate_tiles`` method, which visualizes (on a scaled version of the slide) the first ``n_tiles`` with the highest scores:```pythongrid_tiles_extractor.locate_tiles(slide=ovarian_slide)```![](https://user-images.githubusercontent.com/31658006/104172715-fc094380-5404-11eb-942a-4130b5cdb037.png)Finally, when we extract our cropped images, we can also write a reportof the saved tiles and their scores in a CSV file:```pythonsummary_filename = &quot;summary_ovarian_tiles.csv&quot;SUMMARY_PATH = os.path.join(ovarian_slide.processed_path, summary_filename)scored_tiles_extractor.extract(ovarian_slide, report_path=SUMMARY_PATH)```&lt;img src=&quot;https://user-images.githubusercontent.com/4196091/92751801-9d658780-f388-11ea-8132-5d0c82bb112b.png&quot; width=500&gt;Representation of the score assigned to each extracted tile by the`NucleiScorer`, based on the amount of nuclei detected.## VersioningWe use [PEP 440](https://www.python.org/dev/peps/pep-0440/) for versioning.## Authors* **[Alessia Marcolini](https://github.com/alessiamarcolini)*** **[Ernesto Arbitrio](https://github.com/ernestoarbitrio)*** **[Nicole Bussola](https://gitlab.fbk.eu/bussola)**## LicenseThis project is licensed under `Apache License  Version 2.0` - see the [LICENSE.txt](https://github.com/histolab/histolab/blob/master/LICENSE.txt) file for details## Roadmap[Open issues](https://github.com/histolab/histolab/issues)## Acknowledgements* [https://github.com/deroneriksson](https://github.com/deroneriksson)## References[1] Colling, Richard, et al. &quot;Artificial intelligence in digital pathology: A roadmap to routine use in clinical practice.&quot; The Journal of pathology 249.2 (2019)## Contribution guidelinesIf you want to contribute to histolab, be sure to review the [contribution guidelines](CONTRIBUTING.md)</longdescription>
</pkgmetadata>