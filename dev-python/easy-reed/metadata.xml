<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># easy-reedA Python library for easily configuring applications across multiple projects## The easy_reed.config_object.config objectthe core of the easy_reed library is in the easy_reed.config_object.config object.  This class provides an interface to define new configuration fields that an end user can manipulate through a .ini file.  While this functionality exists within the Python library in a module called ConfigParser (Which this library uses), the unique problem that it aims to solve is to provide a single location that different packages can use to define their own configuration, across multiple environments.  To avoid naming conflicts, this libarary implements a NameSpace concept for defining config fields.For the most part, developers should not instantiate a new Config object.  Instead, this library intializes a Config object to be used by any package within its init file.  This can be imported like so```from easy_reed import config```Then, a developer can define fields for their library under an easy_reed.namespace.NameSpace object and add them to the Config object.  the Config object acts like a dictionary of dictionaries.  If a developer wishes to access &quot;field1&quot; of namespace &quot;example&quot;, they would write```config[&quot;example&quot;][&quot;field1&quot;]```in the .ini file, the final config key will be the namespace name, followed by a '.' character, followed by the field name.```[DEFAULT]example.field1 = &quot;Testing&quot;```the .ini file is read once at module startup, but the final config field is not read into the Config Object itself until it is added via a namespace.  This is so that developers can define the expected type for the value and have the Config automatically convert the string into the final type when the NameSpace is added.## Defining new fields under a project namespaceTo define config fields for a library, a developer must define a Namespace```from easy_reed.namespace import NameSpaceproject_namespace = NameSpace(&quot;project&quot;)```Once that namespace is defined, a developer can then add however many fields they want through the NameSpace.add_entry method.```project_namespace.add_entry(&quot;field1&quot;, str, &quot;example&quot;)```add_entry takes three parameters:1. field_name - a string representing the config field key2. typ - a python type specifying what type to read the field as3. default - the default value to use if the end_user does not include the field in the .ini fileBy default, the config object is able to read in these types- string- int- float- bool- listNew type handlers can be added through the Config.add_handler method.  This allows it to parse strings into new types.Any number of new entries can be added in this way, though all field_names must be unique.```project_namespace.add_entry(&quot;field2&quot;, int, 0)project_namespace.add_entry(&quot;field3&quot;, float, 5.5)project_namespace.add_entry(&quot;field4&quot;, bool, True)project_namespace.add_entry(&quot;field5&quot;, list, [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])```Once all entries have been defined, the NameSpace can be added to the config via the add_namespace method```from easy_reed import configconfig.add_namespace(project_namespace)```Although the fields are read in by a ConfigParser at module startup, they are not made accessible through the config object until this registration has occured.  This allows the library to convert each field to the correct type underneath the hood with no developer intervention outside of defining the expected type.## Adding new type parserslets look at a class called 'Person'```class Person():    def __init__(self, name: str, age: int):        self.name: str = name        self.age: int = age    def get_name(self) -&gt; str:        return self.name    def get_age(self) -&gt; int:        return self.age```Let's say we want to be able to represent a Person object as a string in the config dictionary.  A person consists of a name and an age, so we could represent that with &quot;{name}:{age}&quot; in a string.  Let's define a function that can take a string and parse it to a Person when it is in this format.```    def parse_person(person_string: str):        # the argument must be a string        if not isinstance(person_string, str):            raise TypeError(msg)        # There should be exactly 1 ':' character in the string        if person_string.count(':') != 1:            raise ValueError(msg)                parse = person_string.split(':')        # After splitting by ':', the second element should be readable as int        if not parse[1].isdigit():            raise ValueError(msg)                return Person(parse[0], int(parse[1]))```Now we can pass this function to the Config object as a new type handler for the Person type.```config.add_handler(Person, parse_person)```Then we can add it to the NameSpace before passing it to the Config.```project_namespace.add_entry(&quot;guts&quot;, Person, Person(&quot;John&quot;, 23))```Now we could add a person into the .ini file.```[DEFAULT]example.guts = guts:28```once the namespace is added, this Person object can be accessed with the following.```config[&quot;example&quot;][&quot;guts&quot;]```## SectionsSince this library uses ConfigParser to read the .ini file, it uses the same format.  This means you can define multiple 'sections'.  This library treats each section like a different environment.```[DEFAULT]field1=hellofield2=yesfield3=0[LOCAL]field2=nofield3=1[QA]field3=2```The section that will be used by the Config object is determined by the __APP_ENVIRONMENT__ environment variable.  If a key is missing from a section but is available under DEFAULT, then the DEFAULT value will be used.</longdescription>
</pkgmetadata>