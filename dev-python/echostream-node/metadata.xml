<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># echostream-nodeEchoStream library for implementing remote nodes that can be used in the echostream system.This package supports creating External Nodes and Managed Node Types,and supports the following EchoStream use cases:- An External Node in an External App or Cross Account App that is a stand-alone application or part of another application, using either `threading` or `asyncio`.- An External Node in a Cross Account App that is an AWS Lambda function. This use case only supports `threading`.- A Managed Node Type, using either `threading` or `asyncio`## Installation### Python```bashpip install echostream-node```### AWS LambdaYou may use the publiclally provided layer instead of directly installing `echostream-node` in your lambda package. This layer includes `echostream-node` and all of the Python dependencies *except* those built-in to the AWS Lambda environment for Python.The Layer arn is:```arn:aws:lambda:{region}:226390263822:layer:echostream-node-{version}:1```where `{version}` is the version of `echostream-node` that you want, with `.` replaced with `_` and `{region}` is the AWS region that your Lambda will run in. Currently, `us-east-1`, `us-east-2`, `us-west-1` and `us-west-2` are supported.For example, for `echostream-node==0.3.7` in the `us-east-1` region the layer arn would be:```arn:aws:lambda:us-east-1:226390263822:layer:echostream-node-0_3_7:1```## Usage### ConfigurationTo instantiate a Node a number of variables are required. These can be provided either as environment variables or directly on Node creation:| Parameter | Environment Variable | Description || --- | --- | --- || `appsync_endpoint` | `APPSYNC_ENDPOINT` | The URL to the EchoStream API endpoint. || `client_id` | `CLIENT_ID` | The Application Client ID for the App's Cognito Client Application. || `name` | `NODE` | The Node's name. || `password` | `PASSWORD` | The password for the App User for the Node's App. || `tenant` | `TENANT` | The name of the Tenant that the Node is a part of. || `username` | `USER_NAME` | The name of the App User for the Node's App. || `user_pool_id` | `USER_POOL_ID` | The User Pool Id for the App's Cognito User Pool. |### Threading Application Node```pythonfrom signal import SIGHUP, SIGINT, SIGTERM, signal, strsignalfrom echostream_node import Messagefrom echostream_node.threading import AppNodeclass MyExternalNode(AppNode):    def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)            def signal_handler(self, signum: int, _: object) -&gt; None:        print(f&quot;{strsignal(signum)} received, shutting down&quot;)        self.stop()    def start(self) -&gt; None:        super().start()        signal(SIGHUP, self.signal_handler)        signal(SIGINT, self.signal_handler)        signal(SIGTERM, self.signal_handler)try:    my_external_node = MyExternalNode()    my_external_node.start()    for i in range(100):        message = my_external_node.create_message(str(i))        my_external_node.send_message(message)        my_external_node.audit_message(message)    my_external_node.join()except Exception:    print(&quot;Error running node&quot;)```### Asyncio Application Node```pythonimport asyncioimport aiorunfrom echostream_node import Messagefrom echostream_node.asyncio import Nodeclass MyExternalNode(Node):    async def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)async def main(node: Node) -&gt; None:    try:        await node.start()        for i in range(100):            message = my_external_node.create_message(str(i))            my_external_node.send_message(message)            my_external_node.audit_message(message)        await node.join()    except asyncio.CancelledError:        pass    except Exception:        print(&quot;Error running node&quot;)if __name__ == &quot;__main__&quot;:    aiorun.run(main(MyExternalNode()), stop_on_unhandled_errors=True, use_uvloop=True)```### Cross Account Lambda Node```pythonfrom echostream_node import Messagefrom echostream_node.threading import LambdaNodeclass MyExternalNode(LambdaNode):    def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)        MY_EXTERNAL_NODE = MyExternalNode()def lambda_handler(event, context):    MY_EXTERNAL_NODE.handle_event(event)```## Concurrent vs Sequential Message ProcessingBy default, all Nodes created using the package will process messages sequentially.This is normally the behavior that you want, as many messaging protocols requireguaranteed ordering and therefore sequential processing within your Nodes. If this isthe behavior that you require, nothign special is needed to gain it from `echostream-node`.However, there are use cases where message ordering is not important but processing speed is.In these cases, you may configure your Node upon creation to concurrently process the messagesthat it receives.### Making a Threading Application Node ConcurrentIf your Node inherits from the `echostream_node.threading.AppNode` class you can achieve concurrencyusing threading.This will create an AppNode that uses the provided `ThreadPoolExecutor` to concurrentlyprocess received `Message`s. Note that while you can set the maximum number of workers toless than 10, there is no gain to setting it to more than 10 since Nodes will only processup to 10 messages at a time.```pythonfrom concurrent.futures import ThreadPoolExecutorfrom echostream_node import Messagefrom echostream_node.threading import AppNodeclass MyExternalNode(AppNode):    def __init__(self) -&gt; None:        super().__init__(executor=ThreadPoolExecutor(max_workers=10))    def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)```### Making a Asyncio Application Node ConcurrentIf your Node inherits from the `echostream_node.asyncio.Node` you can set the Node toprocess incoming `Message`s concurrently. There is no setting for the maximum number of tasks;a task is created per received `Message`.```pythonimport asynciofrom echostream_node import Messagefrom echostream_node.asyncio import Nodeclass MyExternalNode(Node):    def __init__(self) -&gt; None:        super().__init__(concurrent_processing=True)    async def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)```### Making a Lambda Node ConcurrentThe AWS Lambda platform does not support shared memory, and therefore will only support concurrencyvia threading. This will create a LambdaNode that uses an optimized (to your Lambda function's resources)`ThreadPoolExecutor` to concurrently process received `Message`s.```pythonfrom echostream_node import Messagefrom echostream_node.threading import LambdaNodeclass MyExternalNode(LambdaNode):    def __init__(self) -&gt; None:        super().__init__(concurrent_processing=True)    def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)```## Lambda Nodes and Partial Success ReportingWhen you connect an Edge's SQS Queue to the AWS Lambda function implementing yourLambda Node, you can choose to Report Batch Item Failures. This allows your Lambda Nodeto report partial success back to the SQS Queue, but it does require that your Lambda Nodeoperate differently.If you wish to take advantage of this, set `report_batch_item_failures` when you create yourLambda Node. This can be set even if your Node is *not* concurrent processing.```pythonfrom echostream_node import Messagefrom echostream_node.threading import LambdaNodeclass MyExternalNode(LambdaNode):    def __init__(self) -&gt; None:        super().__init__(report_batch_item_failures=True)    def handle_received_message(self, *, message: Message, source: str) -&gt; None:        print(f&quot;Got a message:\n{message.body}&quot;)        self.audit_message(message, source=source)```Full documentation may be found at https://docs.echostream-node.echo.stream.</longdescription>
</pkgmetadata>