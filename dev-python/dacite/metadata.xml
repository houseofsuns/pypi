<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![](https://user-images.githubusercontent.com/1078369/212840759-174c0f2b-d446-4c3a-b97c-67a0b912e7f6.png)# dacite[![Build Status](https://travis-ci.org/konradhalas/dacite.svg?branch=master)](https://travis-ci.org/konradhalas/dacite)[![Coverage Status](https://coveralls.io/repos/github/konradhalas/dacite/badge.svg?branch=master)](https://coveralls.io/github/konradhalas/dacite?branch=master)[![License](https://img.shields.io/pypi/l/dacite.svg)](https://pypi.python.org/pypi/dacite/)[![Version](https://img.shields.io/pypi/v/dacite.svg)](https://pypi.python.org/pypi/dacite/)[![Python versions](https://img.shields.io/pypi/pyversions/dacite.svg)](https://pypi.python.org/pypi/dacite/)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)This module simplifies creation of data classes ([PEP 557][pep-557])from dictionaries.## InstallationTo install dacite, simply use `pip`:```$ pip install dacite```## RequirementsMinimum Python version supported by `dacite` is 3.6.## Quick start```pythonfrom dataclasses import dataclassfrom dacite import from_dict@dataclassclass User:    name: str    age: int    is_active: booldata = {    'name': 'John',    'age': 30,    'is_active': True,}user = from_dict(data_class=User, data=data)assert user == User(name='John', age=30, is_active=True)```## FeaturesDacite supports following features:- nested structures- (basic) types checking- optional fields (i.e. `typing.Optional`)- unions- forward references- collections- custom type hooks## MotivationPassing plain dictionaries as a data container between your functions ormethods isn't a good practice. Of course you can always create yourcustom class instead, but this solution is an overkill if you only wantto merge a few fields within a single object.Fortunately Python has a good solution to this problem - data classes.Thanks to `@dataclass` decorator you can easily create a new customtype with a list of given fields in a declarative manner. Data classessupport type hints by design.However, even if you are using data classes, you have to create theirinstances somehow. In many such cases, your input is a dictionary - itcan be a payload from a HTTP request or a raw data from a database. Ifyou want to convert those dictionaries into data classes, `dacite` isyour best friend.This library was originally created to simplify creation of type hinteddata transfer objects (DTO) which can cross the boundaries in theapplication architecture.It's important to mention that `dacite` is not a data validation library.There are dozens of awesome data validation projects and it doesn't makesense to duplicate this functionality within `dacite`. If you want to validate your data first, you should combine `dacite` with one of data validation library.Please check [Use Case](#use-case) section for a real-life example.## UsageDacite is based on a single function - `dacite.from_dict`. This functiontakes 3 parameters:- `data_class` - data class type- `data` - dictionary of input data- `config` (optional) - configuration of the creation process, instanceof `dacite.Config` classConfiguration is a (data) class with following fields:- `type_hooks`- `cast`- `forward_references`- `check_types`- `strict`- `strict_unions_match`The examples below show all features of `from_dict` function and usageof all `Config` parameters.### Nested structuresYou can pass a data with nested dictionaries and it will create a properresult.```python@dataclassclass A:    x: str    y: int@dataclassclass B:    a: Adata = {    'a': {        'x': 'test',        'y': 1,    }}result = from_dict(data_class=B, data=data)assert result == B(a=A(x='test', y=1))```### Optional fieldsWhenever your data class has a `Optional` field and you will not provideinput data for this field, it will take the `None` value.```pythonfrom typing import Optional@dataclassclass A:    x: str    y: Optional[int]data = {    'x': 'test',}result = from_dict(data_class=A, data=data)assert result == A(x='test', y=None)```### UnionsIf your field can accept multiple types, you should use `Union`. Dacitewill try to match data with provided types one by one. If none willmatch, it will raise `UnionMatchError` exception.```pythonfrom typing import Union@dataclassclass A:    x: str@dataclassclass B:    y: int@dataclassclass C:    u: Union[A, B]data = {    'u': {        'y': 1,    },}result = from_dict(data_class=C, data=data)assert result == C(u=B(y=1))```### CollectionsDacite supports fields defined as collections. It works for both - basictypes and data classes.```python@dataclassclass A:    x: str    y: int@dataclassclass B:    a_list: List[A]data = {    'a_list': [        {            'x': 'test1',            'y': 1,        },        {            'x': 'test2',            'y': 2,        }    ],}result = from_dict(data_class=B, data=data)assert result == B(a_list=[A(x='test1', y=1), A(x='test2', y=2)])```### Type hooksYou can use `Config.type_hooks` argument if you want to transform the input data of a data class field with given type into the new value. You have to pass a following mapping: `{Type: callable}`, where `callable` is a `Callable[[Any], Any]`.```python@dataclassclass A:    x: strdata = {    'x': 'TEST',}result = from_dict(data_class=A, data=data, config=Config(type_hooks={str: str.lower}))assert result == A(x='test')```If a data class field type is a `Optional[T]` you can pass both - `Optional[T]` or just `T` - as a key in `type_hooks`. The same with generic collections, e.g. when a field has type `List[T]` you can use `List[T]` to transform whole collection or `T` to transform each item. ### CastingIt's a very common case that you want to create an instance of a field type from the input data with just calling your type with the input value. Of course you can use `type_hooks={T: T}` to achieve this goal but `cast=[T]` is an easier and more expressive way. It also works with base classes - if `T` is a base class of type `S`, all fields of type `S` will be also &quot;casted&quot;.```pythonfrom enum import Enumclass E(Enum):    X = 'x'    Y = 'y'    Z = 'z'@dataclassclass A:    e: Edata = {    'e': 'x',}result = from_dict(data_class=A, data=data, config=Config(cast=[E]))# orresult = from_dict(data_class=A, data=data, config=Config(cast=[Enum]))assert result == A(e=E.X)```### Forward ReferencesDefinition of forward references can be passed as a `{'name': Type}` mapping to `Config.forward_references`. This dict is passed to `typing.get_type_hints()` as the `globalns` param when evaluating each field's type.```python@dataclassclass X:    y: &quot;Y&quot;@dataclassclass Y:    s: strdata = from_dict(X, {&quot;y&quot;: {&quot;s&quot;: &quot;text&quot;}}, Config(forward_references={&quot;Y&quot;: Y}))assert data == X(Y(&quot;text&quot;))```### Types checkingThere are rare cases when `dacite` built-in type checker can not validate your types (e.g. custom generic class) or you have such functionality covered by other library and you don't want to validate your types twice. In such case you can disable type checking with `Config(check_types=False)`.By default types checking is enabled.```pythonT = TypeVar('T')class X(Generic[T]):    pass@dataclassclass A:    x: X[str]x = X[str]()assert from_dict(A, {'x': x}, config=Config(check_types=False)) == A(x=x)```### Strict modeBy default `from_dict` ignores additional keys (not matching data class field) in the input data. If you want change this behaviour set `Config.strict` to `True`. In case of unexpected key `from_dict` will raise `UnexpectedDataError` exception.### Strict unions match`Union` allows to define multiple possible types for a given field. By default `dacite` is trying to find the first matching type for a provided data and it returns instance of this type. It means that it's possible that there are other matching types further on the `Union` types list. With `strict_unions_match` only a single match is allowed, otherwise `dacite` raises `StrictUnionMatchError`.## ExceptionsWhenever something goes wrong, `from_dict` will raise adequateexception. There are a few of them:- `WrongTypeError` - raised when a type of a input value does not matchwith a type of a data class field- `MissingValueError` - raised when you don't provide a value for arequired field- `UnionMatchError` - raised when provided data does not match any typeof `Union`- `ForwardReferenceError` - raised when undefined forward reference encountered indataclass- `UnexpectedDataError` - raised when `strict` mode is enabled and the input data has not matching keys- `StrictUnionMatchError` - raised when `strict_unions_match` mode is enabled and the input data has ambiguous `Union` match## DevelopmentFirst of all - if you want to submit your pull request, thank you very much! I really appreciate your support.Please remember that every new feature, bug fix or improvement should be tested. 100% code coverage is a must-have. We are using a few static code analysis tools to increase the code quality (`black`, `mypy`, `pylint`). Please make sure that you are not generating any errors/warnings before you submit your PR. You can find current configurationin `.github/*` directory.Last but not least, if you want to introduce new feature, please discuss it first within an issue.### How to startClone `dacite` repository:```$ git clone git@github.com:konradhalas/dacite.git```Create and activate virtualenv in the way you like:```$ python3 -m venv dacite-env$ source dacite-env/bin/activate```Install all `dacite` dependencies:```$ pip install -e .[dev]```And, optionally but recommended, install pre-commit hook for black:```$ pre-commit install```To run tests you just have to fire:```$ pytest```### Performance testing`dacite` is a small library, but its use is potentially very extensive. Thus, it is crucialto ensure good performance of the library.We achieve that with the help of `pytest-benchmark` library, and a suite of dedicated performance testswhich can be found in the `tests/performance` directory. The CI process runs these tests automatically,but they can also be helpful locally, while developing the library.Whenever you run `pytest` command, a new benchmark report is saved to `/.benchmarks` directory.You can easily compare these reports by running: `pytest-benchmark compare`, which will load all the runsand display them in a table, where you can compare the performance of each run.You can even specify which particular runs you want to compare, e.g. `pytest-benchmark compare 0001 0003 0005`. ## Use caseThere are many cases when we receive &quot;raw&quot; data (Python dicts) as a input to our system. HTTP request payload is a very common use case. In most web frameworks we receive request data as a simple dictionary. Instead of passing this dict down to your &quot;business&quot; code, it's a good idea to create something more &quot;robust&quot;.Following example is a simple `flask` app - it has single `/products` endpoint.You can use this endpoint to &quot;create&quot; product in your system. Our core `create_product` function expects data class as a parameter. Thanks to `dacite` we can easily build such data class from `POST` request payload.```pythonfrom dataclasses import dataclassfrom typing import Listfrom flask import Flask, request, Responseimport daciteapp = Flask(__name__)@dataclassclass ProductVariantData:    code: str    description: str = ''    stock: int = 0@dataclassclass ProductData:    name: str    price: float    variants: List[ProductVariantData]def create_product(product_data: ProductData) -&gt; None:    pass  # your business logic here@app.route(&quot;/products&quot;, methods=['POST'])def products():    product_data = dacite.from_dict(        data_class=ProductData,        data=request.get_json(),    )    create_product(product_data=product_data)    return Response(status=201)```What if we want to validate our data (e.g. check if `code` has 6 characters)? Such features are out of scope of `dacite` but we can easily combine it with one of data validation library. Let's try with [marshmallow](https://marshmallow.readthedocs.io).First of all we have to define our data validation schemas:```pythonfrom marshmallow import Schema, fields, ValidationErrordef validate_code(code):    if len(code) != 6:        raise ValidationError('Code must have 6 characters.')class ProductVariantDataSchema(Schema):    code = fields.Str(required=True, validate=validate_code)    description = fields.Str(required=False)    stock = fields.Int(required=False)class ProductDataSchema(Schema):    name = fields.Str(required=True)    price = fields.Decimal(required=True)    variants = fields.Nested(ProductVariantDataSchema(many=True))```And use them within our endpoint:```python@app.route(&quot;/products&quot;, methods=['POST'])def products():    schema = ProductDataSchema()    result, errors = schema.load(request.get_json())    if errors:        return Response(            response=json.dumps(errors),             status=400,             mimetype='application/json',        )    product_data = dacite.from_dict(        data_class=ProductData,        data=result,    )    create_product(product_data=product_data)    return Response(status=201)```Still `dacite` helps us to create data class from &quot;raw&quot; dict with validated data.### Cache`dacite` uses some LRU caching to improve its performance where possible. To use the caching utility:```pythonfrom dacite import set_cache_size, get_cache_size, clear_cacheget_cache_size()  # outputs the current LRU max_size, default is 2048set_cache_size(4096)  # set LRU max_size to 4096set_cache_size(None)  # set LRU max_size to Noneclear_cache()  # Clear the cache```The caching is completely transparent from the interface perspective.## ChangelogFollow `dacite` updates in [CHANGELOG][changelog].## AuthorsCreated by [Konrad Ha≈Ças][halas-homepage].[pep-557]: https://www.python.org/dev/peps/pep-0557/[halas-homepage]: https://konradhalas.pl[changelog]: https://github.com/konradhalas/dacite/blob/master/CHANGELOG.md</longdescription>
</pkgmetadata>