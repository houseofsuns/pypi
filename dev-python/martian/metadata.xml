<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>*******Martian*******.. image:: https://github.com/zopefoundation/martian/actions/workflows/tests.yml/badge.svg        :target: https://github.com/zopefoundation/martian/actions/workflows/tests.yml.. image:: https://img.shields.io/pypi/v/martian.svg        :target: https://pypi.python.org/pypi/martian        :alt: PyPI.. image:: https://img.shields.io/pypi/pyversions/martian.svg        :target: https://pypi.python.org/pypi/martian        :alt: Python versionsA library to grok configuration from Python code.Martian tutorial****************Introduction============&quot;There was so much to grok, so little to grok from.&quot; -- Stranger in aStrange Land, by Robert A. HeinleinMartian provides infrastructure for declarative configuration ofPython code. Martian is especially useful for the construction offrameworks that need to provide a flexible plugininfrastructure. Martian doesn't actually provide infrastructure forplugin registries (except for itself). Many frameworks have their ownsystems for this, and if you need a generic one, you might want toconsider ``zope.component``. Martian just allows you to make theregistration of plugins less verbose.You can see Martian as doing something that you can also solve withmetaclasses, with the following advantages:* the developer of the framework doesn't have to write a lot of ad-hoc  metaclasses anymore; instead we offer an infrastructure to make life  easier.* configuration doesn't need to happen at import time, but can happen at  program startup time. This also makes configuration more tractable for  a developer.* we don't bother the developer that *uses* the framework with the  surprising behavior that metaclasses sometimes bring. The classes  the user has to deal with are normal classes.Why is this package named ``martian``? In the novel &quot;Stranger in aStrange Land&quot;, the verb *grok* is introduced:  Grok means to understand so thoroughly that the observer becomes a  part of the observed -- to merge, blend, intermarry, lose identity  in group experience.In the context of this package, &quot;grokking&quot; stands for the process ofdeducing declarative configuration actions from Python code. In thenovel, grokking is originally a concept that comes from the planetMars. Martians *grok*. Since this package helps you grok code, it'scalled Martian.Martian provides a framework that allows configuration to be expressedin declarative Python code. These declarations can often be deducedfrom the structure of the code itself. The idea is to make thesedeclarations so minimal and easy to read that even extensiveconfiguration does not overly burden the programmers working with thecode.The ``martian`` package is a spin-off from the `Grok project`_, in thecontext of which this codebase was first developed. While Grok usesit, the code is completely independent of Grok... _`Grok project`: http://grok.zope.orgMotivation==========&quot;Deducing declarative configuration actions from Python code&quot; - thatsounds very abstract. What does it actually mean? What isconfiguration?  What is declarative configuration? In order to explainthis, we'll first take a look at configuration.Larger frameworks often offer a lot of points where you can modifytheir behavior: ways to combine its own components with components youprovide yourself to build a larger application. A framework offerspoints where it can be *configured* with plugin code. When you plugsome code into a plugin point, it results in the updating of someregistry somewhere with the new plugin. When the framework uses aplugin, it will first look it up in the registry. The action ofregistering some component into a registry can be called*configuration*.Let's look at an example framework that offers a plugin point. Weintroduce a very simple framework for plugging in different templatelanguages, where each template language uses its own extension. Youcan then supply the framework with the template body and the templateextension and some data, and render the template.Let's look at the framework::  &gt;&gt;&gt; import string  &gt;&gt;&gt; class templating(FakeModule):  ...  ...   class InterpolationTemplate(object):  ...      &quot;Use %(foo)s for dictionary interpolation.&quot;  ...      def __init__(self, text):  ...          self.text = text  ...      def render(self, **kw):  ...          return self.text % kw  ...  ...   class TemplateStringTemplate(object):  ...      &quot;PEP 292 string substitutions.&quot;  ...      def __init__(self, text):  ...          self.template = string.Template(text)  ...      def render(self, **kw):  ...          return self.template.substitute(**kw)  ...  ...   # the registry, we plug in the two templating systems right away  ...   extension_handlers = { '.txt': InterpolationTemplate,  ...                          '.tmpl': TemplateStringTemplate }  ...  ...   def render(data, extension, **kw):  ...      &quot;&quot;&quot;Render the template at filepath with arguments.  ...  ...      data - the data in the file  ...      extension - the extension of the file  ...      keyword arguments - variables to interpolate  ...  ...      In a real framework you could pass in the file path instead of  ...      data and extension, but we don't want to open files in our  ...      example.  ...  ...      Returns the rendered template  ...      &quot;&quot;&quot;  ...      template = extension_handlers[extension](data)  ...      return template.render(**kw)Since normally we cannot create modules in a doctest, we have emulatedthe ``templating`` Python module using the ``FakeModule``class. Whenever you see ``FakeModule`` subclasses, imagine you'relooking at a module definition in a ``.py`` file. Now that we havedefined a module ``templating``, we also need to be able to importit. Fake modules are always placed automatically into the``martiantest.fake`` namespace so you can import them from there::  &gt;&gt;&gt; from martiantest.fake import templatingNow let's try the ``render`` function for the registered templatetypes, to demonstrate that our framework works::  &gt;&gt;&gt; templating.render('Hello %(name)s!', '.txt', name=&quot;world&quot;)  'Hello world!'  &gt;&gt;&gt; templating.render('Hello ${name}!', '.tmpl', name=&quot;universe&quot;)  'Hello universe!'File extensions that we do not recognize cause a ``KeyError`` to beraised::  &gt;&gt;&gt; templating.render('Hello', '.silly', name=&quot;test&quot;)  Traceback (most recent call last):  ...  KeyError: '.silly'We now want to plug into this filehandler framework and provide ahandler for ``.silly`` files. Since we are writing a plugin, we cannotchange the ``templating`` module directly. Let's write an extensionmodule instead::  &gt;&gt;&gt; class sillytemplating(FakeModule):  ...   class SillyTemplate(object):  ...      &quot;Replace {key} with dictionary values.&quot;  ...      def __init__(self, text):  ...          self.text = text  ...      def render(self, **kw):  ...          text = self.text  ...          for key, value in kw.items():  ...              text = text.replace('{%s}' % key, value)  ...          return text  ...  ...   templating.extension_handlers['.silly'] = SillyTemplate  &gt;&gt;&gt; from martiantest.fake import sillytemplatingIn the extension module, we manipulate the ``extension_handlers``dictionary of the ``templating`` module (in normal code we'd need toimport it first), and plug in our own function. ``.silly`` handlingworks now::  &gt;&gt;&gt; templating.render('Hello {name}!', '.silly', name=&quot;galaxy&quot;)  'Hello galaxy!'Above we plug into our ``extension_handler`` registry using Pythoncode. Using separate code to manually hook components into registriescan get rather cumbersome - each time you write a plugin, you alsoneed to remember you need to register it.Doing template registration in Python code also poses a maintenancerisk. It is tempting to start doing fancy things in Python code suchas conditional configuration, making the configuration state of aprogram hard to understand. Another problem is that doingconfiguration at import time can also lead to unwanted side effectsduring import, as well as ordering problems, where you want to importsomething that really needs configuration state in another module thatis imported later. Finally, it can also make code harder to test, asconfiguration is loaded always when you import the module, even if inyour test perhaps you don't want it to be.Martian provides a framework that allows configuration to be expressedin declarative Python code. Martian is based on the realization thatwhat to configure where can often be deduced from the structure ofPython code itself, especially when it can be annotated withadditional declarations. The idea is to make it so easy to write andregister a plugin so that even extensive configuration does not overlyburden the developer.Configuration actions are executed during a separate phase (&quot;groktime&quot;), not at import time, which makes it easier to reason about andeasier to test.Configuration the Martian Way=============================Let's now transform the above ``templating`` module and the``sillytemplating`` module to use Martian. First we must recognizethat every template language is configured to work for a particularextension. With Martian, we annotate the classes themselves with thisconfiguration information. Annotations happen using *directives*,which look like function calls in the class body.Let's create an ``extension`` directive that can take a single stringas an argument, the file extension to register the template classfor::  &gt;&gt;&gt; import martian  &gt;&gt;&gt; class extension(martian.Directive):  ...   scope = martian.CLASS  ...   store = martian.ONCE  ...   default = NoneWe also need a way to easily recognize all template classes. The normalpattern for this in Martian is to use a base class, so let's define a``Template`` base class::  &gt;&gt;&gt; class Template(object):  ...   passWe now have enough infrastructure to allow us to change the code to useMartian style base class and annotations::  &gt;&gt;&gt; class templating(FakeModule):  ...  ...   class InterpolationTemplate(Template):  ...      &quot;Use %(foo)s for dictionary interpolation.&quot;  ...      extension('.txt')  ...      def __init__(self, text):  ...          self.text = text  ...      def render(self, **kw):  ...          return self.text % kw  ...  ...   class TemplateStringTemplate(Template):  ...      &quot;PEP 292 string substitutions.&quot;  ...      extension('.tmpl')  ...      def __init__(self, text):  ...          self.template = string.Template(text)  ...      def render(self, **kw):  ...          return self.template.substitute(**kw)  ...  ...   # the registry, empty to start with  ...   extension_handlers = {}  ...  ...   def render(data, extension, **kw):  ...      # this hasn't changed  ...      template = extension_handlers[extension](data)  ...      return template.render(**kw)  &gt;&gt;&gt; from martiantest.fake import templatingAs you can see, there have been very few changes:* we made the template classes inherit from ``Template``.* we use the ``extension`` directive in the template classes.* we stopped pre-filling the ``extension_handlers`` dictionary.So how do we fill the ``extension_handlers`` dictionary with the righttemplate languages? Now we can use Martian. We define a *grokker* for``Template`` that registers the template classes in the``extension_handlers`` registry::  &gt;&gt;&gt; class meta(FakeModule):  ...   class TemplateGrokker(martian.ClassGrokker):  ...     martian.component(Template)  ...     martian.directive(extension)  ...     def execute(self, class_, extension, **kw):  ...       templating.extension_handlers[extension] = class_  ...       return True  &gt;&gt;&gt; from martiantest.fake import metaWhat does this do? A ``ClassGrokker`` has its ``execute`` methodcalled for subclasses of what's indicated by the ``martian.component``directive. You can also declare what directives a ``ClassGrokker``expects on this component by using ``martian.directive()`` (the``directive`` directive!) one or more times.The ``execute`` method takes the class to be grokked as the firstargument, and the values of the directives used will be passed in asadditional parameters into the ``execute`` method. The framework canalso pass along an arbitrary number of extra keyword arguments duringthe grokking process, so we need to declare ``**kw`` to make sure wecan handle these.All our grokkers will be collected in a special Martian-specificregistry::  &gt;&gt;&gt; reg = martian.GrokkerRegistry()We will need to make sure the system is aware of the``TemplateGrokker`` defined in the ``meta`` module first, so let'sregister it first. We can do this by simply grokking the ``meta``module::  &gt;&gt;&gt; reg.grok('meta', meta)  TrueBecause ``TemplateGrokker`` is now registered, our registry now knowshow to grok ``Template`` subclasses. Let's grok the ``templating``module::  &gt;&gt;&gt; reg.grok('templating', templating)  TrueLet's try the ``render`` function of templating again, to demonstratewe have successfully grokked the template classes::  &gt;&gt;&gt; templating.render('Hello %(name)s!', '.txt', name=&quot;world&quot;)  'Hello world!'  &gt;&gt;&gt; templating.render('Hello ${name}!', '.tmpl', name=&quot;universe&quot;)  'Hello universe!'``.silly`` hasn't been registered yet::  &gt;&gt;&gt; templating.render('Hello', '.silly', name=&quot;test&quot;)  Traceback (most recent call last):  ...  KeyError: '.silly'Let's now register ``.silly`` from an extension module::  &gt;&gt;&gt; class sillytemplating(FakeModule):  ...   class SillyTemplate(Template):  ...      &quot;Replace {key} with dictionary values.&quot;  ...      extension('.silly')  ...      def __init__(self, text):  ...          self.text = text  ...      def render(self, **kw):  ...          text = self.text  ...          for key, value in kw.items():  ...              text = text.replace('{%s}' % key, value)  ...          return text  &gt;&gt;&gt; from martiantest.fake import sillytemplatingAs you can see, the developer that uses the framework has no needanymore to know about ``templating.extension_handlers``. Instead we cansimply grok the module to have ``SillyTemplate`` be register appropriately::  &gt;&gt;&gt; reg.grok('sillytemplating', sillytemplating)  TrueWe can now use the ``.silly`` templating engine too::  &gt;&gt;&gt; templating.render('Hello {name}!', '.silly', name=&quot;galaxy&quot;)  'Hello galaxy!'Admittedly it is hard to demonstrate Martian well with a small examplelike this. In the end we have actually written more code than in thebasic framework, after all. But even in this small example, the``templating`` and ``sillytemplating`` module have become moredeclarative in nature. The developer that uses the framework will notneed to know anymore about things like``templating.extension_handlers`` or an API to register thingsthere. Instead the developer can registering a new template systemanywhere, as long as he subclasses from ``Template``, and as long ashis code is grokked by the system.Finally note how Martian was used to define the ``TemplateGrokker`` aswell. In this way Martian can use itself to extend itself.Grokking instances==================Above we've seen how you can grok classes. Martian also supplies a wayto grok instances. This is less common in typical frameworks, and hasthe drawback that no class-level directives can be used, but can stillbe useful.Let's imagine a case where we have a zoo framework with an ``Animal``class, and we want to track instances of it::  &gt;&gt;&gt; class Animal(object):  ...   def __init__(self, name):  ...     self.name = name  &gt;&gt;&gt; class zoo(FakeModule):  ...   horse = Animal('horse')  ...   chicken = Animal('chicken')  ...   elephant = Animal('elephant')  ...   lion = Animal('lion')  ...   animals = {}  &gt;&gt;&gt; from martiantest.fake import zooWe define an ``InstanceGrokker`` subclass to grok ``Animal`` instances::  &gt;&gt;&gt; class meta(FakeModule):  ...   class AnimalGrokker(martian.InstanceGrokker):  ...     martian.component(Animal)  ...     def execute(self, instance, **kw):  ...       zoo.animals[instance.name] = instance  ...       return True  &gt;&gt;&gt; from martiantest.fake import metaLet's create a new registry with the ``AnimalGrokker`` in it::  &gt;&gt;&gt; reg = martian.GrokkerRegistry()  &gt;&gt;&gt; reg.grok('meta', meta)  TrueWe can now grok the ``zoo`` module::  &gt;&gt;&gt; reg.grok('zoo', zoo)  TrueThe animals will now be in the ``animals`` dictionary::  &gt;&gt;&gt; sorted(zoo.animals.items())  [('chicken', &lt;Animal object at ...&gt;),   ('elephant', &lt;Animal object at ...&gt;),   ('horse', &lt;Animal object at ...&gt;),   ('lion', &lt;Animal object at ...&gt;)]More information================For many more details and examples of more kinds of grokkers, pleasesee ``src/martian/core.txt``. For more information on directives see``src/martian/directive.txt``.CHANGES*******2.0.post1 (2023-03-23)======================- Add missing ``python_requires`` in ``setup.py`` to prevent installing on too  old versions.2.0 (2023-03-23)================- Add support for Python 3.11.- Drop support for Python 2.7, 3.5, 3.6.- Fix test suite incompatibility with ``zope.interface &gt;= 6.0``.1.5 (2022-02-11)================- Title directive now correctly handles non-ascii characters.- Fix test suite incompatibility with zope.interface &gt;= 5.0.- Drop support for Python 3.4.- Add support for Python 3.9 and 3.10.1.4 (2020-02-23)================- Check for ``builtins`` (Python 3) everywhere that we check for  ``__builtin__`` (Python 2).1.3.post1 (2019-03-14)======================- Fix rendering of PyPI page.1.3 (2019-03-14)================- Add support for Python 3.7 and 3.8.1.2 (2018-05-09)================- Add a new directive ``martian.ignore()`` to explicitly not grok  something in a module::    class Example:        pass    martian.ignore('Example')- Fix the code to be pep 8 compliant.1.1 (2018-01-25)================- Bypass bootstrap, add coverage to tox- Fix ``inspect.getargspec()`` deprecation in python31.0 (2017-10-19)================- Add support for Python 3.5, 3.6, PyPy2 and PyPy3.- Drop support for Python 2.6 and 3.3.0.15 (2015-04-21)=================- compatibility for python 3- adjust egg to work with newer version of setuptools- Fix an encoding issue under Python-2.7 in the doctests.0.14 (2010-11-03)=================Feature changes---------------* The computation of the default value for a directive can now be defined inside  the directive class definition. Whenever there is a ``get_default``  classmethod, it is used for computing the default::      class name(Directive):          scope = CLASS          store = ONCE          @classmethod          def get_default(cls, component, module=None, **data):             return component.__name__.lower()  When binding the directive, the default-default behaviour can still be  overriden by passing a ``get_default`` function::      def another_default(component, module=None, **data):         return component.__name__.lower()      name.bind(get_default=another_default).get(some_component)  Making the default behaviour intrinsic to the directive, prevents having to  pass the ``get_default`` function over and over when getting values, for  example in the grokkers.0.13 (2010-11-01)=================Feature changes---------------* Ignore all __main__ modules.* List zope.testing as a test dependency.0.12 (2009-06-29)=================Feature changes---------------* Changes to better support various inheritance scenarios in combination with  directives. Details follow.* ``CLASS_OR_MODULE`` scope directives will be aware of inheritance of  values that are defined in module-scope. Consider the following case::    module a:      some_directive('A')      class Foo(object):        pass    module b:      import a      class Bar(a.Foo):        pass  As before, ``Foo`` will have the value ``A`` configured for it. ``Bar``,  since it inherits from ``Foo``, will inherit this value.* ``CLASS_OR_MODULE`` and ``CLASS`` scope directives will be aware of  inheritance of computed default values. Consider the following case::    module a:      class Foo(object):         pass    module b:      import a      class Bar(a.Foo):         pass    def get_default(component, module, **data):        if module.__name__ == 'a':           return &quot;we have a default value for module a&quot;        return martian.UNKNOWN  When we now do this::    some_directive.bind(get_default=get_default).get(b.Bar)  We will get the value &quot;we have a default value for module a&quot;. This  is because when trying to compute the default value for ``Bar`` we  returned ``martian.UNKNOWN`` to indicate the value couldn't be found  yet. The system then looks at the base class and tries again, and in  this case it succeeds (as the module-name is ``a``).* ``martian.ONCE_IFACE`` storage option to allow the creation of  directives that store their value on ``zope.interface``  interfaces. This was originally in ``grokcore.view`` but was of  wider usefulness.Bugs fixed----------* Ignore things that look like Python modules and packages but aren't.  These are sometimes created by editors, operating systems and  network file systems and we don't want to confuse them.* Ignore .pyc and .pyo files that don't have a matching .py file via  ``module_info_from_dotted_name`` if its ``ignore_nonsource``  parameter is ``True``.  The default is ``True``.  To revert to the  older behavior where .pyc files were honored, pass  ``ignore_nonsource=False``.* Pass along ``exclude_filter`` (and the new ``ignore_nonsource``  flag) to ModuleInfo constructor when it calls itself recursively.* Replace ``fake_import`` to import fake modules in tests with a real  python import statement (``from martiantest.fake import  my_fake_module``). This works by introducing a metaclass for  ``FakeModule`` that automatically registers it as a module. The  irony does not escape us. This also means that  ``martian.scan.resolve()`` will now work on fake modules.0.11 (2008-09-24)=================Feature changes---------------* Added MULTIPLE_NOBASE option for directive store. This is like MULTIPLE  but doesn't inherit information from the base class.0.10 (2008-06-06)=================Feature changes---------------* Add a ``validateClass`` validate function for directives.* Moved ``FakeModule`` and ``fake_import`` into a ``martian.testing``  module so that they can be reused by external packages.* Introduce new tutorial text as README.txt. The text previously in  ``README.txt`` was rather too detailed for a tutorial, so has been  moved into ``core.txt``.* Introduce a ``GrokkerRegistry`` class that is a ``ModuleGrokker``  with a ``MetaMultiGrokker`` in it. This is the convenient thing to  instantiate to start working with Grok and is demonstrated in the  tutorial.* Introduced three new martian-specific directives:  ``martian.component``, ``martian.directive`` and  ``martian.priority``. These replace the ``component_class``,  ``directives`` and ``priority`` class-level attributes. This way  Grokkers look the same as what they grok. This breaks backwards  compatibility again, but it's an easy replace operation. Note that  ``martian.directive`` takes the directive itself as an argument, and  then optionally the same arguments as the ``bind`` method of  directives (``name``, ``default`` and ``get_default``). It may be  used multiple times. Note that ``martian.baseclass`` was already a  Martian-specific directive and this has been unchanged.* For symmetry, add an ``execute`` method to ``InstanceGrokker``.0.9.7 (2008-05-29)==================Feature changes---------------* Added a ``MethodGrokker`` base class for grokkers that want to grok  methods of a class rather than the whole class itself.  It works  quite similar to the ``ClassGrokker`` regarding directive  definition, except that directives evaluated not only on class (and  possibly module) level but also for each method.  That way,  directives can also be applied to methods (as decorators) in case  they support it.0.9.6 (2008-05-14)==================Feature changes---------------* Refactored the ``martian.Directive`` base class yet again to allow  more declarative (rather than imperative) usage in grokkers.  Directives themselves no longer have a ``get()`` method nor a  default value factory (``get_default()``).  Instead you will have to  &quot;bind&quot; the directive first which is typically done in a grokker.* Extended the ``ClassGrokker`` baseclass with a standard ``grok()``  method that allows you to simply declare a set of directives that  are used on the grokked classes.  Then you just have to implement an  ``execute()`` method that will receive the data from those  directives as keyword arguments.  This simplifies the implementation  of class grokkers a lot.0.9.5 (2008-05-04)==================* ``scan_for_classes`` just needs a single second argument specifying  an interface. The support for scanning for subclasses directly has  been removed as it became unnecessary (due to changes in  grokcore.component).0.9.4 (2008-05-04)==================Features changes----------------* Replaced the various directive base classes with a single  ``martian.Directive`` base class:  - The directive scope is now defined with the ``scope`` class    attribute using one of ``martian.CLASS``, ``martian.MODULE``,    ``martian.CLASS_OR_MODULE``.  - The type of storage is defined with the ``store`` class attribute    using one of ``martian.ONCE``, ``martian.MULTIPLE``,    ``martian.DICT``.  - Directives have now gained the ability to read the value that they    have set on a component or module using a ``get()`` method.  The    ``class_annotation`` and ``class_annotation_list`` helpers have    been removed as a consequence.* Moved the ``baseclass()`` directive from Grok to Martian.* Added a ``martian.util.check_provides_one`` helper, in analogy to  ``check_implements_one``.* The ``scan_for_classes`` helper now also accepts an ``interface``  argument which allows you to scan for classes based on interface  rather than base classes.Bug fixes---------* added dummy ``package_dotted_name`` to ``BuiltinModuleInfo``. This  allows the grokking of views in test code using Grok's  ``grok.testing.grok_component`` without a failure when it sets up the  ``static`` attribute.* no longer use the convention that classes ending in -Base will be considered  base classes. You must now explicitly use the grok.baseclass() directive.* The type check of classes uses isinstance() instead of type(). This means  Grok can work with Zope 2 ExtensionClasses and metaclass programming.0.9.3 (2008-01-26)==================Feature changes---------------* Added an OptionalValueDirective which allows the construction of  directives that take either zero or one argument. If no arguments  are given, the ``default_value`` method on the directive is  called. Subclasses need to override this to return the default value  to use.Restructuring-------------* Move some util functions that were really grok-specific out of Martian  back into Grok.0.9.2 (2007-11-20)==================Bug fixes---------* scan.module_info_from_dotted_name() now has special behavior when it  runs into __builtin__. Previously, it would crash with an error. Now  it will return an instance of BuiltinModuleInfo. This is a very  simple implementation which provides just enough information to make  client code work. Typically this client code is test-related so that  the module context will be __builtin__.0.9.1 (2007-10-30)==================Feature changes---------------* Grokkers now receive a ``module_info`` keyword argument.  This  change is completely backwards-compatible since grokkers which don't  take ``module_info`` explicitly will absorb the extra argument in  ``**kw``.0.9 (2007-10-02)=================Feature changes---------------* Reverted the behaviour where modules called tests or ftests were skipped  by default and added an API to provides a filtering function for skipping  modules to be grokked.0.8.1 (2007-08-13)==================Feature changes---------------* Don't grok tests or ftests modules.Bugs fixed----------* Fix a bug where if a class had multiple base classes, this could end up  in the resultant list multiple times.0.8 (2007-07-02)================Feature changes---------------* Initial public release.</longdescription>
</pkgmetadata>