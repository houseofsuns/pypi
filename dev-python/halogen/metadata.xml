<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>halogen=======Python HAL generation/parsing library... image:: http://img.shields.io/pypi/v/halogen.svg   :target: https://pypi.python.org/pypi/halogen.. image:: http://img.shields.io/coveralls/paylogic/halogen/master.svg   :target: https://coveralls.io/r/paylogic/halogen.. image:: https://travis-ci.org/paylogic/halogen.svg?branch=master    :target: https://travis-ci.org/paylogic/halogen.. image:: https://readthedocs.org/projects/halogen/badge/?version=latest    :alt: Documentation Status    :scale: 100%    :target: https://readthedocs.org/projects/halogen/Halogen takes the advantage of the declarative style serialization with easily extendable schemas.Schema combines the knowledge about your data model, attribute mapping and advanced accessing, withcomplex types and data transformation.Library is purposed in representing your data in HAL format in the most obvious way possible, but alsoof the generic web form-like functionality so that your schemas and types can be reused as much as possible.Schema======Schema is the main building block of the serialization. It is also a type which means you can declare nestedstructures with schemas.Serialization-------------.. code-block:: python    &gt;&gt;&gt; Schema.serialize({&quot;hello&quot;: &quot;Hello World&quot;})    &gt;&gt;&gt; {&quot;hello&quot;: &quot;Hello World&quot;}Simply call Schema.serialize() class method which can accept dict or any other object.Validation----------There's no validation involved in the serialization. Your source data or your model is consideredto be clean since it is coming from the storage and it is not a user input. Of course exceptionsin the types or attribute accessors may occur but they are considered as programming errors.Serializing dict----------------Dictionary values are automatically accessed by the schema attributes using their names as keys:.. code-block:: python    import halogen    class Hello(halogen.Schema):        hello = halogen.Attr()    serialized = Hello.serialize({&quot;hello&quot;: &quot;Hello World&quot;})Result:.. code-block:: json    {        &quot;hello&quot;: &quot;Hello World&quot;    }HAL is just JSON, but according to it's specification it SHOULD have self link to identify theserialized resource. For this you should use HAL-specific attributes and configure the way the``self`` is composed.HAL example:.. code-block:: python    import halogen    from flask import url_for    spell = {        &quot;uid&quot;: &quot;abracadabra&quot;,        &quot;name&quot;: &quot;Abra Cadabra&quot;,        &quot;cost&quot;: 10,    }    class Spell(halogen.Schema):        self = halogen.Link(attr=lambda spell: url_for(&quot;spell.get&quot; uid=spell['uid']))        name = halogen.Attr()    serialized = Spell.serialize(spell)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;/spells/abracadabra&quot;}        },        &quot;name&quot;: &quot;Abra Cadabra&quot;    }Serializing objects-------------------Similar to dictionary keys the schema attributes can also access object properties:.. code-block:: python    import halogen    from flask import url_for    class Spell(object):        uid = &quot;abracadabra&quot;        name = &quot;Abra Cadabra&quot;        cost = 10    spell = Spell()    class SpellSchema(halogen.Schema):        self = halogen.Link(attr=lambda spell: url_for(&quot;spell.get&quot; uid=spell.uid))        name = halogen.Attr()    serialized = SpellSchema.serialize(spell)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;/spells/abracadabra&quot;}        },        &quot;name&quot;: &quot;Abra Cadabra&quot;    }Attribute---------Attributes form the schema and encapsulate the knowledge how to get the data from your model,how to transform it according to the specific type.Attr()~~~~~~The name of the attribute member in the schema is the name of the key the result will be serialized to.By default the same attribute name is used to access the source model.Example:.. code-block:: python    import halogen    from flask import url_for    class Spell(object):        uid = &quot;abracadabra&quot;        name = &quot;Abra Cadabra&quot;        cost = 10    spell = Spell()    class SpellSchema(halogen.Schema):        self = halogen.Link(attr=lambda spell: url_for(&quot;spell.get&quot; uid=spell.uid))        name = halogen.Attr()    serialized = SpellSchema.serialize(spell)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;/spells/abracadabra&quot;}        },        &quot;name&quot;: &quot;Abra Cadabra&quot;    }Attr(&quot;const&quot;)~~~~~~~~~~~~~In case the attribute represents a constant the value can be specified as a first parameter. This first parameteris a type of the attribute. If the type is not a instance or subclass of a ``halogen.types.Type`` it willbe bypassed... code-block:: python    import halogen    from flask import url_for    class Spell(object):        uid = &quot;abracadabra&quot;        name = &quot;Abra Cadabra&quot;        cost = 10    spell = Spell()    class SpellSchema(halogen.Schema):        self = halogen.Link(attr=lambda spell: url_for(&quot;spell.get&quot; uid=spell.uid))        name = halogen.Attr(&quot;custom name&quot;)    serialized = SpellSchema.serialize(spell)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;/spells/abracadabra&quot;}        },        &quot;name&quot;: &quot;custom name&quot;    }In some cases also the ``attr`` can be specified to be a callable that returns a constant value.Attr(attr=&quot;foo&quot;)~~~~~~~~~~~~~~~~In case the attribute name doesn't correspond your model you can override it:.. code-block:: python    import halogen    from flask import url_for    class Spell(object):        uid = &quot;abracadabra&quot;        title = &quot;Abra Cadabra&quot;        cost = 10    spell = Spell()    class SpellSchema(halogen.Schema):        self = halogen.Link(attr=lambda spell: url_for(&quot;spell.get&quot; uid=spell.uid))        name = halogen.Attr(attr=&quot;title&quot;)    serialized = SpellSchema.serialize(spell)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;/spells/abracadabra&quot;}        },        &quot;name&quot;: &quot;Abra Cadabra&quot;    }The ``attr`` parameter accepts strings of the source attribute name or even dot-separated path to the attribute.This works for both: nested dictionaries or related objects an Python properties... code-block:: python    import halogen    class SpellSchema(halogen.Schema):        name = halogen.Attr(attr=&quot;path.to.my.attribute&quot;)Attr(attr=lambda value: value)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The ``attr`` parameter accepts callables that take the entire source model and can access the neccessaryattribute. You can pass a function or lambda in order to return the desired value whichalso can be just a constant... code-block:: python    import halogen    from flask import url_for    class Spell(object):        uid = &quot;abracadabra&quot;        title = &quot;Abra Cadabra&quot;        cost = 10    spell = Spell()    class SpellSchema(halogen.Schema):        self = halogen.Link(attr=lambda spell: url_for(&quot;spell.get&quot; uid=spell.uid))        name = halogen.Attr(attr=lambda value: value.title)    serialized = SpellSchema.serialize(spell)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;/spells/abracadabra&quot;}        },        &quot;name&quot;: &quot;Abra Cadabra&quot;    }Attribute as a decorator~~~~~~~~~~~~~~~~~~~~~~~~Sometimes accessor functions are too big for lambdas. In this case it is possibleto decorate a method of the class to be a getter accessor... code-block:: python    import halogen    class ShoppingCartSchema(halogen.Schema):        @halogen.attr(AmountType(), default=None)        def total(obj):            return sum(                (item.amount for item in obj.items),                0,            )        @total.setter        def set_total(obj, value):            obj.total = valueAttr(attr=Acccessor)~~~~~~~~~~~~~~~~~~~~In case the schema is used for both directions to serialize and to deserialize the ``halogen.schema.Accessor``can be passed with both ``getter`` and ``setter`` specified.``Getter`` is a string or callable in order to get the value from a model, and ``setter`` is a string or callablethat knows where the deserialized value should be stored.Attr(Type())~~~~~~~~~~~~After the attibute gets the value it passes it to it's type in order to complete the serialization.Halogen provides basic types for example ``halogen.types.List`` to implement lists of values or schemas.Schema is also a Type and can be passed to the attribute to implement complex structures.Example:.. code-block:: python    import halogen    from flask import url_for    class Book(object):        uid = &quot;good-book-uid&quot;        title = &quot;Harry Potter and the Philosopher's Stone&quot;        genres = [            {&quot;uid&quot;: &quot;fantasy-literature&quot;, &quot;title&quot;: &quot;fantasy literature&quot;},            {&quot;uid&quot;: &quot;mystery&quot;, &quot;title&quot;: &quot;mystery&quot;},            {&quot;uid&quot;: &quot;adventure&quot;, &quot;title&quot;: &quot;adventure&quot;},        ]    book = Book()    class GenreSchema(halogen.Schema):        self = halogen.Link(attr=lambda genre: url_for(&quot;genre.get&quot; uid=genre['uid']))        title = halogen.Attr()    class BookSchema(halogen.Schema):        self = halogen.Link(attr=lambda book: url_for(&quot;book.get&quot; uid=book.uid))        title = halogen.Attr()        genres = halogen.Attr(halogen.types.List(GenreSchema))    serialized = BookSchema.serialize(book)Result:.. code-block:: json    {        &quot;_links&quot;: {            &quot;self&quot;: {&quot;href&quot;: &quot;good-book-uid&quot;}        },        &quot;genres&quot;: [            {&quot;_links&quot;: {&quot;self&quot;: {&quot;href&quot;: &quot;fantasy-literature&quot;}}, &quot;title&quot;: &quot;fantasy literature&quot;},            {&quot;_links&quot;: {&quot;self&quot;: {&quot;href&quot;: &quot;mystery&quot;}}, &quot;title&quot;: &quot;mystery&quot;},            {&quot;_links&quot;: {&quot;self&quot;: {&quot;href&quot;: &quot;adventure&quot;}}, &quot;title&quot;: &quot;adventure&quot;}        ],        &quot;title&quot;: &quot;Harry Potter and the Philosopher's Stone&quot;    }Attr(Type(validators=[validator]))~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Type gets optional ``validators`` parameter, which is a list of ``halogen.validators.Validator`` objects whose singleinterface method ``validate`` will be called for the given value during the deserialization. If the value is not valid,``halogen.exceptions.ValidationError`` should be raised.Halogen provides basic validators, for example ``halogen.validators.Range`` to validate that the values is in certainrange.Attr(default=value)~~~~~~~~~~~~~~~~~~~If an attribute cannot be taken, provided ``default`` value will be used; if ``default`` value isa callable, it will be called to get the default value.Attr(required=False)~~~~~~~~~~~~~~~~~~~~By default, attributes are required, so when an attribute can not be taken during the serialization and ``default``is not provided, an exception will be raised (``AttributeError`` or ``KeyError``, depending on the input).It's possible to relax this restriction by passing ``required=False`` to the attribute constructor.For deserialization, the same logic applies, but the exception type will be ``halogen.exceptions.ValidationError``for human readability (see Deserialization_).Type----Type is responsible in serialization of individual values such as integers, strings, dates. Also typeis a base of Schema. It has both serialize() and deserialize() methods that convert the attribute's value.Unlike Schema types are instantiated. You can configure serialization behavior by passing parameters totheir constructors while declaring your schema.Types can raise ``halogen.exceptions.ValidationError`` during deserialization, but serializationexpects the value that this type knows how to transform.Subclassing types~~~~~~~~~~~~~~~~~Types that are common in your application can be shared between schemas. This could be the datetime type,specific URL type, internationalized strings and any other representation that requires specific format.Type.serialize~~~~~~~~~~~~~~The default implementation of the Type.serialize is a bypass.Serialization method of a type is the last opportunity to convert the value that is being serialized:Example:.. code-block:: python    import halogen    class Amount(object):        currency = &quot;EUR&quot;        amount = 1    class AmountType(halogen.types.Type):        def serialize(self, value):            if value is None or not isinstance(value, Amount):                return None            return {                &quot;currency&quot;: value.currency,                &quot;amount&quot;: value.amount            }    class Product(object):        name = &quot;Milk&quot;        def __init__(self):            self.price = Amount()    product = Product()    class ProductSchema(halogen.Schema):        name = halogen.Attr()        price = halogen.Attr(AmountType())    serialized = ProductSchema.serialize(product)Result:.. code-block:: json    {        &quot;name&quot;: &quot;Milk&quot;,        &quot;price&quot;: {            &quot;amount&quot;: 1,            &quot;currency&quot;: &quot;EUR&quot;        }    }Nullable types~~~~~~~~~~~~~~In case the accessor returns None and the further serialization by a type or a nested schemais not desired the type can be wrapped into `Nullable` type... code-block:: python    import halogen    class FreeProduct(object):        &quot;&quot;&quot;A free product, that doesn't have a price.&quot;&quot;&quot;        price = None    class AmountSchema(halogen.Schema):        currency = halogen.Attr(required=True, default=&quot;USD&quot;)        amount = halogen.Attr(required=True, default=0)    class FreeProductSchema(halogen.Schema):        price_null = halogen.Attr(halogen.types.Nullable(AmountType()), attr=&quot;price&quot;)        price_zero = halogen.Attr(AmountType(), attr=&quot;price&quot;)    serialized = FreeProductSchema.serialize(FreeProduct())Result:.. code-block:: python    {        &quot;price_null&quot;: None,        &quot;price_zero&quot;: {            &quot;amount&quot;: 0,            &quot;currency&quot;: &quot;USD&quot;        }    }HAL===Hypertext Application Language.RFC---The JSON variant of HAL (application/hal+json) has now been published as an internet draft: draft-kelly-json-hal_.. _draft-kelly-json-hal: http://tools.ietf.org/html/draft-kelly-json-hal.Link----Link objects at RFC: link-objects_.. _link-objects: http://tools.ietf.org/html/draft-kelly-json-hal-06#section-5href----The &quot;href&quot; property is REQUIRED.``halogen.Link`` will create ``href`` for you. You just need to point to ``halogen.Link`` either from where orwhat ``halogen.Link`` should put into ``href``.Static variant    .. code-block:: python        import halogen        class EventSchema(halogen.Schema):            artist = halogen.Link(attr=&quot;/artists/some-artist&quot;)Callable variant    .. code-block:: python        import halogen        class EventSchema(halogen.Schema):            help = halogen.Link(attr=lambda: current_app.config['DOC_URL'])deprecation-----------Links can be deprecated by specifying the deprecation URL attribute which points to the documentdescribing the deprecation.    .. code-block:: python        import halogen        class EventSchema(halogen.Schema):            artist = halogen.Link(                attr=&quot;/artists/some-artist&quot;,                deprecation=&quot;http://docs.api.com/deprecations#artist&quot;,            )CURIE~~~~~CURIEs are providing links to the resource documentation... code-block:: python    import halogen    doc = halogen.Curie(        name=&quot;doc,        href=&quot;http://haltalk.herokuapp.com/docs/{rel}&quot;,        templated=True    )    class BlogSchema(halogen.Schema):        lastest_post = halogen.Link(attr=&quot;/posts/latest&quot;, curie=doc).. code-block:: json    {        &quot;_links&quot;: {            &quot;curies&quot;: [                {                  &quot;name&quot;: &quot;doc&quot;,                  &quot;href&quot;: &quot;http://haltalk.herokuapp.com/docs/{rel}&quot;,                  &quot;templated&quot;: true                }            ],            &quot;doc:latest_posts&quot;: {                &quot;href&quot;: &quot;/posts/latest&quot;            }        }    }Schema also can be a param to link.. code-block:: python    import halogen    class BookLinkSchema(halogen.Schema):        href = halogen.Attr(&quot;/books&quot;)    class BookSchema(halogen.Schema):        books = halogen.Link(BookLinkSchema)    serialized = BookSchema.serialize({&quot;books&quot;: &quot;&quot;}).. code-block:: python    {        &quot;_links&quot;: {            &quot;books&quot;: {                &quot;href&quot;: &quot;/books&quot;            }        }    }Embedded~~~~~~~~The reserved &quot;_embedded&quot; property is OPTIONAL. It is an object whose property names are link relation types (asdefined by [RFC5988]) and values are either a Resource Object or an array of Resource Objects.Embedded Resources MAY be a full, partial, or inconsistent version ofthe representation served from the target URI.For creating ``_embedded`` in your schema you should use ``halogen.Embedded``.Example:.. code-block:: python    import halogen    em = halogen.Curie(        name=&quot;em&quot;,        href=&quot;https://docs.event-manager.com/{rel}.html&quot;,        templated=True,        type=&quot;text/html&quot;    )    class EventSchema(halogen.Schema):        self = halogen.Link(&quot;/events/activity-event&quot;)        collection = halogen.Link(&quot;/events/activity-event&quot;, curie=em)        uid = halogen.Attr()    class PublicationSchema(halogen.Schema):        self = halogen.Link(attr=lambda publication: &quot;/campaigns/activity-campaign/events/activity-event&quot;)        event = halogen.Link(attr=lambda publication: &quot;/events/activity-event&quot;, curie=em)        campaign = halogen.Link(attr=lambda publication: &quot;/campaign/activity-event&quot;, curie=em)    class EventCollection(halogen.Schema):        self = halogen.Link(&quot;/events&quot;)        events = halogen.Embedded(halogen.types.List(EventSchema), attr=lambda collection: collection[&quot;events&quot;], curie=em)        publications = halogen.Embedded(            attr_type=halogen.types.List(PublicationSchema),            attr=lambda collection: collection[&quot;publications&quot;],            curie=em        )    collections = {        'events': [            {&quot;uid&quot;: 'activity-event'}        ],        'publications': [            {                &quot;event&quot;: {&quot;uid&quot;: &quot;activity-event&quot;},                &quot;campaign&quot;: {&quot;uid&quot;: &quot;activity-campaign&quot;}            }        ]    }    serialized = EventCollection.serialize(collections)Result:.. code-block:: json    {        &quot;_embedded&quot;: {            &quot;em:events&quot;: [                {                    &quot;_links&quot;: {                        &quot;curies&quot;: [                            {                                &quot;href&quot;: &quot;https://docs.event-manager.com/{rel}.html&quot;,                                &quot;name&quot;: &quot;em&quot;,                                &quot;templated&quot;: true,                                &quot;type&quot;: &quot;text/html&quot;                            }                        ],                        &quot;em:collection&quot;: {&quot;href&quot;: &quot;/events/activity-event&quot;},                        &quot;self&quot;: {&quot;href&quot;: &quot;/events/activity-event&quot;}                    },                    &quot;uid&quot;: &quot;activity-event&quot;                }            ],            &quot;em:publications&quot;: [                {                    &quot;_links&quot;: {                        &quot;curies&quot;: [                            {                                &quot;href&quot;: &quot;https://docs.event-manager.com/{rel}.html&quot;,                                &quot;name&quot;: &quot;em&quot;,                                &quot;templated&quot;: true,                                &quot;type&quot;: &quot;text/html&quot;                            }                        ],                        &quot;em:campaign&quot;: {&quot;href&quot;: &quot;/campaign/activity-event&quot;},                        &quot;em:event&quot;: {&quot;href&quot;: &quot;/events/activity-event&quot;},                        &quot;self&quot;: {&quot;href&quot;: &quot;/campaigns/activity-campaign/events/activity-event&quot;}                    }                }            ]        },        &quot;_links&quot;: {            &quot;curies&quot;: [                {                    &quot;href&quot;: &quot;https://docs.event-manager.com/{rel}.html&quot;,                    &quot;name&quot;: &quot;em&quot;,                    &quot;templated&quot;: true,                    &quot;type&quot;: &quot;text/html&quot;                }            ],            &quot;self&quot;: {&quot;href&quot;: &quot;/events&quot;}        }    }By default, embedded resources are required, you can make them not required by passing ``required=False`` to theconstructor, and empty values will be omitted in the serialization:.. code-block:: python    import halogen    class Schema(halogen.Schema):        user1 = halogen.Embedded(PersonSchema, required=False)        user2 = halogen.Embedded(PersonSchema)    serialized = Schema.serialize({'user2': Person(&quot;John&quot;, &quot;Smith&quot;)})Result:.. code-block:: json    {        &quot;_embedded&quot;: {            &quot;user2&quot;: {                &quot;name&quot;: &quot;John&quot;,                &quot;surname&quot;: &quot;Smith&quot;            }        }    }Deserialization===============Schema has ``deserialize`` method. Method ``deserialize`` will return dict as a result of deserializationif you wont pass any object as a second param.Example:.. code-block:: python    import halogen    class Hello(halogen.Schema):        hello = halogen.Attr()    result = Hello.deserialize({&quot;hello&quot;: &quot;Hello World&quot;})    print(result)Result:.. code-block:: python    {        &quot;hello&quot;: &quot;Hello World&quot;    }However, if you will pass object as the second param of ``deserialize`` method then data will be assigned on object'sattributes.Example:.. code-block:: python    import halogen    class HellMessage(object):        hello = &quot;&quot;    hello_message = HellMessage()    class Hello(halogen.Schema):        hello = halogen.Attr()    Hello.deserialize({&quot;hello&quot;: &quot;Hello World&quot;}, hello_message)    print(hello_message.hello)Result:.. code-block:: python    &quot;Hello World&quot;Type.deserialize----------------How you already know attributes launch ``serialize`` method from types which they are supported in moment ofserialization but in case of deserialization the same attributes will launch ``deserialize`` method. It means thatwhen you write your types you should not forget about ``deserialize`` methods for them.Example:.. code-block:: python    import halogen    import decimal    class Amount(object):        currency = &quot;EUR&quot;        amount = 1        def __init__(self, currency, amount):            self.currency = currency            self.amount = amount        def __repr__(self):            return &quot;Amount: {currency} {amount}&quot;.format(currency=self.currency, amount=str(self.amount))    class AmountType(halogen.types.Type):        def serialize(self, value):            if value is None or not isinstance(value, Amount):                return None            return {                &quot;currency&quot;: value.currency,                &quot;amount&quot;: value.amount            }        def deserialize(self, value):            return Amount(value[&quot;currency&quot;], decimal.Decimal(str(value[&quot;amount&quot;])))    class ProductSchema(halogen.Schema):        title = halogen.Attr()        price = halogen.Attr(AmountType())    product = ProductSchema.deserialize({&quot;title&quot;: &quot;Pencil&quot;, &quot;price&quot;: {&quot;currency&quot;: &quot;EUR&quot;, &quot;amount&quot;: 0.30}})    print(product)Result:.. code-block:: python    {&quot;price&quot;: Amount: EUR 0.3, &quot;title&quot;: &quot;Pencil&quot;}Deserialization validation errors---------------------------------On deserialization failure, halogen raises special exception (``halogen.exceptions.ValidationError``).That exception class has ``__unicode__`` method which  renders human readable error result so user can easily trackdown the problem with his input.Example:.. code-block:: python    import halogen    class Hello(halogen.Schema):        hello = halogen.Attr()    try:        result = Hello.deserialize({})    except halogen.exceptions.ValidationError as exc:        print(exc)Result:.. code-block:: python    {        &quot;errors&quot;: [            {                &quot;errors&quot;: [                        {                            &quot;type&quot;: &quot;str&quot;,                            &quot;error&quot;: &quot;Missing attribute.&quot;                        }                    ],                &quot;attr&quot;: &quot;hello&quot;            }        ],        &quot;attr&quot;: &quot;&lt;root&gt;&quot;    }In case when you have nested schemas, and use ``List``, halogen also adds the index (counting from 0) in the listso you see where exactly the validation error happened.Example:.. code-block:: python    import halogen    class Product(halogen.Schema):        &quot;&quot;&quot;A product has a name and quantity.&quot;&quot;&quot;        name = halogen.Attr()        quantity = halogen.Attr()    class NestedSchema(halogen.Schema):        &quot;&quot;&quot;An example nested schema.&quot;&quot;&quot;        products = halogen.Attr(            halogen.types.List(                Product,            ),            default=[],        )    try:        result = NestedSchema.deserialize({            &quot;products&quot;: [                {                    &quot;name&quot;: &quot;name&quot;,                    &quot;quantity&quot;: 1                },                {                    &quot;name&quot;: &quot;name&quot;,                }            ]        })    except halogen.exceptions.ValidationError as exc:        print(exc)Result:.. code-block:: python    {        &quot;errors&quot;: [            {                &quot;errors&quot;: [                    {                        &quot;index&quot;: 1,                        &quot;errors&quot;: [                            {                                &quot;errors&quot;: [                                    {                                        &quot;type&quot;: &quot;str&quot;,                                        &quot;error&quot;: &quot;Missing attribute.&quot;                                    }                                ],                                &quot;attr&quot;: &quot;quantity&quot;                            }                        ]                    }                ],                &quot;attr&quot;: &quot;products&quot;            }        ],        &quot;attr&quot;: &quot;&lt;root&gt;&quot;    }Note that should ``ValueError`` exception happen on the attribute deserialization, it will be caught and reraizedas ``halogen.exceptions.ValidationError``. This is to eliminate the need of raising halogen specific exceptions intypes and attributes during the deserialization.Providing context~~~~~~~~~~~~~~~~~When serializing or deserializing an object, not all data required for (de)serialization may be available in the objectitself. You can pass this data as separate keyword arguments to `serialize` or ``deserialize`` to provide context.This context will be available in all nested schema, types and attributes.Serialize example:.. code-block:: python    class ErrorSchema(halogen.Schema):        message = halogen.Attr(            attr=lambda error, language: error[&quot;message&quot;][language]        )    error = ErrorSchema.serialize({        &quot;message&quot;: {            &quot;dut&quot;: &quot;Ongeldig e-mailadres&quot;,            &quot;eng&quot;: &quot;Invalid email address&quot;        }    }, language=&quot;dut&quot;)    print errorResult:.. code-block:: python    {&quot;message&quot;: &quot;Ongeldig e-mailadres&quot;}Deserialize example:.. code-block:: python    import halogen    class Book(halogen.Schema):        @halogen.attr()        def title(obj, language):            return obj['title'][language]    class Author(halogen.Schema):        name = halogen.Attr(attr='author.name')        books = halogen.Attr(            halogen.types.List(Book),            attr='author.books',        )    author = Author.deserialize({        &quot;author&quot;: {            &quot;name&quot;: &quot;Roald Dahl&quot;,            &quot;books&quot;: [                {                    &quot;title&quot;: {                        &quot;dut&quot;: &quot;De Heksen&quot;,                        &quot;eng&quot;: &quot;The Witches&quot;                    }                },                {                    &quot;title&quot;: {                        &quot;dut&quot;: &quot;Sjakie en de chocoladefabriek&quot;,                        &quot;eng&quot;: &quot;Charlie and the Chocolate Factory&quot;                    }                }            ]        }    }, language=&quot;eng&quot;)    print authorResult:.. code-block:: python    {        &quot;name&quot;: &quot;Roald Dahl&quot;,        &quot;books&quot;: [            {&quot;title&quot;: &quot;The Witches&quot;},            {&quot;title&quot;: &quot;Charlie and the Chocolate Factory&quot;}        ]    }Vendor media types------------------Handling validation and business logic errors are as important as handling HAL responses.Halogen provides support for the vendor error media type, which is fully HAL-compatible.vnd.error=========The vendor error (application/vnd.error+json) has now been published as an internet draft: draft-vnd-error_.. _draft-vnd-error: http://nocarrier.co.uk/profiles/vnd.error/This mediatype is attempting to standartise the format in which the problem can be represented to many clientsso that it can be expressed and understood.Multiple deserialization errors can be mapped to the relevant keys of the payload via the path attribute, whichrepresents the JSON Pointer to the payload key, and therefore to the UI element that is serialized with that key... code-block:: python    import halogen    from halogen.vnd.error import Error, VNDError    class AuthorSchema(halogen.Schema):        name = halogen.Attr(required=True)    class PublisherSchema(halogen.Schema):        name = halogen.Attr(required=True)        address = halogen.Attr()    class BookSchema(halogen.Schema):        title = halogen.Attr(required=True)        year = halogen.Attr(halogen.types.Int(), required=True)        authors = halogen.Attr(halogen.types.List(AuthorSchema), required=True)        publisher = halogen.Attr(PublisherSchema)    try:        BookSchema.deserialize(            dict(                # title is skipped                year=&quot;abc&quot;,  # Not an integer                authors=[dict(name=&quot;John Smith&quot;), dict()],  # Second author has no name                publisher=dict(address=&quot;Chasey Lane 42, Los Angeles, US&quot;),  # No name            ),        )    except halogen.exceptions.ValidationError as e:        error = Error.from_validation_exception(e)    &gt;&gt;&gt; error.errors    &gt;&gt;&gt;        [            {&quot;path&quot;: &quot;/authors/1/name&quot;, &quot;message&quot;: &quot;Missing attribute.&quot;),            {&quot;path&quot;: &quot;/title&quot;, &quot;message&quot;: &quot;Missing attribute.&quot;),            {&quot;path&quot;: &quot;/year&quot;, &quot;message&quot;: &quot;'abc' is not an integer&quot;),            {&quot;path&quot;: &quot;/publisher/name&quot;, &quot;message&quot;: &quot;Missing attribute.&quot;),        }The errors may or may not be related to the payload, but sometimes to another resources.In this case the about link should be returned within the error... code-block:: python    {        &quot;_links&quot;: {            &quot;about&quot;: {&quot;href&quot;: &quot;/products/1&quot;}        },        &quot;message&quot;: &quot;The product is sold out.&quot;    }i18n----The error messages should be internationalized and respect Accept-Language and Content-Language HTTP headers.Contact=======If you have questions, bug reports, suggestions, etc. please create an issue onthe `GitHub project page &lt;http://github.com/paylogic/halogen&gt;`_.License=======This software is licensed under the `MIT license &lt;http://en.wikipedia.org/wiki/MIT_License&gt;`_See `License file &lt;https://github.com/paylogic/halogen/blob/master/LICENSE.txt&gt;`_Â© 2013 Oleg Pidsadnyi, Paylogic International and others.Changelog=========1.7.0-----* Fix `List` type raising unrelated errors (or no error at all, when passing a dictionary) when deserializing objects that are not lists.1.6.1-----* Hotfix for 1.6.0: Fix serialization/deserialization error `Schema.serialize(...)` is invoked with kwargs and there are attributes using callables that don't require those kwargs.1.6.0-----* Fix DeprecationWarnings being raised (youtux)* Dropped support for python 2.6 and add declare support for python 3.5, 3.6, 3.7, 3.81.5.0-----* Allow passing context keyword arguments to deserialize methods (blaise-io)1.4.1-----* Fix the package setup (olegpidsadnyi)1.4.0-----* Support for vnd.error responses (olegpidsadnyi)1.3.5-----* Add ISO Date Time type (moisesribeiro)1.3.4-----* Nullable type (olegpidsadnyi)1.3.3-----* Strict validation of the ISO8601 (olegpidsadnyi)1.3.2-----* Improve serialization performance (youtux)1.3.1-----* Fix for the String.deserialize to force the text type (olegpidsadnyi)1.3.0-----* Attribute as a decorator (olegpidsadnyi)1.2.1-----* Use native datetime.isoformat for datetime serialization (bubenkoff)1.1.3-----* Correctly handle schema class derivation (bubenkoff)1.1.2-----* Correct deserialization for String and Int types (bubenkoff)1.1.1-----* Deprecation attribute is added to Link (olegpidsadnyi)1.1.0-----* Add common-use types (bubenkoff)1.0.8-----* Correctly handle and document ``required`` and ``default`` (bubenkoff)* Properly get validator's comparison values (lazy and constant) (bubenkoff)* Increase test coverage (bubenkoff)1.0.6-----* Respect ValueError in deserialization of the attributes (bubenkoff)1.0.4-----* Correctly render and document deserialization errors (bubenkoff)1.0.3-----* Allow Embedded fields to be marked as not required (mattupstate)* Field order is preserved in serialized documents (mattupstate)1.0.0-----* Initial public release</longdescription>
</pkgmetadata>