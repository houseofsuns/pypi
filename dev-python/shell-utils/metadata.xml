<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DescriptionThe `shell_utils` library provides some handy utilities for when you need to automate certain processes using shell commands.Where you might otherwise write a bash script or muck around with the `subprocess`, `os`, and `sys`  modules in a Python script `shell_utils` providessome patterns and shortcuts for your automation scripts.Let's say we have a new project we need to automate some build process(es) for. We might be tempted to write a Makefile or bashscript(s) to help with that task. If that works for you, great. However, if you're like me, you prefer to python-all-the-things.We can use shell-utils to create an automation script that will behave much the same way a Makefile would, but with all thePython goodness we want.Some familiarity with the `click` library will be helpful.```bashpip3 install shell_utilsshell_utils generate_runner```This will produce an executable python script with the following code```python#!/usr/bin/env python3import osfrom pathlib import Pathfrom shell_utils import shell, cd, env, path, quietimport click@click.group()def main():    &quot;&quot;&quot;    Development tasks; programmatically generated    &quot;&quot;&quot;    # ensure we're running commands from project root    root = Path(__file__).parent.absolute()    cwd = Path().absolute()    if root != cwd:        click.secho(f'Navigating from {cwd} to {root}',                    fg='yellow')        os.chdir(root)if __name__ == '__main__':    main()```Now let's say that we're using sphinx to generate the documentation we have in our project's `docs` directory.If we wanted to create a command that would re-generate our documentation and open a browser window when it's finished,we could add the following code to our generated `run.py` script```python@main.command()@click.option('--no-browser', is_flag=True, help=&quot;Don't open browser after building docs.&quot;)def docs(no_browser):    &quot;&quot;&quot;    Generate Sphinx HTML documentation, including API docs.    &quot;&quot;&quot;    shell(        &quot;&quot;&quot;        rm -f docs/shell_utils.rst        rm -f docs/modules.rst        rm -rf docs/shell_utils*        sphinx-apidoc -o docs/ shell_utils        &quot;&quot;&quot;    )    with cd('docs'):        shell('make clean')        shell('make html')    shell('cp -rf docs/_build/html/ public/')    if no_browser:        return    shell('open public/index.html')```Then, we can execute the following command to do what we intended:`./run.py docs`The strings sent to the `shell` function will be executed in a `bash` subprocess shell. Before they are executed,the `shell` function will print the command to `stdout`, similar to a `Makefile`.Also, notice we change directories into `docs` using a context manager, that way the commands passed to the `shell` functionwill execute within that directory. Once we're out of the context manager's scope, further `shell` function commands are once-again runfrom the project root.# functions and context managers## shellExecutes the given command in a bash shell. It's just a thin wrapper around `subprocess.run` that adds a couple handy features,such as printing the command it's about to run before executing it.```pythonfrom shell_utils import shellp1 = shell('echo hello, world')print(p1)p2 = shell('echo goodbye, cruel world', capture=True)print('captured the string:', p2.stdout)```**outputs**```bashuser@hostname executing...echo goodbye, cruel worldcaptured the string: goodbye, cruel world```## cdTemporarily changes the current working directory while within the context scope.Within a python shell...```pythonfrom shell_utils import shell, cdwith cd('~'):    shell('echo $PWD')    shell('mkdir -p foo')    with cd('foo'):        shell('echo $PWD')    shell('echo $PWD')```**outputs**```bashuser@hostname executing...echo $PWD/Users/useruser@hostname executing...mkdir -p foouser@hostname executing...echo $PWD/Users/user/foouser@hostname executing...echo $PWD/Users/user```## envTemporarily changes environment variables```pythonfrom shell_utils import envimport osprint(os.getenv('foo', 'nothing'))with env(foo='bar'):    print(os.getenv('foo'))print(os.getenv('foo', 'nothing again'))```**outputs**```bashnothingbarnothing again```## pathA special case of the `env` context manager that alters your $PATH. It expands `~` to your home directory and returnsthe elements of the $PATH variable as a list.```pythonfrom shell_utils import pathimport osdef print_path():    print('$PATH ==', os.getenv('PATH'))print_path()with path('~', prepend=True) as plist:    print_path()    print(plist)```**outputs**```bash$PATH == /Users/user/.venvs/shell-utils-py3.7/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin$PATH == /Users/user:/Users/user/.venvs/shell-utils-py3.7/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin['/Users/user', '/Users/user/.venvs/shell-utils-py3.7/bin', '/usr/local/sbin', '/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin', '/Library/TeX/texbin']```</longdescription>
</pkgmetadata>