<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PIDCalib2A set of software tools for estimating LHCb PID efficiencies.The package includes several user-callable modules:- [`make_eff_hists`](#make_eff_hists) creates histograms that can be used to estimate the PID efficiency of a user's sample- [`ref_calib`](#ref_calib) calculates the LHCb PID efficiency of a user reference sample- `merge_trees` merges two ROOT files with compatible `TTree`s- [`plot_calib_distributions`](#plot_calib_distributions) allows you to plot distributions of variables in the calibration datasets- [`pklhisto2root`](#pklhisto2root) converts [Pickled](https://docs.python.org/3/library/pickle.html) [boost-histogram](https://github.com/scikit-hep/boost-histogram)s to ROOT histogramsThe term &quot;reference dataset/sample&quot; refers to the user's dataset to which they want to assign PID efficiencies. The &quot;calibration datasets/samples&quot; are the special, centrally managed samples used internally by PIDCalib for PID efficiency estimation. The `--sample` argument always concerns these calibration samples.Slides with additional information, example output, and plots are available on [Indico](https://indico.cern.ch/event/1055804/contributions/4440878/attachments/2277451/3869206/Run12_210707_v2.pdf).## SetupWhen working on a computer where the LHCb software stack is available (LXPLUS, university cluster, etc.), one can setup PIDCalib2 by running```shlb-conda pidcalib bash```After this, the following commands will be available```shpidcalib2.make_eff_histspidcalib2.ref_calibpidcalib2.merge_treespidcalib2.plot_calib_distributionspidcalib2.pklhisto2root```You can skip the bash invocation and join the setup and run phases into a single command```shlb-conda pidcalib pidcalib2.make_eff_hists```To run `make_eff_hists`, you will need access to CERN EOS. You don't need to do anything special on LXPLUS. On other machines, you will usually need to obtain a Kerberos ticket by running```shkinit [username]@CERN.CH```### Installing from PyPIThe PIDCalib2 package is available on [PyPI](https://pypi.org/project/pidcalib2/). It can be installed on any computer via `pip` simply by running (preferably in a virtual environment; see [`venv`](https://docs.python.org/3/library/venv.html))```shpip install pidcalib2```Note that this will install the [`xrootd`](https://pypi.org/project/xrootd/) *Python bindings*. One also has to install XRootD itself for the bindings to work. See [this page](https://xrootd.slac.stanford.edu/index.html) for XRootD releases and instructions.## `make_eff_hists`This module creates histograms that can be used to estimate the PID efficiency of a user's sample.Reading all the relevant calibration files can take a long time. When running a configuration for the first time, we recommend using the `--max-files 1` option. This will limit PIDCalib2 to reading just a single calibration file. Such a test will reveal any problems with, e.g., missing variables quickly. Keep in mind that you might get a warning about empty bins in the total histogram as you are reading a small subset of the calibration data. For the purposes of a quick test, this warning can be safely ignored.### OptionsTo get a usage message listing all the options, their descriptions, and default values, type```pidcalib2.make_eff_hists --help```The calibration files to be processed are determined by the `sample`, `magnet`, and `particle` options. All the valid combinations can be listed by running```shpidcalib2.make_eff_hists --list configs```Aliases for standard variables are defined to simplify the commands. We recommend users use the aliases when specifying variables. When you use a name that isn't an alias, a warning message like the following will show up in the log.```'probe_PIDK' is not a known PID variable alias, using raw variable```All aliases can be listed by running```shpidcalib2.make_eff_hists --list aliases```Note that there are many more variables than there are aliases. If you want to find a variable for which no alias exists, you can check one of the calibration files yourself. The paths to the calibration files are printed when the `--verbose` option is specified. Alternatively, you can simply guess the name - if it doesn't exist, PIDCalib2 will let you know and might provide a list of similar names that do exist.A file with alternative binnings can be specified using `--binning-file`. The file must contain valid JSON specifying bin edges. For example, two-bin binnings for particle `Pi`, variables `P` and `PT` can be defined as```json{&quot;Pi&quot;: {&quot;P&quot;: [10000, 15000, 30000], &quot;PT&quot;: [6000, 10000, 20000]}}```An arbitrary number of binnings can be defined in a single file.Complex cut expressions can be created by chaining simpler expressions using `&amp;` (logical and) and `|` (logical or). One can also use standard mathematical symbols, like `*`, `/`, `+`, `-`, `(`, `)`. Whitespace does not matter.### Examples- Create a single 3D efficiency histogram for a single PID cut  ```sh  pidcalib2.make_eff_hists --sample Turbo18 --magnet up --particle Pi --pid-cut &quot;DLLK &gt; 4&quot; --bin-var P --bin-var ETA --bin-var nSPDhits --output-dir pidcalib_output  ```- Create multiple histograms in one run (most of the time is spent readingin data, so specifying multiple cuts is much faster than runningmake_eff_hists sequentially)  ```sh  pidcalib2.make_eff_hists --sample Turbo16 --magnet up --particle Pi --pid-cut &quot;DLLK &gt; 0&quot; --pid-cut &quot;DLLK &gt; 4&quot; --pid-cut &quot;DLLK &gt; 6&quot; --bin-var P --bin-var ETA --bin-var nSPDhits --output-dir pidcalib_output  ```- Create a single efficiency histogram for complex cuts using only negatively charged tracks  ```sh  pidcalib2.make_eff_hists --sample Turbo18 --magnet up --particle Pi --pid-cut &quot;MC15TuneV1_ProbNNp*(1-MC15TuneV1_ProbNNpi)*(1-MC15TuneV1_ProbNNk) &lt; 0.5 &amp; DLLK &lt; 3&quot; --cut &quot;IsMuon==0 &amp; Brunel_PT&gt;250 &amp; trackcharge==-1&quot; --bin-var P --bin-var ETA --bin-var nSPDhits --output-dir pidcalib_output  ```### CaveatsNot all datasets have all the variables, and in some cases, the same variable is named differently (e.g., `probe_Brunel_IPCHI2` is named `probe_Brunel_MINIPCHI2` in certain electron samples). The aliases correspond to the most common names, but you might need to check the calibration files if PIDCalib2 can't find the variable you need.## `ref_calib`This module uses the histograms created by `make_eff_hists` to assign efficiency to events in a reference sample supplied by the user. Adding efficiency to the user-supplied file requires PyROOT and is optional.The module works in two steps:1. Calculate the efficiency and save it as a TTree in a separate file.2. Optionally copy the efficiency TTree to the reference file and make it a friend of the user's TTree. The user must request the step by specifying `--merge` on the command line.Be aware that `--merge` will modify your file. Use with caution.### OptionsThe `sample` and `magnet` options are used solely to select the correct PID efficiency histograms. They should therefore mirror the options used when running `make_eff_hists`.`bin-vars` must be a dictionary that relates the binning variables (or aliases) used to make the efficiency histograms with the variables in the reference sample. We assume that the reference sample branch names have the format `[ParticleName]_[VariableName]`. E.g., `D0_K_calcETA`, corresponds to a particle named `D0_K` and variable `calcETA`. If the user wants to estimate PID efficiency of their sample using 1D binning, where `calcETA` corresponds to the `ETA` binning variable alias of the calibration sample, they should specify `--bin-vars '{&quot;ETA&quot;: &quot;calcETA&quot;}'`.`ref-file` is the user's reference file to which they want to assign PID efficiencies. The parameter can be a local file or a remote file, e.g., on EOS (`--ref-file root://eoslhcb.cern.ch//eos/lhcb/user/a/anonymous/tuple.root`).`ref-pars` must be a dictionary of particles from the reference sample to apply cuts to. The keys represent the particle branch name prefix (`D0_K` in the previous example), and the values passed are a list containing particle type and PID cut, e.g. `'{&quot;D0_K&quot; : [&quot;K&quot;, &quot;DLLK &gt; 4&quot;], &quot;D0_Pi&quot; : [&quot;Pi&quot;, &quot;DLLK &lt; 4&quot;]}'`.The `--merge` option will copy the PID efficiency tree to your input file and make the PID efficiency tree a &quot;Friend&quot; of your input tree. Then you can treat your input tree as if it had the PID efficiency branches itself. E.g., `input_tree-&gt;Draw(&quot;PIDCalibEff&quot;)` should work. ROOT's &quot;Friend&quot; mechanism is an efficient way to add branches from one tree to another. Take a look [here](https://root.cern.ch/root/htmldoc/guides/users-guide/Trees.html#example-3-adding-friends-to-trees) if you would like to know more.### Examples- Evaluate efficiency of a single PID cut and save it to `user_ntuple_PID_eff.root` without adding it to `user_ntuple.root`  ```sh  pidcalib2.ref_calib --sample Turbo18 --magnet up --ref-file data/user_ntuple.root --histo-dir pidcalib_output --bin-vars '{&quot;P&quot;: &quot;mom&quot;, &quot;ETA&quot;: &quot;Eta&quot;, &quot;nSPDHits&quot;: &quot;nSPDhits&quot;}' --ref-pars '{&quot;Bach&quot;: [&quot;K&quot;, &quot;DLLK &gt; 4&quot;]}' --output-file user_ntuple_PID_eff.root  ```- Evaluate efficiency of a single PID cut and add it to the reference file `user_ntuple.root`  ```sh  pidcalib2.ref_calib --sample Turbo18 --magnet up --ref-file data/user_ntuple.root --histo-dir pidcalib_output --bin-vars '{&quot;P&quot;: &quot;mom&quot;, &quot;ETA&quot;: &quot;Eta&quot;, &quot;nSPDHits&quot;: &quot;nSPDhits&quot;}' --ref-pars '{&quot;Bach&quot;: [&quot;K&quot;, &quot;DLLK &gt; 4&quot;]}' --output-file user_ntuple_PID_eff.root --merge  ```- Evaluate efficiency of multiple PID cuts and add them to the reference file  ```sh  pidcalib2.ref_calib --sample Turbo18 --magnet up --ref-file data/user_ntuple.root --histo-dir pidcalib_output --bin-vars '{&quot;P&quot;: &quot;P&quot;, &quot;ETA&quot;: &quot;ETA&quot;, &quot;nSPDHits&quot;: &quot;nSPDHits&quot;}' --ref-pars '{&quot;Bach&quot;: [&quot;K&quot;, &quot;DLLK &gt; 4&quot;], &quot;SPi&quot;: [&quot;Pi&quot;, &quot;DLLK &lt; 0&quot;]}' --output-file user_ntuple_PID_eff.root --merge  ```### CaveatsYou might notice that some of the events in your reference sample are assigned `PIDCalibEff`, `PIDCalibErr`, or both of -999.- `PIDCalibEff` is -999 when for at least one track  - The event is out of binning range  - The relevant bin in the efficiency histogram has no events whatsoever  - The efficiency is negative- `PIDCalibErr` is -999 when for at least one track  - The event is out of binning range  - The relevant bin in the efficiency histogram has no events whatsoever  - The relevant bin in the efficiency histogram has no events passing PID cuts  - The efficiency is negativeBecause of `double` → `float` conversion in the original PIDCalib, tiny discrepancies (&lt;1e−3 relative difference) in the efficiencies and/or uncertainties are to be expected.A bug in the original PIDCalib caused the electron calibration datasets to be read twice, resulting in incorrect efficiency map uncertainties.The original PIDCalib didn't apply the correct cuts to Omega samples (`K_Omega` and `K_DD`), leading to non-sensical efficiency maps.## `plot_calib_distributions`This tool allows you to plot distributions of variables in the calibration datasets. You can supply the same cuts and custom binnings that you would use for `make_eff_hists`. If you wish to plot a variable for which no binning exists, a uniform binning with 50 bins will be used. You can change the number of bins using `--bins` and force a uniform binning even if another binning is defined via `--force-uniform`.A plot for every requested variable will be created in the `--output-dir` directory. The format of the plots can be controlled by `--format`. Furthermore, `plot_calib_distributions.pkl` will be saved in the same directory, containing all the histograms, should the user want to make the plots manually.### Examples- Create plots of the variables DLLK and P using 1 calibration file  ```sh  pidcalib2.plot_calib_distributions --sample Turbo18 --magnet up --particle Pi --bin-var DLLK --bin-var P --output-dir pidcalib_output --max-files 1  ```- Create PDF plots of variable P with 95 uniform bins  ```sh  pidcalib2.plot_calib_distributions --sample Turbo18 --magnet up --particle Pi --bin-var P --output-dir pidcalib_output --max-files 1 --format pdf --force-uniform --bins 95  ```- Create plots of variable P using custom binning  ```sh  pidcalib2.plot_calib_distributions --sample Turbo18 --magnet up --particle Pi --bin-var P --output-dir pidcalib_output --max-files 1 --format png --binning-file my_binning.json  ```## `pklhisto2root`This tool converts pickled PIDCalib2 histograms to `TH*D` and saves them in a ROOT file. It can be used on histograms produced by `make_eff_hists` or `plot_calib_distributions`. Note that ROOT supports only 1-, 2-, and 3-dimensional histograms; attempting to convert higher-dimensional histograms will fail.### Example- Convert pickled boost_histograms from `make_eff_hists` to ROOT  ```sh  pidcalib2.pklhisto2root &quot;pidcalib_output/effhists-Turbo18-up-Pi-DLLK&gt;4-P.ETA.nSPDhits.pkl&quot;  ```  This will translate the histograms and save them to `pidcalib_output/effhists-Turbo18-up-Pi-DLLK&gt;4-P.ETA.nSPDhits.root`.## Development### With lb-condaOn machines where `lb-conda` is available, you may use the `pidcalib` environment for PIDCalib2 development. This is mainly useful for small modifications and only if you don't need to add any new dependencies.1. Clone the repository from [GitLab](https://gitlab.cern.ch/lhcb-rta/pidcalib2)2. Enter the PIDCalib2 directory   ```sh   cd pidcalib2   ```2. Start a new BASH shell within the `pidcalib` environment```shlb-conda pidcalib bash```3. Run your *local* PIDCalib2 code```shcd srcpython -m pidcalib2.make_eff_hists -h```### Without lb-condaThis is a more versatile (if convoluted) method. It gives you full control of the dev environment and the ability to use IDEs, etc.1. Clone the repository from [GitLab](https://gitlab.cern.ch/lhcb-rta/pidcalib2)2. Enter the PIDCalib2 directory   ```sh   cd pidcalib2   ```3. (Optional) Set up a virtual environment   ```sh   python3 -m venv .venv   source .venv/bin/activate   ```4. Install pinned dependencies   ```sh   pip install -r requirements-dev.txt   ```5. Install `xrootd` (possibly manually; see this [issue](https://github.com/xrootd/xrootd/issues/1397))6. Run the tests   ```sh   pytest   ```7. Run the modules   ```sh   cd src   python3 -m pidcalib2.make_eff_hists -h   ```### TipsCertain tests can be excluded using markers like this  ```sh  pytest -m &quot;not xrootd&quot;  ```See available markers by running `pytest --markers` (the list will start with PIDCalib2 custom markers, then it will include all the pytest built-in markers).## Links- [PIDGen2](https://gitlab.cern.ch/lhcb-rta/pidgen2) - a tool to resample MC PID variables based on distributions from data calibration samples</longdescription>
</pkgmetadata>