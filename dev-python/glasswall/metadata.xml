<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![](https://github.com/filetrust/glasswall-python/actions/workflows/python-package.yml/badge.svg)![](https://github.com/filetrust/glasswall-python/actions/workflows/python-publish.yml/badge.svg)&lt;!-- omit in toc --&gt;# Glasswall Python WrapperA high level Python wrapper for interfacing with Glasswall libraries.&lt;!-- omit in toc --&gt;## InstallationInstall or upgrade to the latest version via pip:&lt;!-- omit in toc --&gt;### Online installation```pip install --upgrade glasswall```&lt;!-- omit in toc --&gt;### Offline installation for CentOS 7 and RHEL8Run the following commands within the directory containing the offline installation files.```pip install --upgrade --no-index --find-links=. glasswall```**Note:** The lxml wheel includes the required lxml dependencies and has been tested on CentOS 7 and RHEL8 environments.&lt;!-- omit in toc --&gt;## Prerequisites- [Python &gt;= 3.6](https://www.python.org/downloads/)&lt;!-- omit in toc --&gt;## Auto-generated Documentationhttps://gw-engineering.github.io/glasswall-python-wrapper/&lt;!-- omit in toc --&gt;## Examples- [Loading a Glasswall library](#loading-a-glasswall-library)- [Logging](#logging)- [Content management policies](#content-management-policies)- [Editor](#editor)  - [Protect](#protect)    - [Protect from file path to file path](#protect-from-file-path-to-file-path)    - [Protect from file path to memory](#protect-from-file-path-to-memory)    - [Protect from memory](#protect-from-memory)    - [Protect files in a directory](#protect-files-in-a-directory)    - [Protect files in a directory that may contain unsupported file types](#protect-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Protect files in a directory using a custom content management policy](#protect-files-in-a-directory-using-a-custom-content-management-policy)    - [Protect files in a directory conditionally based on file format](#protect-files-in-a-directory-conditionally-based-on-file-format)  - [Analysis](#analysis)    - [Analyse from file path to file path](#analyse-from-file-path-to-file-path)    - [Analyse from file path to memory](#analyse-from-file-path-to-memory)    - [Analyse from memory](#analyse-from-memory)    - [Analyse files in a directory](#analyse-files-in-a-directory)    - [Analyse files in a directory that may contain unsupported file types](#analyse-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Analyse files in a directory using a custom content management policy](#analyse-files-in-a-directory-using-a-custom-content-management-policy)    - [Analyse files in a directory conditionally based on file format](#analyse-files-in-a-directory-conditionally-based-on-file-format)  - [Export](#export)    - [Export from file path to file path](#export-from-file-path-to-file-path)    - [Export from file path to memory](#export-from-file-path-to-memory)    - [Export from memory](#export-from-memory)    - [Export files in a directory](#export-files-in-a-directory)    - [Export files in a directory that may contain unsupported file types](#export-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Export files in a directory using a custom content management policy](#export-files-in-a-directory-using-a-custom-content-management-policy)    - [Export files in a directory conditionally based on file format](#export-files-in-a-directory-conditionally-based-on-file-format)  - [Import](#import)    - [Import from file path to file path](#import-from-file-path-to-file-path)    - [Import from file path to memory](#import-from-file-path-to-memory)    - [Import from memory](#import-from-memory)    - [Import files in a directory](#import-files-in-a-directory)    - [Import files in a directory that may contain unsupported file types](#import-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Import files in a directory using a custom content management policy](#import-files-in-a-directory-using-a-custom-content-management-policy)    - [Import files in a directory conditionally based on file format](#import-files-in-a-directory-conditionally-based-on-file-format)- [Rebuild](#rebuild)- [Archive Manager](#archive-manager)    - [Protect an archive](#protect-an-archive)    - [Protect all archives in a directory using a custom content management policy](#protect-all-archives-in-a-directory-using-a-custom-content-management-policy)  - [Extraction - Unpacking an archive](#extraction---unpacking-an-archive)    - [Other useful arguments when unpacking](#other-useful-arguments-when-unpacking)  - [Extraction - Unpacking a directory of archives](#extraction---unpacking-a-directory-of-archives)  - [Compression - Packing a directory into an archive](#compression---packing-a-directory-into-an-archive)- [WordSearch](#wordsearch)  - [Redact](#redact)    - [Redact from file path to file path](#redact-from-file-path-to-file-path)    - [Redact from file path to memory](#redact-from-file-path-to-memory)    - [Redact from memory](#redact-from-memory)    - [Redact files in a directory](#redact-files-in-a-directory)    - [Redact files in a directory that may contain unsupported file types](#redact-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Redact files in a directory conditionally based on file format](#redact-files-in-a-directory-conditionally-based-on-file-format)### Loading a Glasswall libraryEach library is a subclass of the `glasswall.libraries.library.Library` class and can be accessed from the top level of the `glasswall` module. The following subclasses are available:- ArchiveManager- Editor- Rebuild- SecurityTagging- WordSearchLibraries are loaded on initialisation and have one required argument: `library_path` which can be the path to a file or a directory. If a directory is specified it is recursively searched and the library with the latest change time will be loaded.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)``````&gt;&gt;&gt; 2021-03-15 12:27:42.337 glasswall INFO     __init__                  Loaded Glasswall Editor version 2.173 from C:\gwpw\libraries\sdk.editor\windows-drop-no-kill-switch\glasswall_core2.dll```---### LoggingLogs are saved to the temp directory and are also output to console with a default logging level of INFO. You can view the file path of the temp directory or the log file:```pyimport glasswallprint(glasswall._TEMPDIR)print(glasswall.config.logging.log_file_path)``````&gt;&gt;&gt; C:\Users\ANGUSR~1\AppData\Local\Temp\glasswall&gt;&gt;&gt; C:\Users\ANGUSR~1\AppData\Local\Temp\glasswall\logs\2021-03-15 122826.txt```The logging level can be modified, for a list of levels see: https://docs.python.org/3/library/logging.html#logging-levels```pyimport loggingimport glasswall# Modify logging level for logs to the consoleglasswall.config.logging.console.setLevel(logging.DEBUG)# Modify logging level for logs to fileglasswall.config.logging.log.setLevel(logging.DEBUG)```---### Content management policiesDocumentation about content management policies can be found on the [Policy Management](https://docs.glasswall.com/docs/embedded-engine-policy-management) page.Subclasses of the `glasswall.content_management.policies.Policy` class can be used to easily create content management policies of varying complexity by passing the `default` and `config` keyword arguments. Subclasses include:- ArchiveManager- Editor- Rebuild- WordSearchSome examples of content management policies are below. Note that if a content management policy is required but has not been specified with the keyword argument `content_management_policy` then the default content management policy will be used.Content management policies can be specified using subclasses of `Policy`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\input_sanitised&quot;,    content_management_policy=glasswall.content_management.policies.Editor(default=&quot;sanitise&quot;))```or loaded from a file path:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\input_sanitised&quot;,    content_management_policy=r&quot;C:\gwpw\configs\config.xml&quot;)```Default sanitise all Editor policy```pyimport glasswall# Print the default Editor content management policyprint(glasswall.content_management.policies.Editor())``````xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;config&gt;    &lt;pdfConfig&gt;        &lt;acroform&gt;sanitise&lt;/acroform&gt;        &lt;actions_all&gt;sanitise&lt;/actions_all&gt;        &lt;digital_signatures&gt;sanitise&lt;/digital_signatures&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;sanitise&lt;/javascript&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;    &lt;/pdfConfig&gt;    &lt;pptConfig&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;sanitise&lt;/javascript&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;        &lt;review_comments&gt;sanitise&lt;/review_comments&gt;    &lt;/pptConfig&gt;    &lt;sysConfig&gt;        &lt;interchange_pretty&gt;false&lt;/interchange_pretty&gt;        &lt;interchange_type&gt;sisl&lt;/interchange_type&gt;    &lt;/sysConfig&gt;    &lt;tiffConfig&gt;        &lt;geotiff&gt;sanitise&lt;/geotiff&gt;    &lt;/tiffConfig&gt;    &lt;wordConfig&gt;        &lt;dynamic_data_exchange&gt;sanitise&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;        &lt;review_comments&gt;sanitise&lt;/review_comments&gt;    &lt;/wordConfig&gt;    &lt;xlsConfig&gt;        &lt;dynamic_data_exchange&gt;sanitise&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;        &lt;review_comments&gt;sanitise&lt;/review_comments&gt;    &lt;/xlsConfig&gt;&lt;/config&gt;```Custom Rebuild policy```pyimport glasswall# Print a custom Rebuild content management policy with a default of allow# that only sanitises macros in wordConfig, and embedded images and files in# xlsConfigprint(glasswall.content_management.policies.Rebuild(    default=&quot;allow&quot;,    config={        &quot;wordConfig&quot;: {            &quot;macros&quot;: &quot;sanitise&quot;,        },        &quot;xlsConfig&quot;: {            &quot;embedded_files&quot;: &quot;sanitise&quot;,            &quot;embedded_images&quot;: &quot;sanitise&quot;,        },    }))``````xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;config&gt;    &lt;pdfConfig&gt;        &lt;acroform&gt;allow&lt;/acroform&gt;        &lt;actions_all&gt;allow&lt;/actions_all&gt;        &lt;digital_signatures&gt;allow&lt;/digital_signatures&gt;        &lt;embedded_files&gt;allow&lt;/embedded_files&gt;        &lt;embedded_images&gt;allow&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;allow&lt;/javascript&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;    &lt;/pdfConfig&gt;    &lt;pptConfig&gt;        &lt;embedded_files&gt;allow&lt;/embedded_files&gt;        &lt;embedded_images&gt;allow&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;allow&lt;/javascript&gt;        &lt;macros&gt;allow&lt;/macros&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;        &lt;review_comments&gt;allow&lt;/review_comments&gt;    &lt;/pptConfig&gt;    &lt;sysConfig&gt;        &lt;default&gt;allow&lt;/default&gt;        &lt;interchange_pretty&gt;false&lt;/interchange_pretty&gt;        &lt;interchange_type&gt;sisl&lt;/interchange_type&gt;    &lt;/sysConfig&gt;    &lt;tiffConfig&gt;        &lt;geotiff&gt;allow&lt;/geotiff&gt;    &lt;/tiffConfig&gt;    &lt;wordConfig&gt;        &lt;dynamic_data_exchange&gt;allow&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;allow&lt;/embedded_files&gt;        &lt;embedded_images&gt;allow&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;        &lt;review_comments&gt;allow&lt;/review_comments&gt;    &lt;/wordConfig&gt;    &lt;xlsConfig&gt;        &lt;dynamic_data_exchange&gt;allow&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;macros&gt;allow&lt;/macros&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;        &lt;review_comments&gt;allow&lt;/review_comments&gt;    &lt;/xlsConfig&gt;&lt;/config&gt;```---### Editor#### ProtectFiles can be protected individually from a file path or in memory using the [`protect_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.protect_file) method, or all files from a directory can be protected using the [`protect_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.protect_directory) method.##### Protect from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to sanitise a file, writing the sanitised file to a new patheditor.protect_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\editor\protect_f2f\TestFile_11.doc&quot;,)```##### Protect from file path to memory`protect_file` returns the protected file's bytes. The below example demonstrates assigning the variable `file_bytes`. We can see that after sanitisation the first 8 bytes of `file_bytes` matches the [file signature](https://en.wikipedia.org/wiki/List_of_file_signatures) for the Microsoft Compound File Binary (CFB) format, `D0 CF 11 E0 A1 B1 1A E1`.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to sanitise a file in memory, returning the file bytes in memoryfile_bytes = editor.protect_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Protect from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input\TestFile_11.doc&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Use the default policy to sanitise a filefile_bytes = editor.protect_file(    input_file=input_bytes,)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Protect files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to protect a directory of files, writing the sanitised files to a new directory.editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\protect_directory&quot;)```##### Protect files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to protect a directory of files, writing the sanitised files to a new directory.editor.protect_directory(    input_directory=r&quot;C:\gwpw\input_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\editor\protect_directory_unsupported&quot;,    raise_unsupported=False)```##### Protect files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to sanitise all files in the input directory# and write them to the input_sanitised directory. If macros are present# in ppt or word files, the file will be marked as non-conforming and blocked.# If internal or external hyperlinks are present in word files they will not# be sanitised, and will remain in the regenerated document.editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\protect_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;pptConfig&quot;: {                &quot;macros&quot;: &quot;disallow&quot;,            },            &quot;wordConfig&quot;: {                &quot;internal_hyperlinks&quot;: &quot;allow&quot;,                &quot;external_hyperlinks&quot;: &quot;allow&quot;,                &quot;macros&quot;: &quot;disallow&quot;,            }        }    ))```##### Protect files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input&quot;output_directory = r&quot;C:\gwpw\output\editor\protect_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Protect only doc and docx files    if file_type in [&quot;doc&quot;, &quot;docx&quot;]:        editor.protect_file(input_file, output_file)```---#### AnalysisFiles can be analysed individually from a file path or in memory using the [`analyse_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.analyse_file) method, or all files from a directory can be analysed using the [`analyse_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.analyse_directory) method.##### Analyse from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a file, writing the analysis report to a new patheditor.analyse_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\editor\analyse_f2f\TestFile_11.doc.xml&quot;,)```##### Analyse from file path to memory`analyse_file` returns the analysis report xml file's bytes. The below example demonstrates assigning the variable `analysis_report` and checking the contents of the beginning of an Editor analysis report.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a fileanalysis_report = editor.analyse_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,)assert analysis_report[:500] == b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;gw:GWallInfo xsi:schemaLocation=&quot;http://glasswall.com/namespace/gwallInfo.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentStatistics&gt;\n\t\t&lt;gw:DocumentSummary&gt;\n\t\t\t&lt;gw:TotalSizeInBytes&gt;35840&lt;/gw:TotalSizeInBytes&gt;\n\t\t\t&lt;gw:FileType&gt;doc&lt;/gw:FileType&gt;\n\t\t\t&lt;gw:Version&gt;Not Applicable&lt;/gw:Version&gt;\n\t\t\t&lt;gw:InputSHA256&gt;9FDE85B8800C1019D2865FA298A7F75873E09870B71F9825827E354B865686A6&lt;/gw:InputSHA256&gt;\n\t\t\t&lt;gw'```##### Analyse from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input\TestFile_11.doc&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Use the default policy to analyse a fileanalysis_report = editor.analyse_file(    input_file=input_bytes,)assert analysis_report[:500] == b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;gw:GWallInfo xsi:schemaLocation=&quot;http://glasswall.com/namespace/gwallInfo.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentStatistics&gt;\n\t\t&lt;gw:DocumentSummary&gt;\n\t\t\t&lt;gw:TotalSizeInBytes&gt;35840&lt;/gw:TotalSizeInBytes&gt;\n\t\t\t&lt;gw:FileType&gt;doc&lt;/gw:FileType&gt;\n\t\t\t&lt;gw:Version&gt;Not Applicable&lt;/gw:Version&gt;\n\t\t\t&lt;gw:InputSHA256&gt;9FDE85B8800C1019D2865FA298A7F75873E09870B71F9825827E354B865686A6&lt;/gw:InputSHA256&gt;\n\t\t\t&lt;gw'```##### Analyse files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a directory of files, writing the analysis reports to a new directory.editor.analyse_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\analyse_directory&quot;)```##### Analyse files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a directory of files, writing the analysis reports to a new directory.editor.analyse_directory(    input_directory=r&quot;C:\gwpw\input_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\editor\analyse_directory_unsupported&quot;,    raise_unsupported=False)```##### Analyse files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to analyse all files in the input directory# and write them to analyse_directory_custom directory. If macros are# present in ppt or word files, a GeneralFail exception will be raised if the# raise_unsupported argument is left at it's default value of False, but the# analysis report will still be written to file and will contain IssueItems.# If internal or external hyperlinks are present in word files they will not# be sanitised, and will remain in the regenerated document.editor.analyse_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\analyse_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;pptConfig&quot;: {                &quot;macros&quot;: &quot;disallow&quot;,            },            &quot;wordConfig&quot;: {                &quot;internal_hyperlinks&quot;: &quot;allow&quot;,                &quot;external_hyperlinks&quot;: &quot;allow&quot;,                &quot;macros&quot;: &quot;disallow&quot;,            }        }    ),    raise_unsupported=False)```##### Analyse files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input&quot;output_directory = r&quot;C:\gwpw\output\editor\analyse_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file + &quot;.xml&quot;)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Analyse only doc and docx files    if file_type in [&quot;doc&quot;, &quot;docx&quot;]:        editor.analyse_file(input_file, output_file)```---#### ExportFiles can be exported individually from a file path or in memory using the [`export_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.export_file) method, or all files from a directory can be exported using the [`export_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.export_directory) method.##### Export from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a file, writing the export archive to a new patheditor.export_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;,)```##### Export from file path to memory`export_file` returns the exported archive file's bytes. The below example demonstrates assigning the variable `export_archive` and checking the contents of the beginning of an Editor export archive.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a fileexport_archive = editor.export_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,)assert export_archive[:8] == b'PK\x03\x04\x14\x00\x0e\x00'```##### Export from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input\TestFile_11.doc&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Use the default policy to export a fileexport_archive = editor.export_file(    input_file=input_bytes,)assert export_archive[:8] == b'PK\x03\x04\x14\x00\x0e\x00'```##### Export files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a directory of files, writing the export archives to a new directory.editor.export_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\export_directory&quot;)```##### Export files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a directory of files, writing the export archives to a new directory.editor.export_directory(    input_directory=r&quot;C:\gwpw\input_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\editor\export_directory_unsupported&quot;,    raise_unsupported=False)```##### Export files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to export all files in the input directory# and write them to export_directory_custom directory. Write streams as# &quot;.xml&quot; instead of the default interchange_type, &quot;.sisl&quot;. Export embedded# images as &quot;.xml&quot; instead of their default image file type.editor.export_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\export_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;sysConfig&quot;: {                &quot;interchange_type&quot;: &quot;xml&quot;,                &quot;export_embedded_images&quot;: &quot;true&quot;,            },        }    ),    raise_unsupported=False)```##### Export files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input&quot;output_directory = r&quot;C:\gwpw\output\editor\export_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file + &quot;.zip&quot;)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Export only doc and docx files    if file_type in [&quot;doc&quot;, &quot;docx&quot;]:        editor.export_file(input_file, output_file)```---#### ImportExport archives can be imported individually from a file path or in memory using the [`import_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.import_file) method, or all export archives from a directory can be imported using the [`import_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.import_directory) method.##### Import from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to import an export archive, writing the imported file to a new patheditor.import_file(    input_file=r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;,    output_file=r&quot;C:\gwpw\output\editor\import_f2f\TestFile_11.doc&quot;,)```##### Import from file path to memory`import_file` returns the imported file's bytes. The below example demonstrates assigning the variable `file_bytes` and checking the contents of the beginning of an Editor export archive.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to import an export archivefile_bytes = editor.import_file(    input_file=r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;,)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Import from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;, &quot;rb&quot;) as f:    export_archive_bytes = f.read()# Use the default policy to import an export archivefile_bytes = editor.import_file(    input_file=export_archive_bytes,)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Import files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to import a directory of export archives, writing the import archives to a new directory.editor.import_directory(    input_directory=r&quot;C:\gwpw\output\editor\export_directory&quot;,    output_directory=r&quot;C:\gwpw\output\editor\import_directory&quot;)```##### Import files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a directory of export archives, writing the export archives to a new directory.editor.import_directory(    input_directory=r&quot;C:\gwpw\output\editor\export_directory_unsupported&quot;,    output_directory=r&quot;C:\gwpw\output\editor\import_directory_unsupported&quot;,    raise_unsupported=False)```##### Import files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to import all files in the export directory# and write them to import_directory_custom directory. Read streams as# &quot;.xml&quot; instead of the default interchange_type, &quot;.sisl&quot;.editor.import_directory(    input_directory=r&quot;C:\gwpw\output\editor\export_directory_custom&quot;,    output_directory=r&quot;C:\gwpw\output\editor\import_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;sysConfig&quot;: {                &quot;interchange_type&quot;: &quot;xml&quot;,            },        }    ),    raise_unsupported=False)```##### Import files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\output\editor\export_directory_file_format&quot;output_directory = r&quot;C:\gwpw\output\editor\import_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, os.path.splitext(relative_file)[0])    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Import only doc.zip and docx.zip files    if file_type == &quot;zip&quot; and input_file.endswith((&quot;doc.zip&quot;, &quot;docx.zip&quot;,)):        editor.import_file(input_file, output_file)```---### RebuildSee [Editor](#editor) documentation. High level functionality is the same between the Editor and Rebuild classes, simply use the Rebuild class instead of the Editor class:```pyimport glasswall# Load the Glasswall Rebuild libraryrebuild = glasswall.Rebuild(r&quot;C:\gwpw\libraries\rebuild\1.661.0&quot;)# Use the default policy to sanitise a file, writing the sanitised file to a new pathrebuild.protect_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\rebuild\protect_f2f\TestFile_11.doc&quot;,)```---### Archive Manager##### Protect an archive```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default Archive Manager policy: sanitise all, process all, writing# the sanitised archive and the analysis report to the output directory.am.protect_archive(    input_file=r&quot;C:\gwpw\input_archives\7Zip\0000001.jpg.7z&quot;,    output_file=r&quot;C:\gwpw\output\archive_manager\protect_archive\7Zip\0000001.jpg.7z&quot;,    output_report=r&quot;C:\gwpw\output\archive_manager\protect_archive\7Zip\0000001.jpg.7z.xml&quot;)```##### Protect all archives in a directory using a custom content management policy```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Archive Manager policy: sanitise all, process all, but discard# mp3 and mp4 files. Write the sanitised archives and the analysis reports to# different directoriesam.protect_directory(    input_directory=r&quot;C:\gwpw\input_archives&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\protect_directory_custom&quot;,    output_report_directory=r&quot;C:\gwpw\output\archive_manager\protect_directory_custom_reports&quot;,    content_management_policy=glasswall.content_management.policies.ArchiveManager(        default=&quot;sanitise&quot;,        default_archive_manager=&quot;process&quot;,        config={            &quot;archiveConfig&quot;: {                &quot;mp3&quot;: &quot;discard&quot;,                &quot;mp4&quot;: &quot;discard&quot;            }        }    ),    raise_unsupported=False)```#### Extraction - Unpacking an archive```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Unpack the Nested_4_layers.zip archive to a new directoryam.unpack(    input_file=r&quot;C:\gwpw\input_archives\Nested_4_layers.zip&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\unpack&quot;)```A new directory is created: `C:\gwpw\output\archive_manager\unpack\Nested_4_layers` containing the unpacked contents of the `Nested_4_layers` zip archive. Nested archives are recursively unpacked while maintaining the same directory structure. To disable recursive unpacking use the `recursive` arg:```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Unpack the Nested_4_layers.zip archive to a new directory without recursing the archive.am.unpack(    input_file=r&quot;C:\gwpw\input_archives\Nested_4_layers.zip&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\unpack_nonrecursive&quot;,    recursive=False)```##### Other useful arguments when unpacking- `include_file_type` default False, keep the archive format in the directory name when unpacking. e.g. when True `Nested_4_layers.zip` will be unpacked to a directory `Nested_4_layers.zip` instead of `Nested_4_layers`. This can be necessary when unpacking multiple same-named archives that have different archive formats.- `raise_unsupported` default True, raise an error if the Glasswall library encounters an error.- `delete_origin` default False, delete the `input_file` after it has been unpacked to `output_directory`.#### Extraction - Unpacking a directory of archives```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Recursively unpack all archives found in the `archives` directoryam.unpack_directory(    input_directory=r&quot;C:\gwpw\input_archives&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\unpack_directory&quot;)```The `unpack_directory` method shares the same optional arguments as `unpack`. See also: `Extraction - Unpacking an archive`#### Compression - Packing a directory into an archive```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Pack the `input_archives` directory as zip to `input_archives.zip` in the 'C:\gwpw\output\archive_manager\pack' directoryam.pack_directory(    input_directory=r&quot;C:\gwpw\input_archives&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\pack&quot;,    file_type=&quot;zip&quot;,)```---### WordSearchGlasswall WordSearch can be used to redact text from files and generates an XML report on the redacted file's details.This report includes details on the file size, the determined file type, the total number of text matches, and the location of each of the text matches.&lt;details&gt;    &lt;summary&gt;Example report&lt;/summary&gt;```xml&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;&lt;gw:DocumentSummary&gt;&lt;gw:TotalSizeInBytes&gt;13084&lt;/gw:TotalSizeInBytes&gt;&lt;gw:FileType&gt;docx&lt;/gw:FileType&gt;&lt;gw:TotalItemMatchCount&gt;8&lt;/gw:TotalItemMatchCount&gt;&lt;/gw:DocumentSummary&gt;&lt;gw:WordItem&gt;&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;&lt;gw:ItemMatchCount&gt;5&lt;/gw:ItemMatchCount&gt;&lt;gw:Locations&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;120&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;267&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;691&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;973&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;1034&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;/gw:Locations&gt;&lt;/gw:WordItem&gt;&lt;gw:WordItem&gt;&lt;gw:Name&gt;lorem&lt;/gw:Name&gt;&lt;gw:ItemMatchCount&gt;3&lt;/gw:ItemMatchCount&gt;&lt;gw:Locations&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;114&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;244&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;1224&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;/gw:Locations&gt;&lt;/gw:WordItem&gt;&lt;/gw:WordSearchStatistics&gt;```&lt;/details&gt;A homoglyphs JSON file can be specified either as a file path or in memory as bytes, bytearray, or io.BytesIO. If this is not specified then the default will be used:&lt;details&gt;    &lt;summary&gt;Default homoglyphs.json file&lt;/summary&gt;```json{&quot;!&quot;: &quot;Çƒâµ‘&quot;,&quot;$&quot;: &quot;ï¼„&quot;,&quot;%&quot;: &quot;ï¼…&quot;,&quot;&amp;&quot;: &quot;ê¸ï¼†&quot;,&quot;'&quot;: &quot;`Â´Ê¹Ê»Ê¼Ê½Ê¾ËˆËŠË‹Ë´Í´Î„ÕšÕ×™×³ß´ßµá‘Šá›Œá¾½á¾¿á¿¯á¿½á¿¾â€˜â€™â€›â€²â€µêŒï¼‡ï½€ğ–½‘ğ–½’&quot;,&quot;(&quot;: &quot;â¨â²ã€”ï´¾ï¼ˆï¼»&quot;,&quot;)&quot;: &quot;â©â³ã€•ï´¿ï¼‰ï¼½&quot;,&quot;*&quot;: &quot;Ù­ââˆ—ï¼ŠğŒŸ&quot;,&quot;+&quot;: &quot;á›­ï¼‹ğŠ›&quot;,&quot;,&quot;: &quot;Â¸ØÙ«â€šê“¹ï¼Œ&quot;,&quot;-&quot;: &quot;Ë—Û”â€â€‘â€’â€“âƒâˆ’â–â²ºï¹˜&quot;,&quot;.&quot;: &quot;Ù Û°ÜÜ‚â€¤ê“¸ê˜ï¼ğ©ğ…­&quot;,&quot;/&quot;: &quot;áœµââ„âˆ•â•±âŸ‹â§¸â³†â¼ƒã€³ãƒã‡“ä¸¿ï¼ğˆº&quot;,&quot;0&quot;: &quot;OoÎŸÎ¿ÏƒĞĞ¾Õ•Ö…×¡Ù‡Ù¥Ú¾ÛÛ•Ûµß€à¥¦à§¦à©¦à«¦à¬ à­¦à¯¦à°‚à±¦à²‚à³¦à´‚à´ àµ¦à¶‚à¹à»á€á€áƒ¿á‹á´á´‘â„´â²â²Ÿâµ”ã€‡ê“³ê¬½ï®¦ï®§ï®¨ï®©ï®ªï®«ï®¬ï®­ï»©ï»ªï»«ï»¬ï¼ï¼¯ï½ğŠ’ğŠ«ğ„ğ¬ğ“‚ğ“ªğ”–ğ‘“ğ‘¢µğ‘£ˆğ‘£—ğ‘£ ğğ¨ğ‘‚ğ‘œğ‘¶ğ’ğ’ªğ“ğ“¸ğ”’ğ”¬ğ•†ğ• ğ•ºğ–”ğ–®ğ—ˆğ—¢ğ—¼ğ˜–ğ˜°ğ™Šğ™¤ğ™¾ğš˜ğš¶ğ›ğ›”ğ›°ğœŠğœğœªğ„ğˆğ¤ğ¾ğ‚ğğ¸ğ¼ğŸğŸ˜ğŸ¢ğŸ¬ğŸ¶ğ¸¤ğ¹¤ğº„&quot;,&quot;1&quot;: &quot;Il|Æ–Ç€Î™Ğ†Ó€×€×•×ŸØ§Ù¡Û±ßŠá›â„â„‘â„“â… â…¼âˆ£â½â²’âµê“²ïºïºï¼‘ï¼©ï½Œï¿¨ğŠŠğŒ‰ğŒ ğ–¼¨ğˆğ¥ğ¼ğ‘™ğ‘°ğ’ğ“ğ“˜ğ“µğ”©ğ•€ğ•ğ•´ğ–‘ğ–¨ğ—…ğ—œğ—¹ğ˜ğ˜­ğ™„ğ™¡ğ™¸ğš•ğš°ğ›ªğœ¤ğğ˜ğŸğŸ™ğŸ£ğŸ­ğŸ·ğ£‡ğ¸€ğº€&quot;,&quot;2&quot;: &quot;Æ§Ï¨á’¿ê™„ê›¯êšï¼’ğŸğŸšğŸ¤ğŸ®ğŸ¸&quot;,&quot;3&quot;: &quot;Æ·ÈœĞ—Ó â³Œêªê«ï¼“ğ‘£Šğ–¼»ğˆ†ğŸ‘ğŸ›ğŸ¥ğŸ¯ğŸ¹&quot;,&quot;4&quot;: &quot;áï¼”ğ‘¢¯ğŸ’ğŸœğŸ¦ğŸ°ğŸº&quot;,&quot;5&quot;: &quot;Æ¼ï¼•ğ‘¢»ğŸ“ğŸğŸ§ğŸ±ğŸ»&quot;,&quot;6&quot;: &quot;Ğ±á®â³’ï¼–ğ‘£•ğŸ”ğŸğŸ¨ğŸ²ğŸ¼&quot;,&quot;7&quot;: &quot;ï¼—ğ“’ğ‘£†ğˆ’ğŸ•ğŸŸğŸ©ğŸ³ğŸ½&quot;,&quot;8&quot;: &quot;È¢È£à§ªà©ªà¬ƒï¼˜ğŒšğŸ–ğŸ ğŸªğŸ´ğŸ¾ğ£‹&quot;,&quot;9&quot;: &quot;à§­à©§à­¨àµ­â³Šê®ï¼™ğ‘¢¬ğ‘£Œğ‘£–ğŸ—ğŸ¡ğŸ«ğŸµğŸ¿&quot;,&quot;A&quot;: &quot;4Î‘Ğáªá—…á´€ê“®ê­ºï¼¡ğŠ ğ–½€ğ€ğ´ğ‘¨ğ’œğ“ğ”„ğ”¸ğ•¬ğ– ğ—”ğ˜ˆğ˜¼ğ™°ğš¨ğ›¢ğœœğ–ğ&quot;,&quot;B&quot;: &quot;Ê™Î’Ğ’Ğ²á´á¼á—·á›’â„¬ê“ê´ï¼¢ğŠ‚ğŠ¡ğŒğğµğ‘©ğ“‘ğ”…ğ”¹ğ•­ğ–¡ğ—•ğ˜‰ğ˜½ğ™±ğš©ğ›£ğœğ—ğ‘&quot;,&quot;C&quot;: &quot;Ï¹Ğ¡áŸâ„‚â„­â…­â²¤ê“šï¼£ğŠ¢ğŒ‚ğ•ğ”œğ‘£©ğ‘£²ğ‚ğ¶ğ‘ªğ’ğ“’ğ•®ğ–¢ğ—–ğ˜Šğ˜¾ğ™²ğŸŒ&quot;,&quot;D&quot;: &quot;á á—á—ªá´…â……â…®ê““ê­°ï¼¤ğƒğ·ğ‘«ğ’Ÿğ““ğ”‡ğ”»ğ•¯ğ–£ğ——ğ˜‹ğ˜¿ğ™³&quot;,&quot;E&quot;: &quot;Î•Ğ•á¬á´‡â„°â‹¿â´¹ê“°ê­¼ï¼¥ğŠ†ğ‘¢¦ğ‘¢®ğ„ğ¸ğ‘¬ğ“”ğ”ˆğ”¼ğ•°ğ–¤ğ—˜ğ˜Œğ™€ğ™´ğš¬ğ›¦ğœ ğšğ”&quot;,&quot;F&quot;: &quot;Ïœá–´â„±ê“ê˜ï¼¦ğŠ‡ğŠ¥ğ”¥ğ‘¢¢ğ‘£‚ğˆ“ğ…ğ¹ğ‘­ğ“•ğ”‰ğ”½ğ•±ğ–¥ğ—™ğ˜ğ™ğ™µğŸŠ&quot;,&quot;G&quot;: &quot;É¢ÔŒÔá€á³á»ê“–ê®ï¼§ğ†ğºğ‘®ğ’¢ğ“–ğ”Šğ”¾ğ•²ğ–¦ğ—šğ˜ğ™‚ğ™¶&quot;,&quot;H&quot;: &quot;ÊœÎ—ĞĞ½á»á•¼â„‹â„Œâ„â²ê“§ê®‹ï¼¨ğ‹ğ‡ğ»ğ‘¯ğ“—ğ•³ğ–§ğ—›ğ˜ğ™ƒğ™·ğš®ğ›¨ğœ¢ğœğ–&quot;,&quot;I&quot;: &quot;&quot;,&quot;J&quot;: &quot;Í¿Ğˆá«á’á´Šê“™ê²ê­»ï¼ªğ‰ğ½ğ‘±ğ’¥ğ“™ğ”ğ•ğ•µğ–©ğ—ğ˜‘ğ™…ğ™¹&quot;,&quot;K&quot;: &quot;ÎšĞšá¦á›•â„ªâ²”ê“—ï¼«ğ”˜ğŠğ¾ğ‘²ğ’¦ğ“šğ”ğ•‚ğ•¶ğ–ªğ—ğ˜’ğ™†ğ™ºğš±ğ›«ğœ¥ğŸğ™&quot;,&quot;L&quot;: &quot;ÊŸáá’ªâ„’â…¬â³â³‘ê“¡ê®®ï¼¬ğ›ğ‘ƒğ”¦ğ‘¢£ğ‘¢²ğ–¼–ğˆªğ‹ğ¿ğ‘³ğ“›ğ”ğ•ƒğ•·ğ–«ğ—Ÿğ˜“ğ™‡ğ™»&quot;,&quot;M&quot;: &quot;ÎœÏºĞœá·á—°á›–â„³â…¯â²˜ê“Ÿï¼­ğŠ°ğŒ‘ğŒğ‘€ğ‘´ğ“œğ”ğ•„ğ•¸ğ–¬ğ— ğ˜”ğ™ˆğ™¼ğš³ğ›­ğœ§ğ¡ğ›&quot;,&quot;N&quot;: &quot;É´Îâ„•â²šê“ ï¼®ğ”“ğğ‘ğ‘µğ’©ğ“ğ”‘ğ•¹ğ–­ğ—¡ğ˜•ğ™‰ğ™½ğš´ğ›®ğœ¨ğ¢ğœ&quot;,&quot;O&quot;: &quot;0&quot;,&quot;P&quot;: &quot;Î¡Ğ á¢á‘­á´˜á´©â„™â²¢ê“‘ê®²ï¼°ğŠ•ğğ‘ƒğ‘·ğ’«ğ“Ÿğ”“ğ•»ğ–¯ğ—£ğ˜—ğ™‹ğ™¿ğš¸ğ›²ğœ¬ğ¦ğ &quot;,&quot;Q&quot;: &quot;â„šâµ•ï¼±ğğ‘„ğ‘¸ğ’¬ğ“ ğ””ğ•¼ğ–°ğ—¤ğ˜˜ğ™Œğš€&quot;,&quot;R&quot;: &quot;Æ¦Ê€á¡á’á–‡áš±â„›â„œâ„ê“£ê­±ê®¢ï¼²ğ’´ğ–¼µğˆ–ğ‘ğ‘…ğ‘¹ğ“¡ğ•½ğ–±ğ—¥ğ˜™ğ™ğš&quot;,&quot;S&quot;: &quot;$Ğ…Õá•ášê“¢ï¼³ğŠ–ğ ğ–¼ºğ’ğ‘†ğ‘ºğ’®ğ“¢ğ”–ğ•Šğ•¾ğ–²ğ—¦ğ˜šğ™ğš‚&quot;,&quot;T&quot;: &quot;Å¤Î¤Ï„Ğ¢Ñ‚á¢á´›âŠ¤âŸ™â²¦ê“”ê­²ï¼´ğŠ—ğŠ±ğŒ•ğ‘¢¼ğ–¼Šğ“ğ‘‡ğ‘»ğ’¯ğ“£ğ”—ğ•‹ğ•¿ğ–³ğ—§ğ˜›ğ™ğšƒğš»ğ›•ğ›µğœğœ¯ğ‰ğ©ğƒğ£ğ½ğŸ¨&quot;,&quot;U&quot;: &quot;Õáˆ€á‘Œâˆªâ‹ƒê“´ï¼µğ“ğ‘¢¸ğ–½‚ğ”ğ‘ˆğ‘¼ğ’°ğ“¤ğ”˜ğ•Œğ–€ğ–´ğ—¨ğ˜œğ™ğš„&quot;,&quot;V&quot;: &quot;Ñ´Ù§Û·á™á¯â…¤â´¸ê“¦ê›Ÿï¼¶ğ”ğ‘¢ ğ–¼ˆğˆğ•ğ‘‰ğ‘½ğ’±ğ“¥ğ”™ğ•ğ–ğ–µğ—©ğ˜ğ™‘ğš…&quot;,&quot;W&quot;: &quot;Ôœá³á”ê“ªï¼·ğ‘£¦ğ‘£¯ğ–ğ‘Šğ‘¾ğ’²ğ“¦ğ”šğ•ğ–‚ğ–¶ğ—ªğ˜ğ™’ğš†&quot;,&quot;X&quot;: &quot;Î§Ğ¥á™­áš·â…©â•³â²¬âµê“«ê³ï¼¸ğŠğŠ´ğŒ—ğŒ¢ğ”§ğ‘£¬ğ—ğ‘‹ğ‘¿ğ’³ğ“§ğ”›ğ•ğ–ƒğ–·ğ—«ğ˜Ÿğ™“ğš‡ğš¾ğ›¸ğœ²ğ¬ğ¦&quot;,&quot;Y&quot;: &quot;Î¥Ï’Ğ£Ò®á©á½â²¨ê“¬ï¼¹ğŠ²ğ‘¢¤ğ–½ƒğ˜ğ‘Œğ’€ğ’´ğ“¨ğ”œğ•ğ–„ğ–¸ğ—¬ğ˜ ğ™”ğšˆğš¼ğ›¶ğœ°ğªğ¤&quot;,&quot;Z&quot;: &quot;Î–áƒâ„¤â„¨ê“œï¼ºğ‹µğ‘¢©ğ‘£¥ğ™ğ‘ğ’ğ’µğ“©ğ–…ğ–¹ğ—­ğ˜¡ğ™•ğš‰ğš­ğ›§ğœ¡ğ›ğ•&quot;,&quot;a&quot;: &quot;@É‘Î±Ğ°âºï½ğšğ‘ğ’‚ğ’¶ğ“ªğ”ğ•’ğ–†ğ–ºğ—®ğ˜¢ğ™–ğšŠğ›‚ğ›¼ğœ¶ğ°ğª&quot;,&quot;b&quot;: &quot;Æ„Ğ¬áá–¯ï½‚ğ›ğ‘ğ’ƒğ’·ğ“«ğ”Ÿğ•“ğ–‡ğ–»ğ—¯ğ˜£ğ™—ğš‹&quot;,&quot;c&quot;: &quot;Ï²Ñá´„â…½â²¥ê®¯ï½ƒğ½ğœğ‘ğ’„ğ’¸ğ“¬ğ” ğ•”ğ–ˆğ–¼ğ—°ğ˜¤ğ™˜ğšŒ&quot;,&quot;d&quot;: &quot;Ôá§á‘¯â…†â…¾ê“’ï½„ğğ‘‘ğ’…ğ’¹ğ“­ğ”¡ğ••ğ–‰ğ–½ğ—±ğ˜¥ğ™™ğš&quot;,&quot;e&quot;: &quot;ĞµÒ½â„®â„¯â…‡ê¬²ï½…ğğ‘’ğ’†ğ“®ğ”¢ğ•–ğ–Šğ–¾ğ—²ğ˜¦ğ™šğš&quot;,&quot;f&quot;: &quot;Å¿ÏÖ„áºê™ê¬µï½†ğŸğ‘“ğ’‡ğ’»ğ“¯ğ”£ğ•—ğ–‹ğ–¿ğ—³ğ˜§ğ™›ğšğŸ‹&quot;,&quot;g&quot;: &quot;ÆÉ¡Öá¶ƒâ„Šï½‡ğ ğ‘”ğ’ˆğ“°ğ”¤ğ•˜ğ–Œğ—€ğ—´ğ˜¨ğ™œğš&quot;,&quot;h&quot;: &quot;Ò»Õ°á‚â„ï½ˆğ¡ğ’‰ğ’½ğ“±ğ”¥ğ•™ğ–ğ—ğ—µğ˜©ğ™ğš‘&quot;,&quot;i&quot;: &quot;Ä±É©ÉªË›ÍºÎ¹Ñ–Óá¥á¾¾â„¹â…ˆâ…°â³ê™‡ê­µï½‰ğ‘£ƒğ¢ğ‘–ğ’Šğ’¾ğ“²ğ”¦ğ•šğ–ğ—‚ğ—¶ğ˜ªğ™ğš’ğš¤ğ›Šğœ„ğœ¾ğ¸ğ²&quot;,&quot;j&quot;: &quot;Ï³Ñ˜â…‰ï½Šğ£ğ‘—ğ’‹ğ’¿ğ“³ğ”§ğ•›ğ–ğ—ƒğ—·ğ˜«ğ™Ÿğš“&quot;,&quot;k&quot;: &quot;ï½‹ğ¤ğ‘˜ğ’Œğ“€ğ“´ğ”¨ğ•œğ–ğ—„ğ—¸ğ˜¬ğ™ ğš”&quot;,&quot;l&quot;: &quot;1&quot;,&quot;m&quot;: &quot;ï½&quot;,&quot;n&quot;: &quot;Õ¸Õ¼ï½ğ§ğ‘›ğ’ğ“ƒğ“·ğ”«ğ•Ÿğ–“ğ—‡ğ—»ğ˜¯ğ™£ğš—&quot;,&quot;o&quot;: &quot;&quot;,&quot;p&quot;: &quot;ÏÏ±Ñ€â´â²£ï½ğ©ğ‘ğ’‘ğ“…ğ“¹ğ”­ğ•¡ğ–•ğ—‰ğ—½ğ˜±ğ™¥ğš™ğ›’ğ› ğœŒğœšğ†ğ”ğ€ğğºğŸˆ&quot;,&quot;q&quot;: &quot;Ô›Õ£Õ¦ï½‘ğªğ‘ğ’’ğ“†ğ“ºğ”®ğ•¢ğ––ğ—Šğ—¾ğ˜²ğ™¦ğšš&quot;,&quot;r&quot;: &quot;Ğ³á´¦â²…ê­‡ê­ˆê®ï½’ğ«ğ‘Ÿğ’“ğ“‡ğ“»ğ”¯ğ•£ğ–—ğ—‹ğ—¿ğ˜³ğ™§ğš›&quot;,&quot;s&quot;: &quot;$Æ½Ñ•êœ±ê®ªï½“ğ‘ˆğ‘£ğ¬ğ‘ ğ’”ğ“ˆğ“¼ğ”°ğ•¤ğ–˜ğ—Œğ˜€ğ˜´ğ™¨ğšœ&quot;,&quot;t&quot;: &quot;ï½”ğ­ğ‘¡ğ’•ğ“‰ğ“½ğ”±ğ•¥ğ–™ğ—ğ˜ğ˜µğ™©ğš&quot;,&quot;u&quot;: &quot;Ê‹Ï…Õ½á´œêŸê­ê­’ï½•ğ“¶ğ‘£˜ğ®ğ‘¢ğ’–ğ“Šğ“¾ğ”²ğ•¦ğ–šğ—ğ˜‚ğ˜¶ğ™ªğšğ›–ğœğŠğ„ğ¾&quot;,&quot;v&quot;: &quot;Î½Ñµ×˜á´ â…´âˆ¨â‹ê®©ï½–ğ‘œ†ğ‘£€ğ¯ğ‘£ğ’—ğ“‹ğ“¿ğ”³ğ•§ğ–›ğ—ğ˜ƒğ˜·ğ™«ğšŸğ›ğœˆğ‚ğ¼ğ¶&quot;,&quot;w&quot;: &quot;É¯Ñ¡ÔÕ¡á´¡ê®ƒï½—ğ‘œŠğ‘œğ‘œğ°ğ‘¤ğ’˜ğ“Œğ”€ğ”´ğ•¨ğ–œğ—ğ˜„ğ˜¸ğ™¬ğš &quot;,&quot;x&quot;: &quot;Ã—Ñ…á•á•½á™®â…¹â¤«â¤¬â¨¯ï½˜ğ±ğ‘¥ğ’™ğ“ğ”ğ”µğ•©ğ–ğ—‘ğ˜…ğ˜¹ğ™­ğš¡&quot;,&quot;y&quot;: &quot;É£ÊÎ³ÑƒÒ¯áƒ§á¶Œá»¿â„½ê­šï½™ğ‘£œğ²ğ‘¦ğ’šğ“ğ”‚ğ”¶ğ•ªğ–ğ—’ğ˜†ğ˜ºğ™®ğš¢ğ›„ğ›¾ğœ¸ğ²ğ¬&quot;,&quot;z&quot;: &quot;á´¢ê®“ï½šğ‘£„ğ³ğ‘§ğ’›ğ“ğ”ƒğ”·ğ•«ğ–Ÿğ—“ğ˜‡ğ˜»ğ™¯ğš£&quot;,&quot;Â£&quot;: &quot;â‚¤&quot;,&quot;Â©&quot;: &quot;â’¸&quot;,&quot;Â®&quot;: &quot;â“‡&quot;}```&lt;/details&gt;#### RedactFiles can be redacted individually from a file path or in memory using the [`redact_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/word_search/word_search.html#glasswall.libraries.word_search.word_search.WordSearch.redact_file) method, or all files from a directory can be redacted using the [`redact_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/word_search/word_search.html#glasswall.libraries.word_search.word_search.WordSearch.redact_directory) method.##### Redact from file path to file path```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new pathword_search.redact_file(    input_file=r&quot;C:\gwpw\input_redact\lorem_ipsum.docx&quot;,    output_file=r&quot;C:\gwpw\output\word_search\redact_f2f\lorem_ipsum.docx&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))```##### Redact from file path to memory`redact_file` returns an object with the attributes: &quot;status&quot; (int), &quot;output_file&quot; (bytes), &quot;output_report&quot; (bytes). The below example demonstrates assigning the variable `result` and checking the contents of the beginning of the redacted output_file and the output_report.```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new pathresult = word_search.redact_file(    input_file=r&quot;C:\gwpw\input_redact\lorem_ipsum.docx&quot;,    output_file=None,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))assert result.output_file[:6] == b'PK\x03\x04\x14\x00'assert result.output_report[:500] == b'&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentSummary&gt;\n\t\t&lt;gw:TotalSizeInBytes&gt;14292&lt;/gw:TotalSizeInBytes&gt;\n\t\t&lt;gw:FileType&gt;docx&lt;/gw:FileType&gt;\n\t\t&lt;gw:TotalItemMatchCount&gt;14&lt;/gw:TotalItemMatchCount&gt;\n\t&lt;/gw:DocumentSummary&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;8&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t\t&lt;gw:Offset&gt;120&lt;/gw:Offset&gt;\n\t\t\t\t&lt;gw:Page&gt;0&lt;/gw:Page&gt;\n\t\t\t\t&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;\n\t\t\t&lt;/gw:Location&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t'```##### Redact from memory```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input_redact\lorem_ipsum.docx&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new pathresult = word_search.redact_file(    input_file=input_bytes,    output_file=r&quot;C:\gwpw\output\word_search\redact_m2f\lorem_ipsum.docx&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))assert result.output_file[:6] == b'PK\x03\x04\x14\x00'assert result.output_report[:500] == b'&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentSummary&gt;\n\t\t&lt;gw:TotalSizeInBytes&gt;14292&lt;/gw:TotalSizeInBytes&gt;\n\t\t&lt;gw:FileType&gt;docx&lt;/gw:FileType&gt;\n\t\t&lt;gw:TotalItemMatchCount&gt;14&lt;/gw:TotalItemMatchCount&gt;\n\t&lt;/gw:DocumentSummary&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;8&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t\t&lt;gw:Offset&gt;120&lt;/gw:Offset&gt;\n\t\t\t\t&lt;gw:Page&gt;0&lt;/gw:Page&gt;\n\t\t\t\t&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;\n\t\t\t&lt;/gw:Location&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t'```##### Redact files in a directory`redact_directory` returns a dictionary of file paths relative to the input_directory, and an object with the attributes: &quot;status&quot; (int), &quot;output_file&quot; (bytes), &quot;output_report&quot; (bytes). The below example demonstrates assigning the variable `results` and checking the keys and values of the `results` dictionary.```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within each file in the input_directory, writing the redacted file# to a new path in the output_directoryresults = word_search.redact_directory(    input_directory=r&quot;C:\gwpw\input_redact&quot;,    output_directory=r&quot;C:\gwpw\output\word_search\redact_directory&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))assert list(results.keys()) == ['lorem_ipsum.docx', 'lorem_ipsum.pptx']assert all(result.status == 1 for result in results.values())```##### Redact files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.word_search.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/word_search/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.The below example input directory contains the same two files in the above example as well as a file with an unsupported file format: `python-package.yml`. We can inspect the key value pairs in the `results` dictionary and see that the object returned for the `python-package.yml` file returned a `status: 0`, a failure. The `output_file` attribute is empty bytes, and the `output_report` bytes is populated with a report that includes an `IssueItem` describing the problems encountered while attempting to redact the file: `File contents could not be accessed`.```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within each file in the input_directory, writing the redacted file# to a new path in the output_directoryresults = word_search.redact_directory(    input_directory=r&quot;C:\gwpw\input_redact_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\word_search\redact_directory_unsupported&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ),    raise_unsupported=False)assert list(results.keys()) == [&quot;lorem_ipsum.docx&quot;, &quot;lorem_ipsum.pptx&quot;, &quot;python-package.yml&quot;]assert [result.status for result in results.values()] == [1, 1, 0]print(results[&quot;python-package.yml&quot;].__dict__)# {'status': 0,# 'output_file': b'',# 'output_report': b'&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:IssueItem&gt;\n\t\t&lt;gw:Description&gt;File contents could not be accessed&lt;/gw:Description&gt;\n\t&lt;/gw:IssueItem&gt;\n\t&lt;gw:DocumentSummary&gt;\n\t\t&lt;gw:TotalSizeInBytes&gt;1460&lt;/gw:TotalSizeInBytes&gt;\n\t\t&lt;gw:FileType&gt;Unknown&lt;/gw:FileType&gt;\n\t\t&lt;gw:TotalItemMatchCount&gt;0&lt;/gw:TotalItemMatchCount&gt;\n\t&lt;/gw:DocumentSummary&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;0&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations/&gt;\n\t&lt;/gw:WordItem&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;lorem&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;0&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations/&gt;\n\t&lt;/gw:WordItem&gt;\n&lt;/gw:WordSearchStatistics&gt;\n\n'}```##### Redact files in a directory conditionally based on file formatThe example below demonstrates redacting of only docx and pptx files from a directory that also contains other unsupported file types.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input_redact_with_unsupported_file_types&quot;output_directory = r&quot;C:\gwpw\output\word_search\redact_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Protect only doc and docx files    if file_type in [&quot;docx&quot;, &quot;pptx&quot;]:        # Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new path        word_search.redact_file(            input_file=input_file,            output_file=output_file,            content_management_policy=glasswall.content_management.policies.WordSearch(                config={                    &quot;textSearchConfig&quot;: {                        &quot;@libVersion&quot;: &quot;core2&quot;,                        &quot;textList&quot;: [                            {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                                {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                                {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                            ]},                            {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                                {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                                {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                            ]},                        ]                    }                }            )        )```</longdescription>
</pkgmetadata>