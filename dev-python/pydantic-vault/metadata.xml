<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pydantic-Vault[![PyPI](https://img.shields.io/pypi/v/pydantic-vault)](https://pypi.org/project/pydantic-vault/)[![Check code](https://github.com/nymous/pydantic-vault/workflows/Check%20code/badge.svg)](https://github.com/nymous/pydantic-vault/actions/workflows/check_code.yml)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)A simple extension to [Pydantic][pydantic] [BaseSettings][pydantic-basesettings] that can retrieve secrets stored in Hashicorp [Vault][vault]With Pydantic and Pydantic-Vault, you can easily declare your configuration in a type-hinted class, and load configurationfrom environment variables or Vault secrets. Pydantic-Vault will work the same when developing locally (where you probablylogin with the Vault CLI and your own user account) and when deploying in production (using a Vault Approle or Kubernetesauthentication for example).&lt;!-- toc --&gt;- [Installation](#installation)- [Getting started](#getting-started)- [Documentation](#documentation)  * [`Field` additional parameters](#field-additional-parameters)  * [Configuration](#configuration)  * [Authentication](#authentication)    + [Approle](#approle)    + [Kubernetes](#kubernetes)    + [Vault token](#vault-token)  * [Order of priority](#order-of-priority)- [Logging](#logging)- [Examples](#examples)  * [Retrieve a secret from a KV v2 secret engine](#retrieve-a-secret-from-a-kv-v2-secret-engine)  * [Retrieve a whole secret at once](#retrieve-a-whole-secret-at-once)  * [Retrieve a secret from a KV v1 secret engine](#retrieve-a-secret-from-a-kv-v1-secret-engine)  * [Retrieve a secret from a database secret engine](#retrieve-a-secret-from-a-database-secret-engine)  * [Use a dynamic path to retrieve secrets](#use-a-dynamic-path-to-retrieve-secrets)- [Known limitations](#known-limitations)- [Inspirations](#inspirations)- [License](#license)&lt;!-- tocstop --&gt;## Installation```shellpip install pydantic-vault# or if you use Poetry or Pipenvpoetry add pydantic-vaultpipenv install pydantic-vault```## Getting startedWith [Pydantic][pydantic] [`BaseSettings`][pydantic-basesettings] class, you can easily &quot;create a clearly-defined, type-hintedapplication configuration class&quot; that gets its configuration from environment variables. Starting with Pydantic 1.8,[custom settings sources][pydantic-basesettings-customsource] are officially supported. This is where Pydantic-Vault stepsin, allowing you to load configuration values from Hashicorp Vault secrets. It will work the same when developing locally(where you probably login with the Vault CLI and your own user account) and when deploying in production (using a VaultApprole or Kubernetes authentication for example).You can create a normal `BaseSettings` class, and define the `customise_sources()` method to load secrets from your Vault instance using the `vault_config_settings_source` function:```pythonimport osfrom pydantic import BaseSettings, Field, SecretStrfrom pydantic_vault import vault_config_settings_sourceclass Settings(BaseSettings):    # The `vault_secret_path` is the full path (with mount point included) to the secret    # The `vault_secret_key` is the specific key to extract from a secret    username: str = Field(        ..., vault_secret_path=&quot;secret/data/path/to/secret&quot;, vault_secret_key=&quot;my_user&quot;    )    password: SecretStr = Field(        ...,        vault_secret_path=&quot;secret/data/path/to/secret&quot;,        vault_secret_key=&quot;my_password&quot;,    )    class Config:        vault_url: str = &quot;https://vault.tld&quot;        vault_token: SecretStr = os.environ[&quot;VAULT_TOKEN&quot;]        vault_namespace: str = &quot;your/namespace&quot;  # Optional, pydantic-vault supports Vault namespaces (for Vault Enterprise)        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            # This is where you can choose which settings sources to use and their priority            return (                init_settings,                env_settings,                vault_config_settings_source,                file_secret_settings,            )settings = Settings()# These variables will come from the Vault secret you configuredsettings.usernamesettings.password.get_secret_value()# Now let's pretend we have already set the USERNAME in an environment variable# (see the Pydantic documentation for more information and to know how to configure it)# With the priority order we defined above, its value will override the Vault secretos.environ[&quot;USERNAME&quot;] = &quot;my user&quot;settings = Settings()settings.username  # &quot;my user&quot;, defined in the environment variablesettings.password.get_secret_value()  # the value set in Vault```## Documentation### `Field` additional parametersYou might have noticed that we import `Field` directly from Pydantic. Pydantic-Vault doesn't add any custom logic to it, which means you can still use everything you know and love from Pydantic.The additional parameters Pydantic-Vault uses are:| Parameter name              | Required | Description ||-----------------------------|----------|-------------|| `vault_secret_path`         | **Yes**  | The path to your secret in Vault&lt;br&gt;This needs to be the *full path* to the secret, including its mount point (see [examples](#examples) below) || `vault_secret_key`          | No       | The key to use in the secret&lt;br&gt;If it is not specified the whole secret content will be loaded as a dict (see [examples](#examples) below) |For example, if you create a secret `database/prod` with a key `password` and a value of `a secret password` in a KV v2 secret engine mounted at the default `secret/` location, you would access it with```pythonpassword: SecretStr = Field(    ..., vault_secret_path=&quot;secret/data/database/prod&quot;, vault_secret_key=&quot;password&quot;)```### ConfigurationYou can configure the behaviour of Pydantic-vault in your `Settings.Config` class, or using environment variables:| Settings name              | Required | Environment variable | Description ||----------------------------|----------|----------------------|-------------|| `customise_sources()`      | **Yes**  | N/A                  | You need to implement this function to use Vault as a settings source, and choose the priority order you want || `vault_url`                | **Yes**  | `VAULT_ADDR`         | Your Vault URL || `vault_namespace`          | No       | `VAULT_NAMESPACE`    | Your Vault namespace (if you use one, requires Vault Enterprise) || `vault_auth_mount_point`   | No       | `VAULT_AUTH_MOUNT_POINT` | The mount point of the authentication method, if different from its default mount point |You can also configure everything available in the original Pydantic `BaseSettings` class.### AuthenticationPydantic-Vault supports the following authentication method (in descending order of priority):  - [direct token authentication][vault-auth-token]  - [kubernetes][vault-auth-kubernetes]  - [approle][vault-auth-approle]Pydantic-Vault tries to be transparent and help you work, both during local development and in production. It will try tofind the required information for the first authentication method, if it can't it goes on to the next method, until ithas exhausted all authentication methods. In this case it gives up and logs the failure.You only need to know this order of priority if you specify the authentication parameters for multiple methods.Support is planned for GKE authentication methods.#### ApproleTo authenticate using the [Approle auth method][vault-auth-approle], you need to pass a role ID and a secret ID to your Settings class.Pydantic-vault reads this information from the following sources (in descending order of priority):  - the `vault_role_id` and `vault_secret_id` configuration fields in your `Settings.Config` class (`vault_secret_id` can be a `str` or a `SecretStr`)  - the `VAULT_ROLE_ID` and `VAULT_SECRET_ID` environment variablesYou can also mix-and-match, e.g. write the role ID in your `Settings.Config` class and retrieve the secret ID from the environment at runtime.Example:```pythonfrom pydantic import BaseSettings, Field, SecretStrfrom pydantic_vault import vault_config_settings_sourceclass Settings(BaseSettings):    username: str = Field(        ..., vault_secret_path=&quot;path/to/secret&quot;, vault_secret_key=&quot;my_user&quot;    )    password: SecretStr = Field(        ..., vault_secret_path=&quot;path/to/secret&quot;, vault_secret_key=&quot;my_password&quot;    )    class Config:        vault_url: str = &quot;https://vault.tld&quot;        vault_role_id: str = &quot;my-role-id&quot;        vault_secret_id: SecretStr = SecretStr(&quot;my-secret-id&quot;)        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            return (                init_settings,                env_settings,                vault_config_settings_source,                file_secret_settings,            )```#### KubernetesTo authenticate using the [Kubernetes auth method][vault-auth-kubernetes], you need to pass a role to your Settings class.Pydantic-vault reads this information from the following sources (in descending order of priority):  - the `vault_kubernetes_role` configuration field in your `Settings.Config` class, which must be a `str`  - the `VAULT_KUBERNETES_ROLE` environment variableThe Kubernetes service account token will be read from the file at `/var/run/secrets/kubernetes.io/serviceaccount/token`.Example:```pythonfrom pydantic import BaseSettings, Field, SecretStrfrom pydantic_vault import vault_config_settings_sourceclass Settings(BaseSettings):    username: str = Field(        ..., vault_secret_path=&quot;path/to/secret&quot;, vault_secret_key=&quot;my_user&quot;    )    password: SecretStr = Field(        ..., vault_secret_path=&quot;path/to/secret&quot;, vault_secret_key=&quot;my_password&quot;    )    class Config:        vault_url: str = &quot;https://vault.tld&quot;        vault_kubernetes_role: str = &quot;my-role&quot;        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            return (                init_settings,                env_settings,                vault_config_settings_source,                file_secret_settings,            )```#### Vault tokenTo authenticate using the [Token auth method][vault-auth-token], you need to pass a Vault token to your `Settings` class.Pydantic-vault reads this token from the following sources (in descending order of priority):  - the `vault_token` configuration field in your `Settings.Config` class, which can be a `str` or a `SecretStr`  - the `VAULT_TOKEN` environment variable  - the `~/.vault-token` file (so you can use the `vault` CLI to login locally, Pydantic-vault will transparently reuse its token)Example:```pythonfrom pydantic import BaseSettings, Field, SecretStrfrom pydantic_vault import vault_config_settings_sourceclass Settings(BaseSettings):    username: str = Field(        ..., vault_secret_path=&quot;path/to/secret&quot;, vault_secret_key=&quot;my_user&quot;    )    password: SecretStr = Field(        ..., vault_secret_path=&quot;path/to/secret&quot;, vault_secret_key=&quot;my_password&quot;    )    class Config:        vault_url: str = &quot;https://vault.tld&quot;        vault_token: SecretStr = SecretStr(&quot;my-secret-token&quot;)        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            return (                init_settings,                env_settings,                vault_config_settings_source,                file_secret_settings,            )```### Order of priorityThanks to the new feature in Pydantic 1.8 that allows you to [customize settings sources][pydantic-basesettings-customsource], you can choose the order of priority you want.Here are some examples:```pythonfrom pydantic import BaseSettingsfrom pydantic_vault import vault_config_settings_sourceclass Settings(BaseSettings):    &quot;&quot;&quot;    In descending order of priority:      - arguments passed to the `Settings` class initializer      - environment variables      - Vault variables      - variables loaded from the secrets directory, such as Docker Secrets      - the default field values for the `Settings` model    &quot;&quot;&quot;    class Config:        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            return (                init_settings,                env_settings,                vault_config_settings_source,                file_secret_settings,            )class Settings(BaseSettings):    &quot;&quot;&quot;    In descending order of priority:      - Vault variables      - environment variables      - variables loaded from the secrets directory, such as Docker Secrets      - the default field values for the `Settings` model    Here we chose to remove the &quot;init arguments&quot; source,    and move the Vault source up before the environment source    &quot;&quot;&quot;    class Config:        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            return (vault_config_settings_source, env_settings, file_secret_settings)```## LoggingThe library exports a logger called `pydantic-vault`.To help debugging you can change the log level. A simple way to do that if you do not have a custom log setup is:```py# At the beginning of your main file or entrypointimport logginglogging.basicConfig()logging.getLogger(&quot;pydantic-vault&quot;).setLevel(logging.DEBUG)  # Change the log level here```## ExamplesAll examples use the following structure, so we will omit the imports and the `Config` inner class:```pythonfrom pydantic import BaseSettings, Field, SecretStrfrom pydantic_vault import vault_config_settings_sourceclass Settings(BaseSettings):    ###############################################    # THIS PART CHANGES IN THE DIFFERENT EXAMPLES #    username: str = Field(        ..., vault_secret_path=&quot;secret/data/path/to/secret&quot;, vault_secret_key=&quot;my_user&quot;    )    ###############################################    class Config:        vault_url: str = &quot;https://vault.tld&quot;        @classmethod        def customise_sources(            cls,            init_settings,            env_settings,            file_secret_settings,        ):            return (                init_settings,                env_settings,                vault_config_settings_source,                file_secret_settings,            )```### Retrieve a secret from a KV v2 secret engineSuppose your secret is at `my-api/prod` and looks like this:```Key             Value---             -----root_user       rootroot_password   a_v3ry_s3cur3_p4ssw0rd```Your settings class would be:```pythonclass Settings(BaseSettings):    # The `vault_secret_path` is the full path (with mount point included) to the secret.    # For a KV v2 secret engine, there is always a `data/` sub-path between the mount point and    # the secret actual path, eg. if your mount point is `secret/` (the default) and your secret    # path is `my-api/prod`, the full path to use is `secret/data/my-api/prod`.    # The `vault_secret_key` is the specific key to extract from a secret.    username: str = Field(        ..., vault_secret_path=&quot;secret/data/my-api/prod&quot;, vault_secret_key=&quot;root_user&quot;    )    password: SecretStr = Field(        ...,        vault_secret_path=&quot;secret/data/my-api/prod&quot;,        vault_secret_key=&quot;root_password&quot;,    )settings = Settings()settings.username  # &quot;root&quot;settings.password.get_secret_value()  # &quot;a_v3ry_s3cur3_p4ssw0rd&quot;```### Retrieve a whole secret at onceIf you omit the `vault_secret_key` parameter in your `Field`, Pydantic-Vault will loadthe whole secret in your class field.With the same secret as before, located at `my-api/prod` and with this data:```Key             Value---             -----root_user       rootroot_password   a_v3ry_s3cur3_p4ssw0rd```You could use a settings class like this to retrieve everything in the secret:```pythonclass Settings(BaseSettings):    # The `vault_secret_path` is the full path (with mount point included) to the secret.    # For a KV v2 secret engine, there is always a `data/` sub-path between the mount point and    # the secret actual path, eg. if your mount point is `secret/` (the default) and your secret    # path is `my-api/prod`, the full path to use is `secret/data/my-api/prod`.    # We don't pass a `vault_secret_key` here so that Pydantic-Vault fetches all fields at once.    credentials: dict = Field(..., vault_secret_path=&quot;secret/data/my-api/prod&quot;)settings = Settings()settings.credentials  # { &quot;root_user&quot;: &quot;root&quot;, &quot;root_password&quot;: &quot;a_v3ry_s3cur3_p4ssw0rd&quot; }```You can also use a Pydantic `BaseModel` class to parse and validate the incoming secret:```pythonclass Credentials(BaseModel):    root_user: str    root_password: SecretStrclass Settings(BaseSettings):    # The `vault_secret_path` is the full path (with mount point included) to the secret.    # For a KV v2 secret engine, there is always a `data/` sub-path between the mount point and    # the secret actual path, eg. if your mount point is `secret/` (the default) and your secret    # path is `my-api/prod`, the full path to use is `secret/data/my-api/prod`.    # We don't pass a `vault_secret_key` here so that Pydantic-Vault fetches all fields at once.    credentials: Credentials = Field(..., vault_secret_path=&quot;secret/data/my-api/prod&quot;)settings = Settings()settings.credentials.root_user  # &quot;root&quot;settings.credentials.root_password.get_secret_value()  # &quot;a_v3ry_s3cur3_p4ssw0rd&quot;```### Retrieve a secret from a KV v1 secret engineSuppose your secret is at `my-api/prod` and looks like this:```Key             Value---             -----root_user       rootroot_password   a_v3ry_s3cur3_p4ssw0rd```Your settings class would be:```pythonclass Settings(BaseSettings):    # The `vault_secret_path` is the full path (with mount point included) to the secret.    # For a KV v1 secret engine, the secret path is directly appended to the mount point,    # eg. if your mount point is `kv/` (the default) and your secret path is `my-api/prod`,    # the full path to use is `kv/my-api/prod` (unlike with KV v2 secret engines).    # The `vault_secret_key` is the specific key to extract from a secret.    username: str = Field(        ..., vault_secret_path=&quot;kv/my-api/prod&quot;, vault_secret_key=&quot;root_user&quot;    )    password: SecretStr = Field(        ..., vault_secret_path=&quot;kv/my-api/prod&quot;, vault_secret_key=&quot;root_password&quot;    )settings = Settings()settings.username  # &quot;root&quot;settings.password.get_secret_value()  # &quot;a_v3ry_s3cur3_p4ssw0rd&quot;```âš  Beware of the [known limitations](#known-limitations) on KV v1 secrets!### Retrieve a secret from a database secret engineDatabase secrets can be &quot;dynamic&quot;, generated by Vault every time you request access.Because every call to Vault will create a new database account, you cannot store the usernameand password in two different fields in your settings class, or you would get the username of the*first* generated account and the password of the *second* account. This means that you must *not*pass a `vault_secret_key`, so that Pydantic-Vault retrieves the whole secret at once.You can store the credentials in a dict or in a custom `BaseModel` class:```pythonclass DbCredentials(BaseModel):    username: str    password: SecretStrclass Settings(BaseSettings):    # The `vault_secret_path` is the full path (with mount point included) to the secret.    # For a database secret engine, the secret path is `&lt;mount point&gt;/creds/&lt;role name&gt;`.    # For example if your mount point is `database/` (the default) and your role name is    # `my-db-prod`, the full path to use is `database/creds/my-db-prod`. You will receive    # `username` and `password` fields in response.    # You must *not* pass a `vault_secret_key` so that Pydantic-Vault fetches both fields at once.    db_creds: DbCredentials = Field(..., vault_secret_path=&quot;database/creds/my-db-prod&quot;)    db_creds_in_dict: dict = Field(..., vault_secret_path=&quot;database/creds/my-db-prod&quot;)settings = Settings()settings.db_creds.username  # &quot;generated-username-1&quot;settings.db_creds.password.get_secret_value()  # &quot;generated-password-for-username-1&quot;settings.db_creds_in_dict[&quot;username&quot;]  # &quot;generated-username-2&quot;settings.db_creds_in_dict[&quot;password&quot;]  # &quot;generated-password-for-username-2&quot;```### Use a dynamic path to retrieve secretsIf you have different paths for your secrets (for example if you have different environments) you can use string formattingto dynamically generate the paths depending on an environment variable.```pythonimport os# You will need to specify the environment in an environment variable, but by# default it falls back to &quot;dev&quot;ENV = os.getenv(&quot;ENV&quot;, &quot;dev&quot;)class Settings(BaseSettings):    # This will load different secrets depending on the value of the ENV environment variable    username: str = Field(        ..., vault_secret_path=f&quot;kv/my-api/{ENV}&quot;, vault_secret_key=&quot;root_user&quot;    )    password: SecretStr = Field(        ..., vault_secret_path=f&quot;kv/my-api/{ENV}&quot;, vault_secret_key=&quot;root_password&quot;    )settings = Settings()settings.username  # &quot;root&quot;settings.password.get_secret_value()  # &quot;a_v3ry_s3cur3_p4ssw0rd&quot;```## Known limitations- Pydantic by default takes up ~80 MB, because it is compiled to a native extension and optimized for speed instead of file  size. If you don't rely much on Pydantic (you only use it for your app configuration with Pydantic-Vault, you parse/serialize  a low volume of JSON, your code is generally slow and Pydantic wouldn't be the bottleneck) you can use the flag  `--no-binary pydantic` when running `pip install` to install the pure-Python version instead of the compiled one (which  comes at less than 1 MB). You can also add the flag on its own line in your `requirements.txt`. See this discussion  https://github.com/samuelcolvin/pydantic/issues/2276 for more information.- On KV v1 secret engines, if your secret has a `data` key and you do not specify a `vault_secret_key`to load the whole secret at once, Pydantic-vault will only load the content of the `data` key.  For example, with a secret `kv/my-secret`  ```  Key             Value  ---             -----  user            root  password        a_v3ry_s3cur3_p4ssw0rd  data            a very important piece of data  ```  and the settings class  ```python  class Settings(BaseSettings):      my_secret: dict = Field(..., vault_secret_path=&quot;kv/my-secret&quot;)  ```  Pydantic-Vault will try to load only the `data` value (`a very important piece of data`) in  `my_secret`, which will fail validation from Pydantic because it is not a dict.  **Workaround:** Rename the `data` key in your secret ðŸ˜…  **Workaround:** Migrate to KV v2## Inspirations- [Ansible `hashi_vault` lookup plugin][ansible hashi_vault] for the API and some code- [Hashicorp's Vault GitHub Action][vault-action] for the API## LicensePydantic-Vault is available under the [MIT license](./LICENSE).[ansible hashi_vault]: https://docs.ansible.com/ansible/latest/collections/community/hashi_vault/hashi_vault_lookup.html[pydantic]: https://pydantic-docs.helpmanual.io/[pydantic-basesettings]: https://pydantic-docs.helpmanual.io/usage/settings/[pydantic-basesettings-customsource]: https://pydantic-docs.helpmanual.io/usage/settings/#customise-settings-sources[vault]: https://www.vaultproject.io/[vault-action]: https://github.com/hashicorp/vault-action[vault-auth-approle]: https://www.vaultproject.io/docs/auth/approle[vault-auth-kubernetes]: https://www.vaultproject.io/docs/auth/kubernetes[vault-auth-token]: https://www.vaultproject.io/docs/auth/token[vault-kv-v2]: https://www.vaultproject.io/docs/secrets/kv/kv-v2/</longdescription>
</pkgmetadata>