<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://img.shields.io/pypi/v/schemadict.svg?style=flat   :target: https://pypi.org/project/schemadict/   :alt: Latest PyPI version.. image:: https://readthedocs.org/projects/schemadict/badge/?version=latest    :target: https://schemadict.readthedocs.io/en/latest/?badge=latest    :alt: Documentation Status.. image:: https://img.shields.io/badge/license-Apache%202-blue.svg    :target: https://github.com/airinnova/schemadict/blob/master/LICENSE.txt    :alt: License.. image:: https://travis-ci.org/airinnova/schemadict.svg?branch=master    :target: https://travis-ci.org/airinnova/schemadict    :alt: Build status.. image:: https://codecov.io/gh/airinnova/schemadict/branch/master/graph/badge.svg    :target: https://codecov.io/gh/airinnova/schemadict    :alt: Coverage|.. image:: https://raw.githubusercontent.com/airinnova/schemadict/master/docs/source/_static/images/logo.png   :target: https://github.com/airinnova/schemadict/   :alt: logo..    # ======================================================================    # Include start    # ======================================================================    # from docs/source/user_guide/usage_page.txtUsage=====A *schemadict* is a regular Python dictionary which specifies the type and format of values for some given key. To check if a test dictionary is conform with the expected schema, *schemadict* provides the ``validate()`` method. If the test dictionary is ill-defined, an error will be thrown, otherwise ``None`` is returned.Examples--------**Basic usage**.. code:: python    &gt;&gt;&gt; from schemadict import schemadict    &gt;&gt;&gt; schema = schemadict({    ...     'name': {    ...         'type': str,    ...         'min_len': 3,    ...         'max_len': 12,    ...     },    ...     'age': {    ...         'type': int,    ...         '&gt;=': 0,    ...         '&lt;': 150,    ...     },    ... })    &gt;&gt;&gt;    &gt;&gt;&gt; testdict = {'name': 'Neil', 'age': 55}    &gt;&gt;&gt; schema.validate(testdict)    &gt;&gt;&gt;    &gt;&gt;&gt; testdict = {'name': 'Neil', 'age': -12}    &gt;&gt;&gt; schema.validate(testdict)    Traceback (most recent call last):        ...    ValueError: 'age' too small: expected &gt;= 0, but was -12    &gt;&gt;&gt;    &gt;&gt;&gt; testdict = {'name': 'Neil', 'age': '55'}    &gt;&gt;&gt; schema.validate(testdict)    Traceback (most recent call last):        ...    TypeError: unexpected type for 'age': expected &lt;class 'int'&gt;, but was &lt;class 'str'&gt;    &gt;&gt;&gt;**Nested schemadict**It is possible to check individual item in a list. For instance, in the following example we check if each item (of type ``str``) looks like a valid IPv4 address. How each item should look like can be specified with the ``item_schema`` keyword... code:: python    &gt;&gt;&gt; schema = schemadict({    ...     'ip_addrs': {    ...         'type': list,    ...         'item_schema': {    ...             'type': str,    ...             'regex': r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$',    ...         },    ...     },    ... })    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; schema.validate({'ip_addrs': ['127.0.0.1', '192.168.1.1']})  # Valid    &gt;&gt;&gt; schema.validate({'ip_addrs': ['127.0.0.1', '192.168.1.1', '1234.5678']})  # Last item invalid    Traceback (most recent call last):        ...    ValueError: regex mismatch for 'ip_addrs': expected pattern '^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', got '1234.5678'    &gt;&gt;&gt;Items in a ``list`` (or ``tuple``) may themselves be dictionaries which can be described with *schemadicts*. In this case, we use the keyword ``item_schemadict`` as illustrated in the following example... code:: python    &gt;&gt;&gt; schema_city = schemadict({    ...     'name': {    ...         'type': str    ...     },    ...     'population': {    ...         'type': int,    ...         '&gt;=': 0,    ...     },    ... })    &gt;&gt;&gt;    &gt;&gt;&gt; schema_country = schemadict({    ...     'name': {'type': str},    ...     'cities': {    ...         'type': list,    ...         'item_type': dict,    ...         'item_schemadict': schema_city,    ...     },    ... })    &gt;&gt;&gt;    &gt;&gt;&gt; test_country = {    ...     'name': 'Neverland',    ...     'cities': [    ...         {'name': 'Faketown', 'population': 3},    ...         {'name': 'Evergreen', 'population': True},    ...     ],    ... }    &gt;&gt;&gt;    &gt;&gt;&gt; schema_country.validate(test_country)    Traceback (most recent call last):        ...    TypeError: unexpected type for 'population': expected &lt;class 'int'&gt;, but was &lt;class 'bool'&gt;    &gt;&gt;&gt;**Custom validation functions**Each *type* (``int``, ``bool``, ``str``, etc.) defines its own set of validation keywords and corresponding test functions. The dictionary ``STANDARD_VALIDATORS`` provided by the ``schemadict`` module contains the default validation functions for the Python's built-in types. However, it is also possible to modify or extend this dictionary with custom validation functions... code:: python    &gt;&gt;&gt; from schemadict import schemadict, STANDARD_VALIDATORS    &gt;&gt;&gt; # Add a custom validation function    &gt;&gt;&gt; def is_divisible(key, value, comp_value, _):    ...     if value % comp_value != 0:    ...             raise ValueError(f&quot;{key!r} is not divisible by {comp_value}&quot;)    ...    ...    ...    &gt;&gt;&gt;    &gt;&gt;&gt; # Update the standard validator dictionary    &gt;&gt;&gt; my_validators = STANDARD_VALIDATORS    &gt;&gt;&gt; my_validators[int]['%'] = is_divisible    &gt;&gt;&gt; # Register the updated validator dictionary in the new schemadict instance    &gt;&gt;&gt; s = schemadict({'my_num': {'type': int, '%': 3}}, validators=my_validators)    &gt;&gt;&gt; s.validate({'my_num': 33})    &gt;&gt;&gt; s.validate({'my_num': 4})    Traceback (most recent call last):        ...    ValueError: 'my_num' is not divisible by 3    &gt;&gt;&gt;It is also possible to define *custom types* and *custom test functions* as shown in the following example... code:: python    &gt;&gt;&gt; from schemadict import schemadict, STANDARD_VALIDATORS    &gt;&gt;&gt; class MyOcean:    ...     has_dolphins = True    ...     has_plastic = False    ...    &gt;&gt;&gt;    &gt;&gt;&gt; def has_dolphins(key, value, comp_value, _):    ...     if getattr(value, 'has_dolphins') is not comp_value:    ...         raise ValueError(f&quot;{key!r} does not have dolphins&quot;)    ...    &gt;&gt;&gt;    &gt;&gt;&gt; my_validators = STANDARD_VALIDATORS    &gt;&gt;&gt; my_validators.update({MyOcean: {'has_dolphins': has_dolphins}})    &gt;&gt;&gt;    &gt;&gt;&gt; schema_ocean = schemadict(    ...     {'ocean': {'type': MyOcean, 'has_dolphins': True}},    ...     validators=my_validators,    ... )    &gt;&gt;&gt;    &gt;&gt;&gt; ocean1 = MyOcean()    &gt;&gt;&gt; schema_ocean.validate({'ocean': ocean1})    &gt;&gt;&gt;    &gt;&gt;&gt; ocean2 = MyOcean()    &gt;&gt;&gt; ocean2.has_dolphins = False    &gt;&gt;&gt; schema_ocean.validate({'ocean': ocean2})    Traceback (most recent call last):        ...    ValueError: 'ocean' does not have dolphinsFull documentation: https://schemadict.readthedocs.io/Features--------What *schemadict* offers:* Built-in support for Python's &quot;primitive types&quot;* Specify *required* and *optional* keys* Validate *nested* schemas* Add custom validation functions to built-in types* Add custom validation functions to custom types* Support for Regex checks of stringsFeatures currently in development* Metaschema validation* Lazy validation and summary of all errors* Allow schema variations: schmea 1 OR schema 2..    # ======================================================================    # Include end    # ======================================================================Installation============*Schemadict* is available on `PyPI &lt;https://pypi.org/project/schemadict/&gt;`_ and may simply be installed with.. code::    pip install schemadictIdea====*Schemadict* is loosely inspired by `JSON schema &lt;https://json-schema.org/&gt;`_ and `jsonschema &lt;https://github.com/Julian/jsonschema&gt;`_, a JSON schema validator for Python.License=======**License:** Apache-2.0</longdescription>
</pkgmetadata>