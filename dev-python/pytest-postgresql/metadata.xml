<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://raw.githubusercontent.com/ClearcodeHQ/pytest-postgresql/master/logo.png    :width: 100px    :height: 100px    pytest-postgresql=================.. image:: https://img.shields.io/pypi/v/pytest-postgresql.svg    :target: https://pypi.python.org/pypi/pytest-postgresql/    :alt: Latest PyPI version.. image:: https://img.shields.io/pypi/wheel/pytest-postgresql.svg    :target: https://pypi.python.org/pypi/pytest-postgresql/    :alt: Wheel Status.. image:: https://img.shields.io/pypi/pyversions/pytest-postgresql.svg    :target: https://pypi.python.org/pypi/pytest-postgresql/    :alt: Supported Python Versions.. image:: https://img.shields.io/pypi/l/pytest-postgresql.svg    :target: https://pypi.python.org/pypi/pytest-postgresql/    :alt: LicenseWhat is this?=============This is a pytest plugin, that enables you to test your code that relies on a running PostgreSQL Database.It allows you to specify fixtures for PostgreSQL process and client.How to use==========.. warning::    Tested on PostgreSQL versions &gt;= 10. See tests for more details.Install with:.. code-block:: sh    pip install pytest-postgresqlYou will also need to install ``psycopg``. See `its installation instructions &lt;https://www.psycopg.org/psycopg3/docs/basic/install.html&gt;`_.Note that this plugin requires ``psycopg`` version 3. It is possible to simultaneously install version 3and version 2 for libraries that require the latter (see `those instructions &lt;https://www.psycopg.org/docs/install.html&gt;`_).Plugin contains three fixtures:* **postgresql** - it's a client fixture that has functional scope.  After each test it ends all leftover connections, and drops test database  from PostgreSQL ensuring repeatability.  This fixture returns already connected psycopg connection.* **postgresql_proc** - session scoped fixture, that starts PostgreSQL instance  at it's first use and stops at the end of the tests.* **postgresql_noproc** - a noprocess fixture, that's connecting to already  running postgresql instance.  For example on dockerized test environments, or CI providing postgresql servicesSimply include one of these fixtures into your tests fixture list.You can also create additional postgresql client and process fixtures if you'd need to:.. code-block:: python    from pytest_postgresql import factories    postgresql_my_proc = factories.postgresql_proc(        port=None, unixsocketdir='/var/run')    postgresql_my = factories.postgresql('postgresql_my_proc').. note::    Each PostgreSQL process fixture can be configured in a different way than the others through the fixture factory arguments.Sample test.. code-block:: python    def test_example_postgres(postgresql):        &quot;&quot;&quot;Check main postgresql fixture.&quot;&quot;&quot;        cur = postgresql.cursor()        cur.execute(&quot;CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);&quot;)        postgresql.commit()        cur.close()If you want the database fixture to be automatically populated with your schema there are two ways:#. client fixture specific#. process fixture specificBoth are accepting same set of possible loaders:* sql file path* loading function import path (string)* actual loading functionThat function will receive **host**, **port**, **user**, **dbname** and **password** kwargs and will have to performconnection to the database inside. However, you'll be able to run SQL files or even trigger programmatically databasemigrations you have.Client specific loads the database each test.. code-block:: python    postgresql_my_with_schema = factories.postgresql(        'postgresql_my_proc',        load=[&quot;schemafile.sql&quot;, &quot;otherschema.sql&quot;, &quot;import.path.to.function&quot;, &quot;import.path.to:otherfunction&quot;, load_this]    ).. warning::    This way, the database will still be dropped each time.The process fixture performs the load once per test session, and loads the data into the template database.Client fixture then creates test database out of the template database each test, which significantly speeds up the tests... code-block:: python    postgresql_my_proc = factories.postgresql_proc(        load=[&quot;schemafile.sql&quot;, &quot;otherschema.sql&quot;, &quot;import.path.to.function&quot;, &quot;import.path.to:otherfunction&quot;, load_this]    ).. code-block:: bash    pytest --postgresql-populate-template=path.to.loading_function --postgresql-populate-template=path.to.other:loading_function --postgresql-populate-template=path/to/file.sqlThe loading_function from example will receive , and have to commit that.Connecting to already existing postgresql database--------------------------------------------------Some projects are using already running postgresql servers (ie on docker instances).In order to connect to them, one would be using the ``postgresql_noproc`` fixture... code-block:: python    postgresql_external = factories.postgresql('postgresql_noproc')By default the  ``postgresql_noproc`` fixture would connect to postgresql instance using **5432** port. Standard configuration options apply to it.These are the configuration options that are working on all levels with the ``postgresql_noproc`` fixture:Configuration=============You can define your settings in three ways, it's fixture factory argument, command line option and pytest.ini configuration option.You can pick which you prefer, but remember that these settings are handled in the following order:    * ``Fixture factory argument``    * ``Command line option``    * ``Configuration option in your pytest.ini file``.. list-table:: Configuration options   :header-rows: 1   * - PostgreSQL option     - Fixture factory argument     - Command line option     - pytest.ini option     - Noop process fixture     - Default   * - Path to executable     - executable     - --postgresql-exec     - postgresql_exec     - -     - /usr/lib/postgresql/13/bin/pg_ctl   * - host     - host     - --postgresql-host     - postgresql_host     - yes     - 127.0.0.1   * - port     - port     - --postgresql-port     - postgresql_port     - yes (5432)     - random   * - postgresql user     - user     - --postgresql-user     - postgresql_user     - yes     - postgres   * - password     - password     - --postgresql-password     - postgresql_password     - yes     -   * - Starting parameters (extra pg_ctl arguments)     - startparams     - --postgresql-startparams     - postgresql_startparams     - -     - -w   * - Postgres exe extra arguments (passed via pg_ctl's -o argument)     - postgres_options     - --postgresql-postgres-options     - postgresql_postgres_options     - -     -   * - Log filename's prefix     - logsprefix     - --postgresql-logsprefix     - postgresql_logsprefix     - -     -   * - Location for unixsockets     - unixsocket     - --postgresql-unixsocketdir     - postgresql_unixsocketdir     - -     - $TMPDIR   * - Database name     - dbname     - --postgresql-dbname     - postgresql_dbname     - yes, however with xdist an index is being added to name, resulting in test0, test1 for each worker.     - test   * - Default Schema either in sql files or import path to function that will load it (list of values for each)     - load     - --postgresql-load     - postgresql_load     - yes     -   * - PostgreSQL connection options     - options     - --postgresql-options     - postgresql_options     - yes     -Example usage:* pass it as an argument in your own fixture    .. code-block:: python        postgresql_proc = factories.postgresql_proc(            port=8888)* use ``--postgresql-port`` command line option when you run your tests    .. code-block::        py.test tests --postgresql-port=8888* specify your port as ``postgresql_port`` in your ``pytest.ini`` file.    To do so, put a line like the following under the ``[pytest]`` section of your ``pytest.ini``:    .. code-block:: ini        [pytest]        postgresql_port = 8888Examples========Populating database for tests-----------------------------With SQLAlchemy+++++++++++++++This example shows how to populate database and create an SQLAlchemy's ORM connection:Sample below is simplified session fixture from`pyramid_fullauth &lt;https://github.com/fizyk/pyramid_fullauth/&gt;`_ tests:.. code-block:: python    from sqlalchemy import create_engine    from sqlalchemy.orm import scoped_session, sessionmaker    from sqlalchemy.pool import NullPool    from zope.sqlalchemy import register    @pytest.fixture    def db_session(postgresql):        &quot;&quot;&quot;Session for SQLAlchemy.&quot;&quot;&quot;        from pyramid_fullauth.models import Base        connection = f'postgresql+psycopg2://{postgresql.info.user}:@{postgresql.info.host}:{postgresql.info.port}/{postgresql.info.dbname}'        engine = create_engine(connection, echo=False, poolclass=NullPool)        pyramid_basemodel.Session = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))        pyramid_basemodel.bind_engine(            engine, pyramid_basemodel.Session, should_create=True, should_drop=True)        yield pyramid_basemodel.Session        transaction.commit()        Base.metadata.drop_all(engine)    @pytest.fixture    def user(db_session):        &quot;&quot;&quot;Test user fixture.&quot;&quot;&quot;        from pyramid_fullauth.models import User        from tests.tools import DEFAULT_USER        new_user = User(**DEFAULT_USER)        db_session.add(new_user)        transaction.commit()        return new_user    def test_remove_last_admin(db_session, user):        &quot;&quot;&quot;        Sample test checks internal login, but shows usage in tests with SQLAlchemy        &quot;&quot;&quot;        user = db_session.merge(user)        user.is_admin = True        transaction.commit()        user = db_session.merge(user)        with pytest.raises(AttributeError):            user.is_admin = False.. note::    See the original code at `pyramid_fullauth's conftest file &lt;https://github.com/fizyk/pyramid_fullauth/blob/2950e7f4a397b313aaf306d6d1a763ab7d8abf2b/tests/conftest.py#L35&gt;`_.    Depending on your needs, that in between code can fire alembic migrations in case of sqlalchemy stack or any other codeMaintaining database state outside of the fixtures--------------------------------------------------It is possible and appears it's used in other libraries for tests,to maintain database state with the use of the ``pytest-postgresql`` databasemanaging functionality:For this import DatabaseJanitor and use its init and drop methods:.. code-block:: python    import pytest    from pytest_postgresql.janitor import DatabaseJanitor    @pytest.fixture    def database(postgresql_proc):        # variable definition        janitor = DatabaseJanitor(            postgresql_proc.user,            postgresql_proc.host,            postgresql_proc.port,            &quot;my_test_database&quot;,            postgresql_proc.version,            password=&quot;secret_password,        ):        janitor.init()        yield psycopg2.connect(            dbname=&quot;my_test_database&quot;,            user=postgresql_proc.user,            password=&quot;secret_password&quot;,            host=postgresql_proc.host,            port=postgresql_proc.port,        )        janitor.drop()or use it as a context manager:.. code-block:: python    import pytest    from pytest_postgresql.janitor import DatabaseJanitor    @pytest.fixture    def database(postgresql_proc):        # variable definition        with DatabaseJanitor(            postgresql_proc.user,            postgresql_proc.host,            postgresql_proc.port,            &quot;my_test_database&quot;,            postgresql_proc.version,            password=&quot;secret_password,        ):            yield psycopg2.connect(                dbname=&quot;my_test_database&quot;,                user=postgresql_proc.user,                password=&quot;secret_password&quot;,                host=postgresql_proc.host,                port=postgresql_proc.port,            ).. note::    DatabaseJanitor manages the state of the database, but you'll have to create    connection to use in test code yourself.    You can optionally pass in a recognized postgresql ISOLATION_LEVEL for    additional control... note::    See DatabaseJanitor usage in python's warehouse test code https://github.com/pypa/warehouse/blob/5d15bfe/tests/conftest.py#L127Connecting to Postgresql (in a docker)--------------------------------------To connect to a docker run postgresql and run test on it, use noproc fixtures... code-block:: sh    docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgresThis will start postgresql in a docker container, however using a postgresql installed locally is not much different.In tests, make sure that all your tests are using **postgresql_noproc** fixture like that:.. code-block:: python    from pytest_postgresql import factories    postgresql_in_docker = factories.postgresql_noproc()    postgresql = factories.postgresql(&quot;postgresql_in_docker&quot;, dbname=&quot;test&quot;)    def test_postgres_docker(postgresql):        &quot;&quot;&quot;Run test.&quot;&quot;&quot;        cur = postgresql.cursor()        cur.execute(&quot;CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);&quot;)        postgresql.commit()        cur.close()And run tests:.. code-block:: sh    pytest --postgresql-host=172.17.0.2 --postgresql-password=mysecretpasswordUsing a common database initialisation between tests----------------------------------------------------If you've got several tests that require common initialisation, you need to define a `load` and pass it toyour custom postgresql process fixture:.. code-block:: python    import pytest_postgresql.factories    def load_database(**kwargs):        db_connection: connection = psycopg2.connect(**kwargs)        with db_connection.cursor() as cur:            cur.execute(&quot;CREATE TABLE stories (id serial PRIMARY KEY, name varchar);&quot;)            cur.execute(                &quot;INSERT INTO stories (name) VALUES&quot;                &quot;('Silmarillion'), ('Star Wars'), ('The Expanse'), ('Battlestar Galactica')&quot;            )            db_connection.commit()    postgresql_proc = factories.postgresql_proc(        load=[load_database],    )    postgresql = factories.postgresql(        &quot;postgresql_proc&quot;,    )You can also define your own database name by passing same dbname valueto **both** factories.The way this will work is that the process fixture will populate template database,which in turn will be used automatically by client fixture to create a test database from scratch.Fast, clean and no dangling transactions, that could be accidentally rolled back.Same approach will work with noproces fixture, while connecting to already running postgresql instance whetherit'll be on a docker machine or running remotely or locally.CHANGELOG=========4.1.1----------Misc++++- Error message typo fix- Docker documentation example typo fixes- Have setuptools required as package dependency. pkg_resources.parse_version is used in code   but setuptools was only used as build requirements4.1.0----------Features++++++++- Import FixtureRequest from pytest, not private _pytest.  Require at least pytest 6.2- Replace tmpdir_factory with tmp_path_factory4.0.0----------Features++++++++- Upgrade to psycopg 3.- Xdist running test connecting to already existing postgresql,  will now create separate databases for each worker.Backward Incompatibilities++++++++++++++++++++++++++- Use psycopg 3 and return its connections in client fixtures.- Drop support for postgresql 9.6- client fixture will no longer utilize configuration's load param- client fixture will no longer utilize configuration's dbanme parameterMisc++++- Add Postgresql 14 to the CI3.1.2----------Bugfix++++++- Database can be created by DatabaseJanitor or the client fixture when an isolation  level is specified.3.1.1----------Misc++++- rely on `get_port` functionality delivered by `port_for`3.1.0----------Features++++++++- Added type annotations and compatibitlity with PEP 561Misc++++- pre-commit configuration3.0.2----------Bugfix++++++- Changed `UPDATE pg_database SET` to `ALTER`. System tables should not be updated.3.0.1----------Bugfix++++++- Fixed DatabaseJanitor port type hint to int from str- Changed retry definition to not fail if psycopg2 is not installed.  Now the default is Exception.Misc++++- Support python 3.7 and up3.0.0----------Features++++++++- Ability to create template database once for the process fixture and  re-recreate a clean database out of it every test. Not only it does provide some  common db initialisation between tests but also can speed up tests significantly,  especially if the initialisation has lots of operations to perform.- DatabaseJanitor can now define a `connection_timeout` parameter.  How long will it try to connect to database before raising a TimeoutError- Updated supported python versions- Unified temporary directory handling in fixture. Settled on tmpdir_factory.- Fully moved to the Github Actions as CI/CD pipelineDeprecations++++++++++++- Deprecated support for `logs_prefix` process fixture factory argument,  `--postgresql-logsprefix` pytest command line option and `postgresql_logsprefix`  ini configuration option. tmpdir_factory now builds pretty unique temporary directory structure.Backward Incompatibilities++++++++++++++++++++++++++- Dropped support for postgresql 9.5 and down- Removed init_postgresql_database and drop_postgresql_database functions.  They were long deprecated and their role perfectly covered by DatabaseJanitor class.- `pytest_postgresql.factories.get_config` was moved to `pytest_postgresql.config.get_config`- all `db_name` keywords and attributes were renamed to `dbname`- postgresql_nooproc fixture was renamed to postgresql_noprocBugfix++++++- Use `postgresql_logsprefix` and `--postgresql-logsprefix` again.  They were stopped being used somewhere along the way.- Sometimes pytest-postrgesql would fail to start postgresql with  &quot;FATAL:  the database system is starting up&quot; message. It's not really a fatal error,  but a message indicating that the process still starts. Now pytest-postgresql will wait properly in this cases.2.6.1----------- [bugfix] To not fail loading code if no postgresql version is installed.  Fallback for janitor and process fixture only, if called upon.2.6.0----------- [enhancement] add ability to pass options to pg_ctl's -o flag to send arguments to the underlying postgres executable   Use `postgres_options` as fixture argument, `--postgresql-postgres-options` as pytest starting option or  `postgresql_postgres_options` as pytest.ini configuration option2.5.3----------- [enhancement] Add ability to set up isolation level for fixture and janitor2.5.2----------- [fix] Status checks for running postgres depend on pg_ctl status code,  not on pg_ctl log language. Fixes starting on systems without C locale.  Thanks @Martin Meyries.2.5.1----------- [fix] Added LC_* env vars to running initdb and other utilities.  Now all tools and server are using same, C locale2.5.0----------- [feature] Ability to define default schema to initialize database with- [docs] Added more examples to readme on how to use the plugin2.4.1----------- [enhancement] extract NoopExecutor into it's own submodule- [bugfix] Ignore occasional `ProcessFinishedWithError` error on executor exit.- [bugfix] Fixed setting custom password for process fixture- [bugfix] Fix version detection, to allow for two-digit minor version part2.4.0----------- [feature] Drop support for python 3.5- [enhancement] require at least mirakuru 2.3.0 (executor's stop method parameter's change)- [bug] pass password to DatabaseJanitor in client's factory2.3.0----------- [feature] Allow to set password for postgresql. Use it throughout the flow.- [bugfix] Default Janitor's connections to postgres database. When using custom users,   postgres attempts to use user's database and it might not exist.- [bugfix] NoopExecutor connects to read version by context manager to properly handle cases  where it can't connect to the server.2.2.1----------- [bugfix] Fix drop_postgresql_database to actually use DatabaseJanitor.drop instead of an init2.2.0----------- [feature] ability to properly connect to already existing postgresql server using ``postgresql_nooproc`` fixture.2.1.0----------- [enhancement] Gather helper functions maintaining postgresql database in DatabaseJanitor class.- [deprecate] Deprecate ``init_postgresql_database`` in favour of ``DatabaseJanitor.init``- [deprecate] Deprecate ``drop_postgresql_database`` in favour of ``DatabaseJanitor.drop``2.0.0----------- [feature] Drop support for python 2.7. From now on, only support python 3.5 and up- [feature] Ability to configure database name through plugin options- [enhancement] Use tmpdir_factory. Drop ``logsdir`` parameter- [ehnancement] Support only Postgresql 9.0 and up- [bugfix] Always start postgresql with LC_ALL, LC_TYPE and LANG set to C.UTF-8.  It makes postgresql start in english.1.4.1----------- [bugfix] Allow creating test database with hyphens 1.4.0----------- [enhancements] Ability to configure additional options for postgresql process and connection- [bugfix] - removed hard dependency on ``psycopg2``, allowing any of its alternative packages, like  ``psycopg2-binary``, to be used.- [maintenance] Drop support for python 3.4 and use 3.7 instead1.3.4----------- [bugfix] properly detect if executor running and clean after executor is being stopped    .. note::        Previously if a test failed, there was a possibility of the executor being removed when python was closing,        causing it to print ignored errors on already unloaded modules.1.3.3----------- [enhancement] use executor's context manager to start/stop postrgesql server in a fixture1.3.2----------- [bugfix] version regexp to correctly catch postgresql 101.3.1----------- [enhancement] explicitly turn off logging_collector1.3.0----------- [feature] pypy compatibility1.2.0----------- [bugfix] - disallow connection to database before it gets dropped.    .. note::        Otherwise it caused random test subprocess to connect again and this the drop was unsuccessful which resulted in many more test fails on setup.- [cleanup] - removed path.py dependency1.1.1----------- [bugfix] - Fixing the default pg_ctl path creation1.1.0----------- [feature] - migrate usage of getfuncargvalue to getfixturevalue. require at least pytest 3.0.01.0.0----------- create command line and pytest.ini configuration options for postgresql starting parameters- create command line and pytest.ini configuration options for postgresql username- make the port random by default- create command line and pytest.ini configuration options for executable- create command line and pytest.ini configuration options for host- create command line and pytest.ini configuration options for port- Extracted code from pytest-dbfixtures</longdescription>
</pkgmetadata>