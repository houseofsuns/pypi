<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>üöÄ Introducing ‚ú® Bose Framework - The Swiss Army Knife for Bot Developers ü§ñ=============================================================================.. figure:: https://www.omkar.cloud/bose/assets/images/featured-0bacb14445a1b4cf367c10cd01454000.jpgBot Development is Tough.Bot Detectors like Cloudflare are ready to defend websites from ourBots. Configuring Selenium with ChromeOptions to specify the driverpath, profile, user agent, and window size is Cumbersome and a nightmarein windows. Debugging Bot Crashes via logs is hard. How do you solvethese pain points without sacrificing speed and handy development?Enter Bose. Bose is the first bot development framework in the DeveloperCommunity that is specifically designed to provide the best developerexperience for bot developers. Powered by Selenium, it offers a range offeatures and functionalities to simplify the process of bot development.As far as our knowledge goes, Bose is the first bot developmentframework of its kind in the town.Getting Started---------------Clone Starter Template::   git clone https://github.com/omkarcloud/bose-starter my-bose-projectThen change into that directory, install dependencies, and start theproject:::   cd my-bose-project   python -m pip install -r requirements.txt   python main.pyThe first run will take some time as it downloads the chrome driverexecutable, subsequent runs will be fast.Core features-------------1. Adds Powerful Methods to make working with Selenium a lot easier.2. Follows best practices to avoid Bot Detection by Cloudflare and   PerimeterX.3. Saves the HTML, Screenshot, and the run details for each task run to   enable easy debugging.4. Utility components to write scraped data as JSON, CSV, and Excel   files.5. Automatically downloads and initializes the correct Chrome driver.6. Fast and Developer friendly.Usage-----Say you want to start scraping a website. If you were using bareSelenium, you would have to handle the imperative tasks of opening andclosing the driver like this:.. code:: python   from selenium import webdriver   driver_path = 'path/to/chromedriver'   driver = webdriver.Chrome(executable_path=driver_path)   driver.get('https://www.example.com')   driver.quit()However, with Bose Framework, you can take a declarative and structuredapproach. You only need to write the following code, and Bose driverwill take care of creating the driver, passing it to the **``run``**method of the Task, and closing the driver:.. code:: python   from bose import *              class Task(BaseTask):       def run(self, driver):           driver.get('https://www.example.com')Configuration-------------In bare Selenium, if you want to configure options such as the profile,user agent, or window size, it requires writing a lot of code, as shownbelow:.. code:: python   from selenium.webdriver.chrome.options import Options   from selenium import webdriver   driver_path = 'path/to/chromedriver.exe'   options = Options()   profile_path = '1'   options.add_argument(f'--user-data-dir={profile_path}')   user_agent = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.37&quot;)'   options.add_argument(f'--user-agent={user_agent}')   window_width = 1200   window_height = 720   options.add_argument(f'--window-size={window_width},{window_height}')   driver = webdriver.Chrome(executable_path=driver_path, options=options)On the other hand, Bose Framework simplifies these complexities byencapsulating the browser configuration within the **``BrowserConfig``**property of the Task, as shown below:.. code:: python   from bose import BaseTask, BrowserConfig, UserAgent, WindowSize   class Task(BaseTask):       browser_config = BrowserConfig(user_agent=UserAgent.user_agent_106, window_size=WindowSize.window_size_1280_720, profile=1)Exception handling------------------Exceptions are common when using Selenium. In bare Selenium, if anexception occurs, the driver automatically closes, leaving you with onlylogs to debug.In Bose, when an exception occurs in a scraping task, the browserremains open instead of immediately closing. This allows you to see thelive browser state at the moment the exception occurred, which greatlyhelps in debugging... figure:: https://www.omkar.cloud/bose/assets/images/error-prompt-83de79e560f129197afb9f831d388383.pngDebugging---------Web scraping can often be fraught with errors, such as incorrectselectors or pages that fail to load. When debugging with raw Selenium,you may have to sift through logs to identify the issue. Fortunately,Bose makes it simple for you to debug by storing information about eachrun.After each run a directory is created in tasks which contains threefiles, which are listed below:``task_info.json``~~~~~~~~~~~~~~~~~~It contains information about the task run such as duration for whichthe task run, the ip details of task, the user agent, window_size andprofile which used to execute the task... figure:: https://www.omkar.cloud/bose/assets/images/task-info-1ad8d89552138e2edc900434144dfbe0.png``final.png``~~~~~~~~~~~~~This is the screenshot captured before driver was closed... figure:: https://www.omkar.cloud/bose/assets/images/final-d2ca24d2717d17576eb8233ad0cd2b10.png``page.html``~~~~~~~~~~~~~This is the html source captured before driver was closed. Very usefulto know in case your selectors failed to select elements... figure:: https://www.omkar.cloud/bose/assets/images/page-cffce10976b4bf201b49a479c2340075.png``error.log``~~~~~~~~~~~~~In case your task crashed due to exception we also store error.log whichcontains the error due to which the task crashed. This is very helful indebugging... figure:: https://www.omkar.cloud/bose/assets/images/error-log-9ebb09dca133b2d7df1ae6cfc67df909.pngOutputting Data---------------After performing web scraping, we need to store the data in either JSONor CSV format. Typically, this process involves writing a significantamount of imperative code which looks like this:.. code:: python   import csv   import json   def write_json(data, filename):       with open(filename, 'w') as fp:           json.dump(data, fp, indent=4)   def write_csv(data, filename):       with open(filename, 'w', newline='', encoding='utf-8') as csvfile:           fieldnames = data[0].keys()  # get the fieldnames from the first dictionary           writer = csv.DictWriter(csvfile, fieldnames=fieldnames)           writer.writeheader()  # write the header row           writer.writerows(data)  # write each row of data   data = [       {           &quot;text&quot;: &quot;\u201cThe world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.\u201d&quot;,           &quot;author&quot;: &quot;Albert Einstein&quot;       },       {           &quot;text&quot;: &quot;\u201cIt is our choices, Harry, that show what we truly are, far more than our abilities.\u201d&quot;,           &quot;author&quot;: &quot;J.K. Rowling&quot;       }   ]   write_json(data, &quot;data.json&quot;)   write_csv(data, &quot;data.csv&quot;)Bose simplifies these complexities by encapsulating them in OutputModule for reading and writing Data.To use Output Method, call the¬†``write``¬†method for the type of file youwant to save.All data will be saved in the¬†``output/``¬†folder:See following Code for Reference.. code:: python   from bose import Output   data = [       {           &quot;text&quot;: &quot;\u201cThe world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.\u201d&quot;,           &quot;author&quot;: &quot;Albert Einstein&quot;       },       {           &quot;text&quot;: &quot;\u201cIt is our choices, Harry, that show what we truly are, far more than our abilities.\u201d&quot;,           &quot;author&quot;: &quot;J.K. Rowling&quot;       }   ]   Output.write_json(data, &quot;data.json&quot;)   Output.write_csv(data, &quot;data.csv&quot;)Undetected Driver-----------------`Ultrafunkamsterdam &lt;https://github.com/ultrafunkamsterdam&gt;`__¬†createda¬†`ChromeDriver &lt;https://github.com/ultrafunkamsterdam/undetected-chromedriver&gt;`__¬†thathas excellent support for bypassing **all major bot detectionsystems**¬†such as Distil, Datadome, Cloudflare, and others.Bose recognized the importance of bypassing bot detections and providesin built support for`Ultrafunkamsterdam‚Äôs &lt;https://github.com/ultrafunkamsterdam&gt;`__`UndetectedDriver &lt;https://github.com/ultrafunkamsterdam/undetected-chromedriver&gt;`__Using the Undetected Driver in Bose Framework is as simple as passingthe **``use_undetected_driver``** option to the **``BrowserConfig``**,like so:.. code:: python   from bose import BaseTask, BrowserConfig   class Task(BaseTask):       browser_config = BrowserConfig(use_undetected_driver=True)LocalStorage------------Just like how modern browsers have a local storage module, Bose has alsoincorporated the same concept in its framework.You can import the LocalStorage object from Bose to persist data acrossbrowser runs, which is extremely useful when scraping large amounts ofdata.The data is stored in a file named¬†``local_storage.json``¬†in the rootdirectory of your project. Here‚Äôs how you can use it:.. code:: python   from bose import LocalStorage   LocalStorage.set_item(&quot;pages&quot;, 5)   print(LocalStorage.get_item(&quot;pages&quot;))Learn More----------To learn about Bose Bot Development Framework in detail, read the Bosedocs at https://www.omkar.cloud/bose/--------------If Bose Framework helped in Bot Development, please take a moment to `star the repository &lt;https://github.com/omkarcloud/bose&gt;`__. Your act of starring will help developers in discovering our Repository and contribute towards helping fellow developers in Bot Development. Dhanyawad üôè! Vande Mataram!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</longdescription>
</pkgmetadata>