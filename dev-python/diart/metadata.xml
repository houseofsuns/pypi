<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;https://github.com/juanmc2005/diart/blob/main/logo.jpg?raw=true&quot; title=&quot;diart logo&quot; /&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;i&gt;üåø Build AI-powered real-time audio applications in a breeze üåø&lt;/i&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;img alt=&quot;PyPI Version&quot; src=&quot;https://img.shields.io/pypi/v/diart?color=g&quot;&gt;&lt;img alt=&quot;PyPI Downloads&quot; src=&quot;https://static.pepy.tech/personalized-badge/diart?period=total&amp;units=international_system&amp;left_color=grey&amp;right_color=brightgreen&amp;left_text=downloads&quot;&gt;&lt;img alt=&quot;Python Versions&quot; src=&quot;https://img.shields.io/badge/python-3.8%20%7C%203.9%20%7C%203.10-dark_green&quot;&gt;&lt;img alt=&quot;Code size in bytes&quot; src=&quot;https://img.shields.io/github/languages/code-size/juanmc2005/StreamingSpeakerDiarization?color=g&quot;&gt;&lt;img alt=&quot;License&quot; src=&quot;https://img.shields.io/github/license/juanmc2005/StreamingSpeakerDiarization?color=g&quot;&gt;&lt;a href=&quot;https://joss.theoj.org/papers/cc9807c6de75ea4c29025c7bd0d31996&quot;&gt;&lt;img src=&quot;https://joss.theoj.org/papers/cc9807c6de75ea4c29025c7bd0d31996/status.svg&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;div align=&quot;center&quot;&gt;  &lt;h4&gt;    &lt;a href=&quot;#-installation&quot;&gt;      üíæ Installation    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#%EF%B8%8F-stream-audio&quot;&gt;      üéôÔ∏è Stream audio    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#-models&quot;&gt;      üß† Models    &lt;/a&gt;    &lt;br /&gt;    &lt;a href=&quot;#-tune-hyper-parameters&quot;&gt;      üìà Tuning    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#-build-pipelines&quot;&gt;      üß†üîó Pipelines    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#-websockets&quot;&gt;      üåê WebSockets    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#-powered-by-research&quot;&gt;      üî¨ Research    &lt;/a&gt;  &lt;/h4&gt;&lt;/div&gt;&lt;br/&gt;&lt;p align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;https://github.com/juanmc2005/diart/blob/main/demo.gif?raw=true&quot; title=&quot;Real-time diarization example&quot; /&gt;&lt;/p&gt;## ‚ö° Quick introductionDiart is a python framework to build AI-powered real-time audio applications.Its key feature is the ability to recognize different speakers in real time with state-of-the-art performance,a task commonly known as &quot;speaker diarization&quot;.The pipeline `diart.SpeakerDiarization` combines a speaker segmentation and a speaker embedding modelto power an incremental clustering algorithm that gets more accurate as the conversation progresses:&lt;p align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;https://github.com/juanmc2005/diart/blob/main/pipeline.gif?raw=true&quot; title=&quot;Real-time speaker diarization pipeline&quot; /&gt;&lt;/p&gt;With diart you can also create your own custom AI pipeline, benchmark it,tune its hyper-parameters, and even serve it on the web using websockets.**We provide pre-trained pipelines for:**- Speaker Diarization- Voice Activity Detection- Transcription ([coming soon](https://github.com/juanmc2005/diart/pull/144))- [Speaker-Aware Transcription](https://betterprogramming.pub/color-your-captions-streamlining-live-transcriptions-with-diart-and-openais-whisper-6203350234ef) ([coming soon](https://github.com/juanmc2005/diart/pull/147))## üíæ Installation**1) Make sure your system has the following dependencies:**```ffmpeg &lt; 4.4portaudio == 19.6.Xlibsndfile &gt;= 1.2.2```Alternatively, we provide an `environment.yml` file for a pre-configured conda environment:```shellconda env create -f diart/environment.ymlconda activate diart```**2) Install the package:**```shellpip install diart```### Get access to üéπ pyannote modelsBy default, diart is based on [pyannote.audio](https://github.com/pyannote/pyannote-audio) models from the [huggingface](https://huggingface.co/) hub.In order to use them, please follow these steps:1) [Accept user conditions](https://huggingface.co/pyannote/segmentation) for the `pyannote/segmentation` model2) [Accept user conditions](https://huggingface.co/pyannote/segmentation-3.0) for the newest `pyannote/segmentation-3.0` model3) [Accept user conditions](https://huggingface.co/pyannote/embedding) for the `pyannote/embedding` model4) Install [huggingface-cli](https://huggingface.co/docs/huggingface_hub/quick-start#install-the-hub-library) and [log in](https://huggingface.co/docs/huggingface_hub/quick-start#login) with your user access token (or provide it manually in diart CLI or API).## üéôÔ∏è Stream audio### From the command lineA recorded conversation:```shelldiart.stream /path/to/audio.wav```A live conversation:```shell# Use &quot;microphone:ID&quot; to select a non-default device# See `python -m sounddevice` for available devicesdiart.stream microphone```By default, diart runs a speaker diarization pipeline, equivalent to setting `--pipeline SpeakerDiarization`,but you can also set it to `--pipeline VoiceActivityDetection`. See `diart.stream -h` for more options.### From pythonUse `StreamingInference` to run a pipeline on an audio source and write the results to disk:```pythonfrom diart import SpeakerDiarizationfrom diart.sources import MicrophoneAudioSourcefrom diart.inference import StreamingInferencefrom diart.sinks import RTTMWriterpipeline = SpeakerDiarization()mic = MicrophoneAudioSource()inference = StreamingInference(pipeline, mic, do_plot=True)inference.attach_observers(RTTMWriter(mic.uri, &quot;/output/file.rttm&quot;))prediction = inference()```For inference and evaluation on a dataset we recommend to use `Benchmark` (see notes on [reproducibility](#reproducibility)).## üß† ModelsYou can use other models with the `--segmentation` and `--embedding` arguments.Or in python:```pythonimport diart.models as msegmentation = m.SegmentationModel.from_pretrained(&quot;model_name&quot;)embedding = m.EmbeddingModel.from_pretrained(&quot;model_name&quot;)```### Pre-trained modelsBelow is a list of all the models currently supported by diart:| Model Name                                                                                                                | Model Type   | CPU Time* | GPU Time* ||---------------------------------------------------------------------------------------------------------------------------|--------------|-----------|-----------|| [ü§ó](https://huggingface.co/pyannote/segmentation) `pyannote/segmentation` (default)                                      | segmentation | 12ms      | 8ms       || [ü§ó](https://huggingface.co/pyannote/segmentation-3.0) `pyannote/segmentation-3.0`                                        | segmentation | 11ms      | 8ms       || [ü§ó](https://huggingface.co/pyannote/embedding) `pyannote/embedding` (default)                                            | embedding | 26ms      | 12ms      || [ü§ó](https://huggingface.co/hbredin/wespeaker-voxceleb-resnet34-LM) `hbredin/wespeaker-voxceleb-resnet34-LM` (ONNX)       | embedding | 48ms      | 15ms      || [ü§ó](https://huggingface.co/pyannote/wespeaker-voxceleb-resnet34-LM) `pyannote/wespeaker-voxceleb-resnet34-LM` (PyTorch)  | embedding | 150ms     | 29ms      || [ü§ó](https://huggingface.co/speechbrain/spkrec-xvect-voxceleb) `speechbrain/spkrec-xvect-voxceleb`                        | embedding | 41ms      | 15ms      || [ü§ó](https://huggingface.co/speechbrain/spkrec-ecapa-voxceleb) `speechbrain/spkrec-ecapa-voxceleb`                        | embedding | 41ms      | 14ms      || [ü§ó](https://huggingface.co/speechbrain/spkrec-ecapa-voxceleb-mel-spec) `speechbrain/spkrec-ecapa-voxceleb-mel-spec`      | embedding | 42ms      | 14ms      || [ü§ó](https://huggingface.co/speechbrain/spkrec-resnet-voxceleb) `speechbrain/spkrec-resnet-voxceleb`                      | embedding | 41ms      | 16ms      || [ü§ó](https://huggingface.co/nvidia/speakerverification_en_titanet_large) `nvidia/speakerverification_en_titanet_large`    | embedding | 91ms      | 16ms      |The latency of segmentation models is measured in a VAD pipeline (5s chunks).The latency of embedding models is measured in a diarization pipeline using `pyannote/segmentation` (also 5s chunks).\* CPU: AMD Ryzen 9 - GPU: RTX 4060 Max-Q### Custom modelsThird-party models can be integrated by providing a loader function:```pythonfrom diart import SpeakerDiarization, SpeakerDiarizationConfigfrom diart.models import EmbeddingModel, SegmentationModeldef segmentation_loader():    # It should take a waveform and return a segmentation tensor    return load_pretrained_model(&quot;my_model.ckpt&quot;)def embedding_loader():    # It should take (waveform, weights) and return per-speaker embeddings    return load_pretrained_model(&quot;my_other_model.ckpt&quot;)segmentation = SegmentationModel(segmentation_loader)embedding = EmbeddingModel(embedding_loader)config = SpeakerDiarizationConfig(    segmentation=segmentation,    embedding=embedding,)pipeline = SpeakerDiarization(config)```If you have an ONNX model, you can use `from_onnx()`:```pythonfrom diart.models import EmbeddingModelembedding = EmbeddingModel.from_onnx(    model_path=&quot;my_model.ckpt&quot;,    input_names=[&quot;x&quot;, &quot;w&quot;],  # defaults to [&quot;waveform&quot;, &quot;weights&quot;]    output_name=&quot;output&quot;,  # defaults to &quot;embedding&quot;)```## üìà Tune hyper-parametersDiart implements an optimizer based on [optuna](https://optuna.readthedocs.io/en/stable/index.html) that allows you to tune pipeline hyper-parameters to your needs.### From the command line```shelldiart.tune /wav/dir --reference /rttm/dir --output /output/dir```See `diart.tune -h` for more options.### From python```pythonfrom diart.optim import Optimizeroptimizer = Optimizer(&quot;/wav/dir&quot;, &quot;/rttm/dir&quot;, &quot;/output/dir&quot;)optimizer(num_iter=100)```This will write results to an sqlite database in `/output/dir`.### Distributed tuningFor bigger datasets, it is sometimes more convenient to run multiple optimization processes in parallel.To do this, create a study on a [recommended DBMS](https://optuna.readthedocs.io/en/stable/tutorial/10_key_features/004_distributed.html#sphx-glr-tutorial-10-key-features-004-distributed-py) (e.g. MySQL or PostgreSQL) making sure that the study and database names match:```shellmysql -u root -e &quot;CREATE DATABASE IF NOT EXISTS example&quot;optuna create-study --study-name &quot;example&quot; --storage &quot;mysql://root@localhost/example&quot;```You can now run multiple identical optimizers pointing to this database:```shelldiart.tune /wav/dir --reference /rttm/dir --storage mysql://root@localhost/example```or in python:```pythonfrom diart.optim import Optimizerfrom optuna.samplers import TPESamplerimport optunadb = &quot;mysql://root@localhost/example&quot;study = optuna.load_study(&quot;example&quot;, db, TPESampler())optimizer = Optimizer(&quot;/wav/dir&quot;, &quot;/rttm/dir&quot;, study)optimizer(num_iter=100)```## üß†üîó Build pipelinesFor a more advanced usage, diart also provides building blocks that can be combined to create your own pipeline.Streaming is powered by [RxPY](https://github.com/ReactiveX/RxPY), but the `blocks` module is completely independent and can be used separately.### ExampleObtain overlap-aware speaker embeddings from a microphone stream:```pythonimport rx.operators as opsimport diart.operators as dopsfrom diart.sources import MicrophoneAudioSourcefrom diart.blocks import SpeakerSegmentation, OverlapAwareSpeakerEmbeddingsegmentation = SpeakerSegmentation.from_pretrained(&quot;pyannote/segmentation&quot;)embedding = OverlapAwareSpeakerEmbedding.from_pretrained(&quot;pyannote/embedding&quot;)mic = MicrophoneAudioSource()stream = mic.stream.pipe(    # Reformat stream to 5s duration and 500ms shift    dops.rearrange_audio_stream(sample_rate=segmentation.model.sample_rate),    ops.map(lambda wav: (wav, segmentation(wav))),    ops.starmap(embedding)).subscribe(on_next=lambda emb: print(emb.shape))mic.read()```Output:```# Shape is (batch_size, num_speakers, embedding_dim)torch.Size([1, 3, 512])torch.Size([1, 3, 512])torch.Size([1, 3, 512])...```## üåê WebSocketsDiart is also compatible with the WebSocket protocol to serve pipelines on the web.### From the command line```shelldiart.serve --host 0.0.0.0 --port 7007diart.client microphone --host &lt;server-address&gt; --port 7007```**Note:** make sure that the client uses the same `step` and `sample_rate` than the server with `--step` and `-sr`.See `-h` for more options.### From pythonFor customized solutions, a server can also be created in python using the `WebSocketAudioSource`:```pythonfrom diart import SpeakerDiarizationfrom diart.sources import WebSocketAudioSourcefrom diart.inference import StreamingInferencepipeline = SpeakerDiarization()source = WebSocketAudioSource(pipeline.config.sample_rate, &quot;localhost&quot;, 7007)inference = StreamingInference(pipeline, source)inference.attach_hooks(lambda ann_wav: source.send(ann_wav[0].to_rttm()))prediction = inference()```## üî¨ Powered by researchDiart is the official implementation of the paper[Overlap-aware low-latency online speaker diarization based on end-to-end local segmentation](https://github.com/juanmc2005/diart/blob/main/paper.pdf)by [Juan Manuel Coria](https://juanmc2005.github.io/),[Herv√© Bredin](https://herve.niderb.fr),[Sahar Ghannay](https://saharghannay.github.io/)and [Sophie Rosset](https://perso.limsi.fr/rosset/).&gt; We propose to address online speaker diarization as a combination of incremental clustering and local diarization applied to a rolling buffer updated every 500ms. Every single step of the proposed pipeline is designed to take full advantage of the strong ability of a recently proposed end-to-end overlap-aware segmentation to detect and separate overlapping speakers. In particular, we propose a modified version of the statistics pooling layer (initially introduced in the x-vector architecture) to give less weight to frames where the segmentation model predicts simultaneous speakers. Furthermore, we derive cannot-link constraints from the initial segmentation step to prevent two local speakers from being wrongfully merged during the incremental clustering step. Finally, we show how the latency of the proposed approach can be adjusted between 500ms and 5s to match the requirements of a particular use case, and we provide a systematic analysis of the influence of latency on the overall performance (on AMI, DIHARD and VoxConverse).&lt;p align=&quot;center&quot;&gt;&lt;img height=&quot;400&quot; src=&quot;https://github.com/juanmc2005/diart/blob/main/figure1.png?raw=true&quot; title=&quot;Visual explanation of the system&quot; width=&quot;325&quot; /&gt;&lt;/p&gt;### CitationIf you found diart useful, please make sure to cite our paper:```bibtex@inproceedings{diart,    author={Coria, Juan M. and Bredin, Herv√© and Ghannay, Sahar and Rosset, Sophie},    booktitle={2021 IEEE Automatic Speech Recognition and Understanding Workshop (ASRU)},     title={Overlap-Aware Low-Latency Online Speaker Diarization Based on End-to-End Local Segmentation},   year={2021},  pages={1139-1146},  doi={10.1109/ASRU51503.2021.9688044},}```### Reproducibility![Results table](https://github.com/juanmc2005/diart/blob/main/table1.png?raw=true)**Important:** We highly recommend installing `pyannote.audio&lt;3.1` to reproduce these results.For more information, see [this issue](https://github.com/juanmc2005/diart/issues/214).Diart aims to be lightweight and capable of real-time streaming in practical scenarios.Its performance is very close to what is reported in the paper (and sometimes even a bit better).To obtain the best results, make sure to use the following hyper-parameters:| Dataset     | latency | tau    | rho    | delta ||-------------|---------|--------|--------|-------|| DIHARD III  | any     | 0.555  | 0.422  | 1.517 || AMI         | any     | 0.507  | 0.006  | 1.057 || VoxConverse | any     | 0.576  | 0.915  | 0.648 || DIHARD II   | 1s      | 0.619  | 0.326  | 0.997 || DIHARD II   | 5s      | 0.555  | 0.422  | 1.517 |`diart.benchmark` and `diart.inference.Benchmark` can run, evaluate and measure the real-time latency of the pipeline. For instance, for a DIHARD III configuration:```shelldiart.benchmark /wav/dir --reference /rttm/dir --tau-active=0.555 --rho-update=0.422 --delta-new=1.517 --segmentation pyannote/segmentation@Interspeech2021```or using the inference API:```pythonfrom diart.inference import Benchmark, Parallelizefrom diart import SpeakerDiarization, SpeakerDiarizationConfigfrom diart.models import SegmentationModelbenchmark = Benchmark(&quot;/wav/dir&quot;, &quot;/rttm/dir&quot;)model_name = &quot;pyannote/segmentation@Interspeech2021&quot;model = SegmentationModel.from_pretrained(model_name)config = SpeakerDiarizationConfig(    # Set the segmentation model used in the paper    segmentation=model,    step=0.5,    latency=0.5,    tau_active=0.555,    rho_update=0.422,    delta_new=1.517)benchmark(SpeakerDiarization, config)# Run the same benchmark in parallelp_benchmark = Parallelize(benchmark, num_workers=4)if __name__ == &quot;__main__&quot;:  # Needed for multiprocessing    p_benchmark(SpeakerDiarization, config)```This pre-calculates model outputs in batches, so it runs a lot faster.See `diart.benchmark -h` for more options.For convenience and to facilitate future comparisons, we also provide the&lt;a href=&quot;https://github.com/juanmc2005/diart/tree/main/expected_outputs&quot;&gt;expected outputs&lt;/a&gt;of the paper implementation in RTTM format for every entry of Table 1 and Figure 5.This includes the VBx offline topline as well as our proposed online approach withlatencies 500ms, 1s, 2s, 3s, 4s, and 5s.![Figure 5](https://github.com/juanmc2005/diart/blob/main/figure5.png?raw=true)## üìë License```MIT LicenseCopyright (c) 2021 Universit√© Paris-SaclayCopyright (c) 2021 CNRSPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.```&lt;p style=&quot;color:grey;font-size:14px;&quot;&gt;Logo generated by &lt;a href=&quot;https://www.designevo.com/&quot; title=&quot;Free Online Logo Maker&quot;&gt;DesignEvo free logo designer&lt;/a&gt;&lt;/p&gt;</longdescription>
</pkgmetadata>