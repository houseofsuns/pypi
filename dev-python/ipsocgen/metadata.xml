<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># IP SoC Generator**IP SoC gen** is a framework to generate MP/SoCs with different configurations through a set of masters/slaves for fastdigital design development. To install through pip: ```bashpip install --upgrade ipsocgen```## Template projects In order to get started generating your own designs, check the [templaterepository](https://github.com/aignacio/ipsocgen_template) which contains an example of SoC and MPSoC using[NoX](https://github.com/aignacio/nox)processor as the main CPU. The configuration files that were used for the **ipsocgen_template** are available in [`ipsocgen/examples/template_soc.yaml`](ipsocgen/examples/template_soc.yaml) and [`ipsocgen/examples/template_mpsoc.yaml`](ipsocgen/examples/template_mpsoc.yaml).## To contribute/develop/extend the workPlease follow the steps below to build the virtual environment and install the dependencies.```bashpython3 -m venv venvsource venv/bin/activate python3 setup.py install```## Configuration file referenceHere is a list of all inputs that can be listed for the IPSoCGen configuration file in yaml format.```yamlproj_name:                #Project Namedesc:                   #Short descriptiontype:                     #System type (soc or mpsoc)###################### If type == soc#####################soc_desc:  bus_name:            #Name for the bus Interconnect  bus_type:            #Type of the bus  addr_width:           #Bus adress width  data_width:          #Bus data width  txn_id_width:          #Bus transaction ID width  num_masters:          #Number of master in the bus (min == 1)  num_slaves:            #Number of slave in the bus (min == 1)  proc_required:        #Set if a processor is required (y or n)  mmap_type:             #Memory map type (manual or auto)  clk:    name:             #Clock name    clk_int:           #Internal signal name for the clock    io_in_clk:         #Wrapper input pin for the clock    type:              #Type of clock (pll or direct)    pll:              #Only applicable if type == pll      divclk_divide:      #PLL parameters      clkfbout_mult:    #PLL parameters      clkout_divide:    #PLL parameters      io_rst_pin:         #Wrapper input pin for the PLL reset      rst_in_type:        #Type of reset for the PLL (act_l or act_h)      clkin_period:       #PLL parameters  rst:     name:             #Reset name    rst_int:          #Internal signal name for the reset    io_in_rst:         #Wrapper input pin for the reset    rst_in_type:        #Type of reset for the PLL (act_l or act_h)    type:             #Type of reset (acc_rst or direct)  proc:    name:             #Name of the main CPU that will be used    type:              #Type of processor (nox, vex…)    clk:               #Describe the clock of the processor    rst:               #Describe the reset of the processor    boot:              #Describe the boot for this processor      type:            #Type of boot (slave, value or signal)      signal:           #Only applicable if type == signal      slave:           #Only applicable if type == slave      value:            #Only applicable if type == value    irq_mapping:      timer:          #Internal signal name for RV timer interrupts      software:       #Internal signal name for RV software interrupts      external:       #Internal signal name for RV external interrupts  masters:            #Describe all masters within the system    x:                #Master ID, start always from 0      name:           #Unique name for the instance      desc:           #Brief description of the master I/F      type:           #Master type      if:             #Interface name (must be a valid one supported)    ...  slaves:    x:                #Slave ID, start always from 0      name:           #Unique name for the instance      desc:           #Brief description of the slave      type:            #Slave type      base_addr:        #Base address if mmap_type == manual      addr_width:        #Base address if mmap_type == manual      mem_size_kib:      #Slave kib size, only applicable if type == ram_mem/rom_mem/acc_custom_slave      irq_timer:      #Timer internal signal name, only applicable if type == acc_timer      rst_def_addr:      #Reset default address, only applicable if type == acc_rst      rst_addr_out:      #Reset address signal name [usually for CPUs], only applicable if type == acc_rst      rst_pulse_width:   #Reset address signal name [usually for CPUs], only applicable if type == acc_rst      io_bootloader:    #Wrapper input pin for the bootloader, only applicable if type == acc_rst      bootloader_type:    #Bootloader type (act_l or act_h), only applicable if type == acc_rst      irq_dma_done:      #Internal signal name for the DMA done IRQ, only applicable if type == acc_dma      irq_dma_error:    #Internal signal name for the DMA error IRQ, only applicable if type == acc_dma      io_tx:          #Wrapper output pin for the UART TX, only applicable if type == acc_uart      io_rx:          #Wrapper input pin for the UART TX, only applicable if type == acc_uart      irq_uart_rx:      #Internal signal name for the UART IRQ, only applicable if type == acc_uart      irq_type:        #IRQ type (0-level, 1-edge) for all incomming IRQs, only applicable if type == acc_irq      irq_summary:      #Internal signal name for the IRQ summary, only applicable if type == acc_irq      vec_mapping:      #List of all internal signal names for the IRQ vector, only applicable if type == acc_irq         - highest_prior_irq_1         - …         - lowest_prior_irq_n      irq_noc:        #Internal signal name for the NoC IRQ, only applicable if type == acc_noc      pkt_recv_irq:      #Internal signal name for the Received Packet IRQ, only applicable if type == acc_eth      pkt_sent_irq:      #Internal signal name for the Packet sent IRQ, only applicable if type == acc_eth      pkt_recv_full_irq:#Internal signal name for the Full FIFO Recv. Packet IRQ, only applicable if type == acc_eth      eth_type:        #Ethernet slave type (csr, infifo or outfifo), only applicable if type == acc_eth    ...###################### If type == mpsoc#####################mpsoc_desc:  clk:    name:             #Clock name    clk_int:           #Internal signal name for the clock    io_in_clk:         #Wrapper input pin for the clock    type:              #Type of clock (pll or direct)    pll:              #Only applicable if type == pll      divclk_divide:      #PLL parameters      clkfbout_mult:    #PLL parameters      clkout_divide:    #PLL parameters      io_rst_pin:         #Wrapper input pin for the PLL reset      rst_in_type:        #Type of reset for the PLL (act_l or act_h)      clkin_period:       #PLL parameters  rst:     name:             #Reset name    rst_int:          #Internal signal name for the reset    io_in_rst:         #Wrapper input pin for the reset    rst_in_type:        #Type of reset for the PLL (act_l or act_h)    type:             #Type of reset (acc_rst or direct)  noc:    type:                 #Type of the noc (currently only ravenoc is available)    name:                 #Unique name for the NoC instance    size_x:               #Num. of rows    size_y:               #Num. of collumns    flit_data_width:      #Data width of the flit    flit_buff:            #Num. of flit buffers    h_priority:           #Priority of the virtual channels (ZeroHighPrior or ZeroLowPrior)    n_virt_chn:           #Num. of virtual channels    routing_alg:          #Routing algorithm (XYAlg or YXAlg)    max_sz_pkt:           #Max. size of packet in flits (usually 256)    base_addr:            #NoC common base address across all Tiles  tiles:    x:                    #Tile ID, always start from zero      ....                #Same description pattern as soc_desc```</longdescription>
</pkgmetadata>