<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Eventy* Source: [Eventy on GitLab](https://gitlab.com/qotto/oss/eventy)* Package: [Eventy on Pypi](https://pypi.org/project/eventy/)* Documentation: [Eventy API documentation](https://qotto.gitlab.io/oss/eventy/)## What is Eventy?Eventy is both a protocol and a library for making the design of fault-tolerant, event-driven, concurrent anddistributed applications in a microservices-oriented architecture easier.As a protocol, Eventy is language-agnostic.However, the reference implementation is written in Python. Whatever is your programming language, you can use Eventy.If you are using Python, you will be able to make the most of it quicker.## MotivationThe reality is, a distributed, microservices-oriented architecture is a bit hard to make right.Martin Fowler even [ended up stating](https://www.drdobbs.com/errant-architectures/184414966):&gt; First Law of Distributed Object Design: “don't distribute your objects”.He later [detailed his view](https://martinfowler.com/articles/distributed-objects-microservices.html) of the First Lawregarding microservices.As Martin Folwer points out, inherently microservices come with their undeniable advantages and a few companies use themwith great success. The only reason why a lot of people end up struggling with microservices, is because it greatlyincreases the complexity of the whole system, which makes it harder to get it right.Eventy is adressing exactly that issue — providing you with a reliable framework to make microservices work for you.A big part of the design process to create Eventy was to understand different use cases and see how the design can besimplified. For instance, not only does Eventy offer state partitionning for free, it actually comes up with a fewstratagies that eliminate the need to persist state altogether.## Inspiration[Kafka Streams](https://kafka.apache.org/documentation/streams/) was a great influence in makingEventy. [Celery](http://www.celeryproject.org/) and [Faust](https://github.com/robinhood/faust) are also worth to belooked at if you are looking for an opiniated framework easy to get started with.However, these frameworks only partially solve all the issues you will have with microservices. And, in our opinion,these frameworks are not suitable for designing large critical systems.They're both opinanated, and therefore cannot be easily integrated in your existing software. You will have to buildyour software around the framework, instead of the other way around. They also don't give you the full control on theway you can use them: you can only use them as a whole, or not at all.## What Eventy can do for youEventy implements multiple features, but all of them simply solve two main problems:* How to make services communicate with each other* How to access and persist stateWith Eventy, you can serialize data the way you want. You can use [Avro](https://avro.apache.org/), [JSON](https://www.json.org/), [gRPC](https://grpc.io/), or whatever customer serializer you like.With Eventy, you can use any system you like as a persistency layer, as long as it supports transactions, if you needstrong processing guarantees. The most obvious choice is to use [Apache Kafka](https://kafka.apache.org/), butpersisting messages over [PostgreSQL](https://www.postgresql.org/) is completely feasable, too.Eventy was destined with the mindset of a library of related but independently usable components - and not a framework:the behaviour is explicit and you're the one in charge: you can design your software your own way.This explicit behaviour, albeit requiring more boilerplate, gives you better clarity on what is happening. Recipes andexamples are provided so that you can understand how to use Eventy for most use cases.You're free to use any part of Eventy as well. Even if you end up not using the Eventy protocol at all, simply readingthe documentation and understanding the issues that are adressed and how they are adressed can help you to get on theright path.## Main components of Eventy* a **well-defined communication protocol** for sending various types of persisted messages, called _Records_: _Events_  , _Requests_ and _Responses_* **persistency of _Records_** that can be stored forever, which lets you keep track of all the changes in your system (  especially useful for audits and business analytics)* **queues** so that _Records_ can be processed asynchroneously, and aren't lost even if your system is down or  overloaded* **strong processing guarantees**: a Record can be designed to be processed _at least once_, _at most once_ and _  exactly once_ even if your system encounters a process or network failure at any point* **self-propagating _Contexts_** that in many cases entirely eliminate the need of persisting state* **partitionned state persistency** so that you no longer have a single point of failure in your system (aka _the  database_) and can scale up as your business grows# ContributeInstall with dev dependencies```poetry install -E celery -E sanic -E aiohttp -E django -E confluent-kafka -E avro -E requests```The project uses [poetry](https://python-poetry.org/)```poetry config pypi-token.pypi my-tokenpoetry config testpypi-token.pypi my-token```</longdescription>
</pkgmetadata>