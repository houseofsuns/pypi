<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;br/&gt;&lt;p align=&quot;center&quot;&gt;&lt;img width=&quot;40%&quot; src=&quot;/logo.jpg&quot; title=&quot;Logo&quot; /&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;img alt=&quot;PyPI Version&quot; src=&quot;https://img.shields.io/pypi/v/diart?color=g&quot;&gt;&lt;img alt=&quot;PyPI Downloads&quot; src=&quot;https://static.pepy.tech/personalized-badge/diart?period=total&amp;units=international_system&amp;left_color=grey&amp;right_color=brightgreen&amp;left_text=downloads&quot;&gt;&lt;img alt=&quot;Top language&quot; src=&quot;https://img.shields.io/github/languages/top/juanmc2005/StreamingSpeakerDiarization?color=g&quot;&gt;&lt;img alt=&quot;Code size in bytes&quot; src=&quot;https://img.shields.io/github/languages/code-size/juanmc2005/StreamingSpeakerDiarization?color=g&quot;&gt;&lt;img alt=&quot;License&quot; src=&quot;https://img.shields.io/github/license/juanmc2005/StreamingSpeakerDiarization?color=g&quot;&gt;&lt;/p&gt;&lt;div align=&quot;center&quot;&gt;  &lt;h4&gt;    &lt;a href=&quot;#installation&quot;&gt;      Installation    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#stream-audio&quot;&gt;      Stream audio    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#custom-models&quot;&gt;      Custom models    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#tune-hyper-parameters&quot;&gt;      Tune hyper-parameters    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#build-pipelines&quot;&gt;      Build pipelines    &lt;/a&gt;    &lt;br/&gt;    &lt;a href=&quot;#websockets&quot;&gt;      WebSockets    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#powered-by-research&quot;&gt;      Research    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#citation&quot;&gt;      Citation    &lt;/a&gt;    &lt;span&gt; | &lt;/span&gt;    &lt;a href=&quot;#reproducibility&quot;&gt;      Reproducibility    &lt;/a&gt;  &lt;/h4&gt;&lt;/div&gt;&lt;br/&gt;&lt;p align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;/demo.gif&quot; title=&quot;Real-time diarization example&quot; /&gt;&lt;/p&gt;## Installation1) Create environment:```shellconda create -n diart python=3.8conda activate diart```2) Install audio libraries:```shellconda install portaudio pysoundfile ffmpeg -c conda-forge```3) Install diart:```shellpip install diart```### Get access to pyannote modelsBy default, diart is based on [pyannote.audio](https://github.com/pyannote/pyannote-audio) models stored in the [huggingface](https://huggingface.co/) hub.To allow diart to use them, you need to follow these steps:1) [Accept user conditions](https://huggingface.co/pyannote/segmentation) for the `pyannote/segmentation` model2) [Accept user conditions](https://huggingface.co/pyannote/embedding) for the `pyannote/embedding` model3) Install [huggingface-cli](https://huggingface.co/docs/huggingface_hub/quick-start#install-the-hub-library) and [log in](https://huggingface.co/docs/huggingface_hub/quick-start#login) with your user access token (or provide it manually in diart CLI or API).## Stream audio### From the command lineA recorded conversation:```shelldiart.stream /path/to/audio.wav```A live conversation:```shell# Use &quot;microphone:ID&quot; to select a non-default device# See `python -m sounddevice` for available devicesdiart.stream microphone```See `diart.stream -h` for more options.### From pythonUse `RealTimeInference` to easily run a pipeline on an audio source and write the results to disk:```pythonfrom diart import OnlineSpeakerDiarizationfrom diart.sources import MicrophoneAudioSourcefrom diart.inference import RealTimeInferencefrom diart.sinks import RTTMWriterpipeline = OnlineSpeakerDiarization()mic = MicrophoneAudioSource(pipeline.config.sample_rate)inference = RealTimeInference(pipeline, mic, do_plot=True)inference.attach_observers(RTTMWriter(mic.uri, &quot;/output/file.rttm&quot;))prediction = inference()```For inference and evaluation on a dataset we recommend to use `Benchmark` (see notes on [reproducibility](#reproducibility)).## Custom modelsThird-party models can be integrated seamlessly by subclassing `SegmentationModel` and `EmbeddingModel` (which are PyTorch `Module` subclasses):```pythonfrom diart import OnlineSpeakerDiarization, PipelineConfigfrom diart.models import EmbeddingModel, SegmentationModelfrom diart.sources import MicrophoneAudioSourcefrom diart.inference import RealTimeInferencedef model_loader():    return load_pretrained_model(&quot;my_model.ckpt&quot;)class MySegmentationModel(SegmentationModel):    def __init__(self):        super().__init__(model_loader)        @property    def sample_rate(self) -&gt; int:        return 16000        @property    def duration(self) -&gt; float:        return 2  # seconds        def forward(self, waveform):        # self.model is created lazily        return self.model(waveform)    class MyEmbeddingModel(EmbeddingModel):    def __init__(self):        super().__init__(model_loader)        def forward(self, waveform, weights):        # self.model is created lazily        return self.model(waveform, weights)    config = PipelineConfig(    segmentation=MySegmentationModel(),    embedding=MyEmbeddingModel())pipeline = OnlineSpeakerDiarization(config)mic = MicrophoneAudioSource(config.sample_rate)inference = RealTimeInference(pipeline, mic)prediction = inference()```## Tune hyper-parametersDiart implements a hyper-parameter optimizer based on [optuna](https://optuna.readthedocs.io/en/stable/index.html) that allows you to tune any pipeline to any dataset.### From the command line```shelldiart.tune /wav/dir --reference /rttm/dir --output /output/dir```See `diart.tune -h` for more options.### From python```pythonfrom diart.optim import Optimizeroptimizer = Optimizer(&quot;/wav/dir&quot;, &quot;/rttm/dir&quot;, &quot;/output/dir&quot;)optimizer(num_iter=100)```This will write results to an sqlite database in `/output/dir`.### Distributed optimizationFor bigger datasets, it is sometimes more convenient to run multiple optimization processes in parallel.To do this, create a study on a [recommended DBMS](https://optuna.readthedocs.io/en/stable/tutorial/10_key_features/004_distributed.html#sphx-glr-tutorial-10-key-features-004-distributed-py) (e.g. MySQL or PostgreSQL) making sure that the study and database names match:```shellmysql -u root -e &quot;CREATE DATABASE IF NOT EXISTS example&quot;optuna create-study --study-name &quot;example&quot; --storage &quot;mysql://root@localhost/example&quot;```You can now run multiple identical optimizers pointing to this database:```shelldiart.tune /wav/dir --reference /rttm/dir --storage mysql://root@localhost/example```or in python:```pythonfrom diart.optim import Optimizerfrom optuna.samplers import TPESamplerimport optunadb = &quot;mysql://root@localhost/example&quot;study = optuna.load_study(&quot;example&quot;, db, TPESampler())optimizer = Optimizer(&quot;/wav/dir&quot;, &quot;/rttm/dir&quot;, study)optimizer(num_iter=100)```## Build pipelinesFor a more advanced usage, diart also provides building blocks that can be combined to create your own pipeline.Streaming is powered by [RxPY](https://github.com/ReactiveX/RxPY), but the `blocks` module is completely independent and can be used separately.### ExampleObtain overlap-aware speaker embeddings from a microphone stream:```pythonimport rx.operators as opsimport diart.operators as dopsfrom diart.sources import MicrophoneAudioSourcefrom diart.blocks import SpeakerSegmentation, OverlapAwareSpeakerEmbeddingsegmentation = SpeakerSegmentation.from_pyannote(&quot;pyannote/segmentation&quot;)embedding = OverlapAwareSpeakerEmbedding.from_pyannote(&quot;pyannote/embedding&quot;)sample_rate = segmentation.model.sample_ratemic = MicrophoneAudioSource(sample_rate)stream = mic.stream.pipe(    # Reformat stream to 5s duration and 500ms shift    dops.rearrange_audio_stream(sample_rate=sample_rate),    ops.map(lambda wav: (wav, segmentation(wav))),    ops.starmap(embedding)).subscribe(on_next=lambda emb: print(emb.shape))mic.read()```Output:```# Shape is (batch_size, num_speakers, embedding_dim)torch.Size([1, 3, 512])torch.Size([1, 3, 512])torch.Size([1, 3, 512])...```## WebSocketsDiart is also compatible with the WebSocket protocol to serve pipelines on the web.### From the command line```commandlinediart.serve --host 0.0.0.0 --port 7007diart.client microphone --host &lt;server-address&gt; --port 7007```**Note:** please make sure that the client uses the same `step` and `sample_rate` than the server with `--step` and `-sr`.See `-h` for more options.### From pythonFor customized solutions, a server can also be created in python using the `WebSocketAudioSource`:```pythonfrom diart import OnlineSpeakerDiarizationfrom diart.sources import WebSocketAudioSourcefrom diart.inference import RealTimeInferencepipeline = OnlineSpeakerDiarization()source = WebSocketAudioSource(pipeline.config.sample_rate, &quot;localhost&quot;, 7007)inference = RealTimeInference(pipeline, source)inference.attach_hooks(lambda ann_wav: source.send(ann_wav[0].to_rttm()))prediction = inference()```## Powered by researchDiart is the official implementation of the paper *[Overlap-aware low-latency online speaker diarization based on end-to-end local segmentation](/paper.pdf)* by [Juan Manuel Coria](https://juanmc2005.github.io/), [Hervé Bredin](https://herve.niderb.fr), [Sahar Ghannay](https://saharghannay.github.io/) and [Sophie Rosset](https://perso.limsi.fr/rosset/).&gt; We propose to address online speaker diarization as a combination of incremental clustering and local diarization applied to a rolling buffer updated every 500ms. Every single step of the proposed pipeline is designed to take full advantage of the strong ability of a recently proposed end-to-end overlap-aware segmentation to detect and separate overlapping speakers. In particular, we propose a modified version of the statistics pooling layer (initially introduced in the x-vector architecture) to give less weight to frames where the segmentation model predicts simultaneous speakers. Furthermore, we derive cannot-link constraints from the initial segmentation step to prevent two local speakers from being wrongfully merged during the incremental clustering step. Finally, we show how the latency of the proposed approach can be adjusted between 500ms and 5s to match the requirements of a particular use case, and we provide a systematic analysis of the influence of latency on the overall performance (on AMI, DIHARD and VoxConverse).&lt;p align=&quot;center&quot;&gt;&lt;img height=&quot;400&quot; src=&quot;/figure1.png&quot; title=&quot;Visual explanation of the system&quot; width=&quot;325&quot; /&gt;&lt;/p&gt;## CitationIf you found diart useful, please make sure to cite our paper:```bibtex@inproceedings{diart,    author={Coria, Juan M. and Bredin, Hervé and Ghannay, Sahar and Rosset, Sophie},    booktitle={2021 IEEE Automatic Speech Recognition and Understanding Workshop (ASRU)},     title={Overlap-Aware Low-Latency Online Speaker Diarization Based on End-to-End Local Segmentation},   year={2021},  pages={1139-1146},  doi={10.1109/ASRU51503.2021.9688044},}```##  Reproducibility![Results table](/table1.png)Diart aims to be lightweight and capable of real-time streaming in practical scenarios.Its performance is very close to what is reported in the paper (and sometimes even a bit better).To obtain the best results, make sure to use the following hyper-parameters:| Dataset     | latency | tau    | rho    | delta ||-------------|---------|--------|--------|-------|| DIHARD III  | any     | 0.555  | 0.422  | 1.517 || AMI         | any     | 0.507  | 0.006  | 1.057 || VoxConverse | any     | 0.576  | 0.915  | 0.648 || DIHARD II   | 1s      | 0.619  | 0.326  | 0.997 || DIHARD II   | 5s      | 0.555  | 0.422  | 1.517 |`diart.benchmark` and `diart.inference.Benchmark` can run, evaluate and measure the real-time latency of the pipeline. For instance, for a DIHARD III configuration:```shelldiart.benchmark /wav/dir --reference /rttm/dir --tau=0.555 --rho=0.422 --delta=1.517 --segmentation pyannote/segmentation@Interspeech2021```or using the inference API:```pythonfrom diart.inference import Benchmark, Parallelizefrom diart import OnlineSpeakerDiarization, PipelineConfigfrom diart.models import SegmentationModelbenchmark = Benchmark(&quot;/wav/dir&quot;, &quot;/rttm/dir&quot;)name = &quot;pyannote/segmentation@Interspeech2021&quot;segmentation = SegmentationModel.from_pyannote(name)config = PipelineConfig(    # Set the model used in the paper    segmentation=segmentation,    step=0.5,    latency=0.5,    tau_active=0.555,    rho_update=0.422,    delta_new=1.517)benchmark(OnlineSpeakerDiarization, config)# Run the same benchmark in parallelp_benchmark = Parallelize(benchmark, num_workers=4)if __name__ == &quot;__main__&quot;:  # Needed for multiprocessing    p_benchmark(OnlineSpeakerDiarization, config)```This pre-calculates model outputs in batches, so it runs a lot faster.See `diart.benchmark -h` for more options.For convenience and to facilitate future comparisons, we also provide the [expected outputs](/expected_outputs) of the paper implementation in RTTM format for every entry of Table 1 and Figure 5. This includes the VBx offline topline as well as our proposed online approach with latencies 500ms, 1s, 2s, 3s, 4s, and 5s.![Figure 5](/figure5.png)##  License```MIT LicenseCopyright (c) 2021 Université Paris-SaclayCopyright (c) 2021 CNRSPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.```&lt;p&gt;Logo generated by &lt;a href=&quot;https://www.designevo.com/&quot; title=&quot;Free Online Logo Maker&quot;&gt;DesignEvo free logo designer&lt;/a&gt;&lt;/p&gt;</longdescription>
</pkgmetadata>