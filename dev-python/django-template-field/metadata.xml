<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=============================django-template-field=============================.. image:: https://badge.fury.io/py/django-template-field.png    :target: https://badge.fury.io/py/django-template-field.. image:: https://travis-ci.org/orcasgit/django-template-field.png?branch=master    :target: https://travis-ci.org/orcasgit/django-template-fieldA Django template field with a manager to return the rendered template.Documentation-------------The full documentation is at https://django-template-field.readthedocs.org.Quickstart----------Install django-template-field::    pip install django-template-fieldThen use it in a project::    from django.db import models    from templatefield import fields, managers    class TemplatedText(models.Model):        value = fields.TemplateTextField()        # Manager that returns rendered templates. This will be the default        # manager since it is first. Now, when accessed via `Related Models`_        # this field will also be rendered.        objects_rendered = managers.RenderTemplateManager()        # Django's default manager returns unrendered templates.        objects_unrendered = models.Manager()Extra context can be added in ``settings`` like so:    TEMPLATE_FIELD_CONTEXT = { 'template_var': value }Context can also be added to querysets like so:    TemplatedText.objects_rendered.with_context({'template_var2': value2})If you dump fixtures with ``RenderTemplateManager`` as the default manager,django will render the exported data. To work around that, create an alternatesettings file for your project with the following setting:    TEMPLATE_FIELD_RENDER = FalseThen you can dump your unrendered data like so:    ./manage.py dumpdata myapp.mymodel --settings=myapp.dump_settingsRelated Models--------------If a ``TemplateTextField`` will be accessed from another model through a``ForeignKey`` relationship, Django will use the default manager to render the``TemplateTextField``. For example, if we define this additional model:    class RelatedToTemplatedText(models.Model):        templated_text = models.ForeignKey(TemplatedText)We can expect to see fields accessed via ``templated_text`` rendered properly.Admin-----Using ``RenderTemplateManager`` as the default has the unfortunate side effectof rendering your fields in the Django admin, so we have provided a class fromwhich you can inherit to solve that problem. Ex:    from templatefield import admin    class TemplatedTextAdmin(admin.UnrenderedAdmin):        ...Running Tests--------------    source &lt;YOURVIRTUALENV&gt;/bin/activate    (myenv) $ pip install -r requirements/test.txt    (myenv) $ python runtests.pyHistory-------0.3.1 (2016-01-11)++++++++++++++++++* Add setting to disable rendering0.3.0 (2016-01-06)++++++++++++++++++* Enable rendering in related field access0.2.0 (2015-10-23)++++++++++++++++++* Add `with_context` to `RenderTemplateManager`0.1.0 (2015-10-02)++++++++++++++++++* First release on PyPI.</longdescription>
</pkgmetadata>