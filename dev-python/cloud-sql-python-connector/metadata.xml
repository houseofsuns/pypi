<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://cloud.google.com/blog/topics/developers-practitioners/how-connect-cloud-sql-using-python-easy-way&quot;&gt;        &lt;img src=&quot;https://raw.githubusercontent.com/GoogleCloudPlatform/cloud-sql-python-connector/main/docs/images/cloud-sql-python-connector.png&quot; alt=&quot;cloud-sql-python-connector image&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;h1 align=&quot;center&quot;&gt;Cloud SQL Python Connector&lt;/h1&gt;[![Open In Colab][colab-badge]][colab-notebook][![CI][ci-badge]][ci-build][![pypi][pypi-badge]][pypi-docs][![PyPI download month][pypi-downloads]][pypi-docs][![python][python-versions]][pypi-docs][colab-badge]: https://colab.research.google.com/assets/colab-badge.svg[colab-notebook]: https://colab.research.google.com/github/GoogleCloudPlatform/cloud-sql-python-connector/blob/main/samples/notebooks/postgres_python_connector.ipynb[ci-badge]: https://github.com/GoogleCloudPlatform/cloud-sql-python-connector/actions/workflows/tests.yml/badge.svg?event=push[ci-build]: https://github.com/GoogleCloudPlatform/cloud-sql-python-connector/actions/workflows/tests.yml?query=event%3Apush+branch%3Amain[pypi-badge]: https://img.shields.io/pypi/v/cloud-sql-python-connector[pypi-docs]: https://pypi.org/project/cloud-sql-python-connector[pypi-downloads]: https://img.shields.io/pypi/dm/cloud-sql-python-connector.svg[python-versions]: https://img.shields.io/pypi/pyversions/cloud-sql-python-connectorThe _Cloud SQL Python Connector_ is a Cloud SQL connector designed for use with thePython language. Using a Cloud SQL connector provides the following benefits:* **IAM Authorization:** uses IAM permissions to control who/what can connect to  your Cloud SQL instances* **Improved Security:** uses robust, updated TLS 1.3 encryption and  identity verification between the client connector and the server-side proxy,  independent of the database protocol.* **Convenience:** removes the requirement to use and distribute SSL  certificates, as well as manage firewalls or source/destination IP addresses.* (optionally) **IAM DB Authentication:** provides support for  [Cloud SQL’s automatic IAM DB AuthN][iam-db-authn] feature.[iam-db-authn]: https://cloud.google.com/sql/docs/postgres/authenticationThe Cloud SQL Python Connector is a package to be used alongside a database driver.Currently supported drivers are: - [`pymysql`](https://github.com/PyMySQL/PyMySQL) (MySQL) - [`pg8000`](https://github.com/tlocke/pg8000) (PostgreSQL) - [`asyncpg`](https://github.com/MagicStack/asyncpg) (PostgreSQL) - [`pytds`](https://github.com/denisenkom/pytds) (SQL Server)## InstallationYou can install this library with `pip install`, specifying the driverbased on your database dialect.### MySQL```pip install &quot;cloud-sql-python-connector[pymysql]&quot;```### PostgresThere are two different database drivers that are supported for the Postgres dialect:#### pg8000```pip install &quot;cloud-sql-python-connector[pg8000]&quot;```#### asyncpg```pip install &quot;cloud-sql-python-connector[asyncpg]&quot;```### SQL Server```pip install &quot;cloud-sql-python-connector[pytds]&quot;```## UsageThis package provides several functions for authorizing and encryptingconnections. These functions are used with your database driver to connect toyour Cloud SQL instance.The instance connection name for your Cloud SQL instance is always in theformat &quot;project:region:instance&quot;.### APIs and ServicesThis package requires the following to successfully make Cloud SQL Connections:- IAM principal (user, service account, etc.) with the[Cloud SQL Client][client-role] role. This IAM principal will be used for[credentials](#credentials).- The [Cloud SQL Admin API][admin-api] to be enabled within your Google CloudProject. By default, the API will be called in the project associated withthe IAM principal.[admin-api]: https://console.cloud.google.com/apis/api/sqladmin.googleapis.com[client-role]: https://cloud.google.com/sql/docs/mysql/roles-and-permissions### CredentialsThis library uses the [Application Default Credentials (ADC)][adc] strategy forresolving credentials. Please see [these instructions for how to set your ADC][set-adc](Google Cloud Application vs Local Development, IAM user vs service account credentials),or consult the [google.auth][google-auth] package.To explicitly set a specific source for the credentials, see[Configuring the Connector](#configuring-the-connector) below.[adc]: https://cloud.google.com/docs/authentication#adc[set-adc]: https://cloud.google.com/docs/authentication/provide-credentials-adc[google-auth]: https://google-auth.readthedocs.io/en/master/reference/google.auth.html### How to use this ConnectorTo connect to Cloud SQL using the connector, inititalize a `Connector`object and call it's `connect` method with the proper input parameters.The `Connector` itself creates connection objects by calling its `connect` method but does not manage database connection pooling. For this reason, it is recommended to use the connector alongside a library that can create connection pools, such as [SQLAlchemy](https://www.sqlalchemy.org/). This will allow for connections to remain open and be reused, reducing connection overhead and the number of connections needed.In the Connector's `connect` method below, input your connection string as the first positional argument and the name of the database driver for the second positional argument. Insert the rest of your connection keyword arguments like user, password and database. You can also set the optional `timeout` or `ip_type` keyword arguments.To use this connector with SQLAlchemy, use the `creator` argument for `sqlalchemy.create_engine`:```pythonfrom google.cloud.sql.connector import Connectorimport sqlalchemy# initialize Connector objectconnector = Connector()# function to return the database connectiondef getconn() -&gt; pymysql.connections.Connection:    conn: pymysql.connections.Connection = connector.connect(        &quot;project:region:instance&quot;,        &quot;pymysql&quot;,        user=&quot;my-user&quot;,        password=&quot;my-password&quot;,        db=&quot;my-db-name&quot;    )    return conn# create connection poolpool = sqlalchemy.create_engine(    &quot;mysql+pymysql://&quot;,    creator=getconn,)```The returned connection pool engine can then be used to query and modify the database.```python# insert statementinsert_stmt = sqlalchemy.text(    &quot;INSERT INTO my_table (id, title) VALUES (:id, :title)&quot;,)with pool.connect() as db_conn:    # insert into database    db_conn.execute(insert_stmt, parameters={&quot;id&quot;: &quot;book1&quot;, &quot;title&quot;: &quot;Book One&quot;})    # query database    result = db_conn.execute(sqlalchemy.text(&quot;SELECT * from my_table&quot;)).fetchall()    # commit transaction (SQLAlchemy v2.X.X is commit as you go)    db_conn.commit()    # Do something with the results    for row in result:        print(row)```To close the `Connector` object's background resources, call it's `close()` method as follows:```pythonconnector.close()```**Note**: For more examples of using SQLAlchemy to manage connection pooling with the connector, please see [Cloud SQL SQLAlchemy Samples](https://cloud.google.com/sql/docs/postgres/connect-connectors#python_1).**Note for SQL Server users**: If your SQL Server instance requires SSL, you need to download the CA certificate for your instance and include `cafile={path to downloaded certificate}` and `validate_host=False`. This is a workaround for a [known issue](https://issuetracker.google.com/184867147).### Configuring the ConnectorIf you need to customize something about the connector, or want to specifydefaults for each connection to make, you can initialize a`Connector` object as follows:```pythonfrom google.cloud.sql.connector import Connector, IPTypes# Note: all parameters below are optionalconnector = Connector(    ip_type=IPTypes.PUBLIC,    enable_iam_auth=False,    timeout=30,    credentials=custom_creds # google.auth.credentials.Credentials)```### Using Connector as a Context ManagerThe `Connector` object can also be used as a context manager in order toautomatically close and cleanup resources, removing the need for explicitcalls to `connector.close()`.Connector as a context manager:```pythonfrom google.cloud.sql.connector import Connectorimport sqlalchemy# build connectiondef getconn() -&gt; pymysql.connections.Connection:    with Connector() as connector:        conn = connector.connect(            &quot;project:region:instance&quot;,            &quot;pymysql&quot;,            user=&quot;my-user&quot;,            password=&quot;my-password&quot;,            db=&quot;my-db-name&quot;        )    return conn# create connection poolpool = sqlalchemy.create_engine(    &quot;mysql+pymysql://&quot;,    creator=getconn,)# insert statementinsert_stmt = sqlalchemy.text(    &quot;INSERT INTO my_table (id, title) VALUES (:id, :title)&quot;,)# interact with Cloud SQL database using connection poolwith pool.connect() as db_conn:    # insert into database    db_conn.execute(insert_stmt, parameters={&quot;id&quot;: &quot;book1&quot;, &quot;title&quot;: &quot;Book One&quot;})    # commit transaction (SQLAlchemy v2.X.X is commit as you go)    db_conn.commit()    # query database    result = db_conn.execute(sqlalchemy.text(&quot;SELECT * from my_table&quot;)).fetchall()    # Do something with the results    for row in result:        print(row)```### Specifying Public or Private IPThe Cloud SQL Connector for Python can be used to connect to Cloud SQL instances using both public and private IP addresses. To specify which IP address to use to connect, set the `ip_type` keyword argument Possible values are `IPTypes.PUBLIC` and `IPTypes.PRIVATE`.Example:```pythonfrom google.cloud.sql.connector import IPTypesconnector.connect(    &quot;project:region:instance&quot;,    &quot;pymysql&quot;,    ip_type=IPTypes.PRIVATE # use private IP... insert other kwargs ...)```Note: If specifying Private IP, your application must already be in the same VPC network as your Cloud SQL Instance.### IAM AuthenticationConnections using [Automatic IAM database authentication](https://cloud.google.com/sql/docs/postgres/authentication#automatic) are supported when using Postgres or MySQL drivers.First, make sure to [configure your Cloud SQL Instance to allow IAM authentication](https://cloud.google.com/sql/docs/postgres/create-edit-iam-instances#configure-iam-db-instance)and [add an IAM database user](https://cloud.google.com/sql/docs/postgres/create-manage-iam-users#creating-a-database-user).Now, you can connect using user or service account credentials instead of a password.In the call to connect, set the `enable_iam_auth` keyword argument to true and the `user` argument to the appropriately formatted IAM principal.&gt; Postgres: For an IAM user account, this is the user's email address. For a service account, it is the service account's email without the `.gserviceaccount.com` domain suffix.&gt; MySQL: For an IAM user account, this is the user's email address, without the @ or domain name. For example, for `test-user@gmail.com`, set the `user` argument to `test-user`. For a service account, this is the service account's email address without the `@project-id.iam.gserviceaccount.com` suffix.Example:```pythonconnector.connect(     &quot;project:region:instance&quot;,     &quot;pg8000&quot;,     user=&quot;postgres-iam-user@gmail.com&quot;,     db=&quot;my-db-name&quot;,     enable_iam_auth=True, )```### SQL Server Active Directory AuthenticationActive Directory authentication for SQL Server instances is currently only supported on Windows. First, make sure to follow [these steps](https://cloud.google.com/blog/topics/developers-practitioners/creating-sql-server-instance-integrated-active-directory-using-google-cloud-sql) to set up a Managed AD domain and join your Cloud SQL instance to the domain. [See here for more info on Cloud SQL Active Directory integration](https://cloud.google.com/sql/docs/sqlserver/ad).Once you have followed the steps linked above, you can run the following code to return a connection object:```pythonconnector.connect(    &quot;project:region:instance&quot;,    &quot;pytds&quot;,    db=&quot;my-db-name&quot;,    active_directory_auth=True,    server_name=&quot;public.[instance].[location].[project].cloudsql.[domain]&quot;,)```Or, if using Private IP:```pythonconnector.connect(    &quot;project:region:instance&quot;,    &quot;pytds&quot;,    db=&quot;my-db-name&quot;,    active_directory_auth=True,    server_name=&quot;private.[instance].[location].[project].cloudsql.[domain]&quot;,    ip_type=IPTypes.PRIVATE)```### Using the Python Connector with Python Web FrameworksThe Python Connector can be used alongside popular Python web frameworks suchas Flask, FastAPI, etc, to integrate Cloud SQL databases within yourweb applications.#### Flask-SQLAlchemy[Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)is an extension for [Flask](https://flask.palletsprojects.com/en/2.2.x/)that adds support for [SQLAlchemy](https://www.sqlalchemy.org/) to yourapplication. It aims to simplify using SQLAlchemy with Flask by providinguseful defaults and extra helpers that make it easier to accomplishcommon tasks.You can configure Flask-SQLAlchemy to connect to a Cloud SQL database fromyour web application through the following:```pythonfrom flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom google.cloud.sql.connector import Connector, IPTypes# Python Connector database connection functiondef getconn():    with Connector() as connector:        conn = connector.connect(            &quot;project:region:instance-name&quot;, # Cloud SQL Instance Connection Name            &quot;pg8000&quot;,            user=&quot;my-user&quot;,            password=&quot;my-password&quot;,            db=&quot;my-database&quot;,            ip_type= IPTypes.PUBLIC  # IPTypes.PRIVATE for private IP        )        return connapp = Flask(__name__)# configure Flask-SQLAlchemy to use Python Connectorapp.config['SQLALCHEMY_DATABASE_URI'] = &quot;postgresql+pg8000://&quot;app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {    &quot;creator&quot;: getconn}db = SQLAlchemy(app)```For more details on how to use Flask-SQLAlchemy, check out the[Flask-SQLAlchemy Quickstarts](https://flask-sqlalchemy.palletsprojects.com/en/2.x/quickstart/#)#### FastAPI[FastAPI](https://fastapi.tiangolo.com/) is a modern, fast (high-performance),web framework for building APIs with Python based on standard Python type hints.You can configure FastAPI to connect to a Cloud SQL database fromyour web application using [SQLAlchemy ORM](https://docs.sqlalchemy.org/en/14/orm/)through the following:```pythonfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerfrom google.cloud.sql.connector import Connector, IPTypes# Python Connector database connection functiondef getconn():    with Connector() as connector:        conn = connector.connect(            &quot;project:region:instance-name&quot;, # Cloud SQL Instance Connection Name            &quot;pg8000&quot;,            user=&quot;my-user&quot;,            password=&quot;my-password&quot;,            db=&quot;my-database&quot;,            ip_type= IPTypes.PUBLIC  # IPTypes.PRIVATE for private IP        )    return connSQLALCHEMY_DATABASE_URL = &quot;postgresql+pg8000://&quot;engine = create_engine(    SQLALCHEMY_DATABASE_URL , creator=getconn)# create SQLAlchemy ORM sessionSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)Base = declarative_base()```To learn more about integrating a database into your FastAPI application,follow along the [FastAPI SQL Database guide](https://fastapi.tiangolo.com/tutorial/sql-databases/#create-the-database-models).### Async Driver UsageThe Cloud SQL Connector is compatible with[asyncio](https://docs.python.org/3/library/asyncio.html) to improve the speedand efficiency of database connections through concurrency. You can use allnon-asyncio drivers through the `Connector.connect_async` function, in additionto the following asyncio database drivers:- [asyncpg](https://magicstack.github.io/asyncpg) (Postgres)The Cloud SQL Connector has a helper `create_async_connector` function that isrecommended for asyncio database connections. It returns a `Connector`object that uses the current thread's running event loop. This is differentthan `Connector()` which by default initializes a new event loop in abackground thread.The `create_async_connector` allows all the same input arguments as the[Connector](#configuring-the-connector) object.Once a `Connector` object is returned by `create_async_connector` you can callits `connect_async` method, just as you would the `connect` method:```pythonimport asyncpgimport sqlalchemyfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_enginefrom google.cloud.sql.connector import Connector, create_async_connectorasync def init_connection_pool(connector: Connector) -&gt; AsyncEngine:    # initialize Connector object for connections to Cloud SQL    async def getconn() -&gt; asyncpg.Connection:        conn: asyncpg.Connection = await connector.connect_async(            &quot;project:region:instance&quot;,  # Cloud SQL instance connection name            &quot;asyncpg&quot;,            user=&quot;my-user&quot;,            password=&quot;my-password&quot;,            db=&quot;my-db-name&quot;            # ... additional database driver args        )        return conn    # The Cloud SQL Python Connector can be used along with SQLAlchemy using the    # 'async_creator' argument to 'create_async_engine'    pool = create_async_engine(        &quot;postgresql+asyncpg://&quot;,        async_creator=getconn,    )    return poolasync def main():    # initialize Connector object for connections to Cloud SQL    connector = await create_async_connector()    # initialize connection pool    pool = await init_connection_pool(connector)    # example query    async with pool.connect() as conn:        await conn.execute(sqlalchemy.text(&quot;SELECT NOW()&quot;))    # close Connector    await connector.close_async()    # dispose of connection pool    await pool.dispose()```For more details on additional database arguments with an `asyncpg.Connection`, please visit the[official documentation](https://magicstack.github.io/asyncpg/current/api/index.html).### Async Context ManagerAn alternative to using the `create_async_connector` function is initializinga `Connector` as an async context manager, removing the need for explicitcalls to `connector.close_async()` to cleanup resources.**Note:** This alternative requires that the running event loop bepassed in as the `loop` argument to `Connector()`.```pythonimport asyncioimport asyncpgimport sqlalchemyfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_enginefrom google.cloud.sql.connector import Connectorasync def init_connection_pool(connector: Connector) -&gt; AsyncEngine:    # initialize Connector object for connections to Cloud SQL    async def getconn() -&gt; asyncpg.Connection:            conn: asyncpg.Connection = await connector.connect_async(                &quot;project:region:instance&quot;,  # Cloud SQL instance connection name                &quot;asyncpg&quot;,                user=&quot;my-user&quot;,                password=&quot;my-password&quot;,                db=&quot;my-db-name&quot;                # ... additional database driver args            )            return conn    # The Cloud SQL Python Connector can be used along with SQLAlchemy using the    # 'async_creator' argument to 'create_async_engine'    pool = create_async_engine(        &quot;postgresql+asyncpg://&quot;,        async_creator=getconn,    )    return poolasync def main():    # initialize Connector object for connections to Cloud SQL    loop = asyncio.get_running_loop()    async with Connector(loop=loop) as connector:        # initialize connection pool        pool = await init_connection_pool(connector)        # example query        async with pool.connect() as conn:            await conn.execute(sqlalchemy.text(&quot;SELECT NOW()&quot;))        # dispose of connection pool        await pool.dispose()```## Support policy### Major version lifecycleThis project uses [semantic versioning](https://semver.org/), and uses thefollowing lifecycle regarding support for a major version:**Active** - Active versions get all new features and security fixes (thatwouldn’t otherwise introduce a breaking change). New major versions areguaranteed to be &quot;active&quot; for a minimum of 1 year.**Deprecated** - Deprecated versions continue to receive security and criticalbug fixes, but do not receive new features. Deprecated versions will be publiclysupported for 1 year.**Unsupported** - Any major version that has been deprecated for &gt;=1 year isconsidered publicly unsupported.## Supported Python VersionsWe test and support at a minimum, every [active version until it'send-of-life date][pyver]. Changes in supported Python versions will beconsidered a minor change, and will be listed in the release notes.[pyver]: https://devguide.python.org/#status-of-python-branches### Release cadenceThis project aims for a minimum monthly release cadence. If no newfeatures or fixes have been added, a new PATCH version with the latestdependencies is released.### ContributingWe welcome outside contributions. Please see our[Contributing Guide](CONTRIBUTING.md) for details on how best to contribute.</longdescription>
</pkgmetadata>