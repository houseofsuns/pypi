<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># mpmq[![GitHub Workflow Status](https://github.com/soda480/mpmq/workflows/build/badge.svg)](https://github.com/soda480/mpmq/actions)[![Code Coverage](https://codecov.io/gh/soda480/mpmq/branch/main/graph/badge.svg?token=SAEJLS4FCM)](https://codecov.io/gh/soda480/mpmq)[![Code Grade](https://api.codiga.io/project/20847/status/svg)](https://app.codiga.io/public/project/20847/mpmq/dashboard)[![vulnerabilities](https://img.shields.io/badge/vulnerabilities-None-brightgreen)](https://pypi.org/project/bandit/)[![PyPI version](https://badge.fury.io/py/mpmq.svg)](https://badge.fury.io/py/mpmq)[![python](https://img.shields.io/badge/python-3.7%20%7C%203.8%20%7C%203.9%20%7C%203.10-teal)](https://www.python.org/downloads/)The mpmq module provides a convenient way to scale execution of a function across multiple input values by distributing the input across a specified number of background processes. It also provides the means for the caller to intercept and process messages from the background processes while they execute the function. It does this by configuring a custom log handler that sends the function's log messages to a thread-safe queue; several API's are provided for the caller to process the messages from the message queue. The number of processes along with the input data for each process is specified as a list of dictionaries. The number of elements in the list dictates the total number of processes to execute. The result of each function is returned as a list to the caller after all background workers complete.The main features are:* execute function across multiple processes* queue function execution* create log handler that sends function log messages to thread-safe message queue* process messages from log message queue* maintain result of all executed functions* terminate execution using keyboard interrupt### Installation```bashpip install mpmq```### `MPmq class````mpmq.MPmq(function, process_data=None, shared_data=None, processes_to_start=None)```&gt; `function` - the function to execute&gt; `process_data` - list of dictionaries where each dictionary describes the input data that will be sent to each background process executing the function; the length of the list dictates the total number of processes that will be executed&gt; `shared_data` - a dictionary containing arbitrary data that will be sent to all processes&gt; `process_to_start` - the number of processes to initially start; this represents the number of concurrent processes that will be running. If the total number of processes is greater than this number then execution will be queued and executed to ensure that this concurrency is maintained&gt; **execute(raise_if_error=False)**&gt;&gt; Start execution the processâ€™s activity. If `raise_if_error` is set to True, an exception will be raised if any function encountered an error during execution.&gt; **process_message(offset, message)**&gt;&gt; Process a message sent from one of the background processes executing the function. The `offset` represents the index of the executing Process; this number is the same as the corresponding index within the `process_data` list that was sent to the constructor. The `message` represents the message that was logged by the function.### ExamplesA simple example using mpmq:```pythonfrom mpmq import MPmqimport sys, logginglogger = logging.getLogger(__name__)logging.basicConfig(stream=sys.stdout, level=logging.INFO, format=&quot;%(processName)s [%(funcName)s] %(levelname)s %(message)s&quot;)def do_work(*args):    logger.info(f&quot;hello from process: {args[0]['pid']}&quot;)    return 10 + int(args[0]['pid'])process_data = [{'pid': item} for item in range(3)]results = MPmq(function=do_work, process_data=process_data).execute()print(f&quot;Total items processed {sum([result for result in results])}&quot;) ```Executing the code above results in the following (for conciseness only INFO level messages are shown):```PythonMainProcess [start_next_process] INFO started background process at offset:0 with id:4430 name:Process-1Process-1 [do_work] INFO hello from process: 0MainProcess [start_next_process] INFO started background process at offset:1 with id:4431 name:Process-2Process-1 [_queue_handler] DEBUG adding 'do_work' offset:0 result to result queueProcess-2 [do_work] INFO hello from process: 1MainProcess [start_next_process] INFO started background process at offset:2 with id:4433 name:Process-3MainProcess [start_processes] INFO started 3 background processesProcess-3 [do_work] INFO hello from process: 2Process-2 [_queue_handler] DEBUG adding 'do_work' offset:1 result to result queueProcess-1 [_queue_handler] DEBUG execution of do_work offset:0 endedProcess-3 [_queue_handler] DEBUG adding 'do_work' offset:2 result to result queueProcess-1 [_queue_handler] DEBUG DONEMainProcess [complete_process] INFO process at offset:0 id:4430 name:Process-1 has completedProcess-2 [_queue_handler] DEBUG execution of do_work offset:1 endedProcess-2 [_queue_handler] DEBUG DONEMainProcess [complete_process] INFO joining process at offset:0 with id:4430 name:Process-1Process-3 [_queue_handler] DEBUG execution of do_work offset:2 endedProcess-3 [_queue_handler] DEBUG DONEMainProcess [process_control_message] INFO the to process queue is emptyMainProcess [complete_process] INFO process at offset:1 id:4431 name:Process-2 has completedMainProcess [complete_process] INFO joining process at offset:1 with id:4431 name:Process-2MainProcess [process_control_message] INFO the to process queue is emptyMainProcess [complete_process] INFO process at offset:2 id:4433 name:Process-3 has completedMainProcess [complete_process] INFO joining process at offset:2 with id:4433 name:Process-3MainProcess [process_control_message] INFO the to process queue is emptyMainProcess [run] INFO there are no more active processses - quitting&gt;&gt;&gt; print(f&quot;Total items processed {sum([result for result in results])}&quot;)Total items processed 33```### Projects using `mpmq`* [`mpcurses`](https://pypi.org/project/mpcurses/) An abstraction of the Python curses and multiprocessing libraries providing function execution and runtime visualization capabilities* [`mppbars`](https://pypi.org/project/mppbar/) Scale execution of a function across multiple across a number of background processes while displaying their execution status via a progress bar* [`mp4ansi`](https://pypi.org/project/mp4ansi/) A simple ANSI-based terminal emulator that provides multi-processing capabilities### DevelopmentClone the repository and ensure the latest version of Docker is installed on your development server.Build the Docker image:```shdocker image build \-t \mpmq:latest .```Run the Docker container:```shdocker container run \--rm \-it \-v $PWD:/code \mpmq:latest \bash```Execute the build:```shpyb -X```</longdescription>
</pkgmetadata>