<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python Dict WrapperThis is a simple class that exposes a dictionary's keys as class attributes,making for less typing when accessing dictionary values.  This class alsoenforces that the dictionary's overall __shape__ is maintained.A common use of this class may be in retrieving and updating model objectsfrom web services (i.e. RESTful web services) where the shape of the modelobject must be kept intact between when it is retrieved and when it is saved.For instance, if used with [requests](https://github.com/psf/requests), theoutput of a request's _json()_ call can be wrapped and the resulting objectwill behave in much the same manner as a real model object.  The valuescan be manipulated and later _unwrapped_ to be sent back the server usinga requests _post()_ call.Using the python_dict_wrapper is pretty simple.  You _wrap()_ a dictionary(or list).  Then you manipulate and/or query it.  Finally, you can _unwrap()_to get the dictionary (or list) back.A trivial example:    import requests    from python_dict_wrapper import wrap, unwrap    actor_dict = requests.get('http://ficticious_actor_database_site.com/actors/c/carell_steve').json()        # Returns:    # {    #    &quot;name&quot;: &quot;Steve Carell&quot;,    #    &quot;career&quot;: [{    #        &quot;medium&quot;: &quot;TV&quot;,    #        &quot;title&quot;: &quot;The Office&quot;    #    }, {    #        &quot;medium&quot;: &quot;MOVIE&quot;,    #        &quot;title&quot;: &quot;Bruce Almighty&quot;    #    }]    #}    actor = wrap(actor_dict)    actor.career[1].title = &quot;Despicable Me&quot;    unwrapped_actor = unwrap(actor)        requests.post('http://ficticious_actor_database_site.com/actors/c/carell_steve', data=unwrapped_actor)# Installationpython_dict_wrapper is available on PyPi, so the easiest way to install itis by using pip:    $ pip install python-dict-wrapper        # function make\_wrapper(**kargs)_make\_wrapper_ is a factory function for quickly instantiating a _DictWrapper_from keyword arguments.  It's easier to demonstrate:    &gt;&gt;&gt; from python_dict_wrapper import make_wrapper    &gt;&gt;&gt;    &gt;&gt;&gt; person = make_wrapper(first_name='Steve', last_name='Carell', occupation='actor')    &gt;&gt;&gt; person    &lt;DictWrapper: {'first_name': 'Steve', 'last_name': 'Carell', 'occupation': 'actor'}&gt;    &gt;&gt;&gt; person.last_name    'Carell'        # function wrap(data, strict=False, key_prefix=None, mutable=True)_wrap_ is a factory function for generating either a DictWrapper or aListWrapper.  It has one required argument and three optional ones:* data - A Python dictionary or a list of dictionaries that needs to be wrapped.  If data is a dictionary, this method will return a DictWrapper instance.  If  it's a list, the function will return a ListWrapper instance.  This argument  is required.* strict - An optional boolean that indicates if the wrapper should enforce  types when setting attribute values.* key_prefix - A string or list of strings that contains characters that  dictionary keys should be prefixed with before they become attributes.* mutable - A boolean indicating whether the DictWapper should be mutable or not.  This is a convenience function for when you have a data object and don't wantto bother checking if it's a dictionary or a list.    &gt;&gt;&gt; from python_dict_wrapper import wrap    &gt;&gt;&gt;    &gt;&gt;&gt; person_dict = {'first_name': 'Steve', 'last_name': 'Carell', 'occupation': 'actor'}    &gt;&gt;&gt;    &gt;&gt;&gt; person = wrap(person_dict)    &gt;&gt;&gt;    &gt;&gt;&gt; person    &lt;DictWrapper: {'first_name': 'Steve', 'last_name': 'Carell', 'occupation': 'actor'}&gt;    &gt;&gt;&gt; person.occupation    'actor'# function unwrap(wrapped_item)The _unwrap_ function will return the original item that was wrapped.    &gt;&gt;&gt; from python_dict_wrapper import wrap, unwrap    &gt;&gt;&gt; data_dict = {'first_name': 'Steve', 'last_name': 'Carell'}    &gt;&gt;&gt; id(data_dict)    4497764480    &gt;&gt;&gt; wrapped_data_dict = wrap(data_dict)    &gt;&gt;&gt; id(wrapped_data_dict)    4498248224    &gt;&gt;&gt; wrapped_data_dict    &lt;python_dict_wrapper.DictWrapper object at 0x10c1dd220&gt;    &gt;&gt;&gt; unwrapped_data_dict = unwrap(wrapped_data_dict)    &gt;&gt;&gt; unwrapped_data_dict is data_dict    True    &gt;&gt;&gt; unwrapped_data_dict    {'first_name': 'Steve', 'last_name': 'Carell'}The _unwrap_ function will work on both _DictWrapper_ items as well as_ListWrapper_ items.  If the item passed to _unwrap_ is not a _DictWrapper_or a _ListWrapper_, _unwrap_ will just return the item untouched._DictWrapper_ objects manipulate the original dictionary that they wrap sounwrapping is technically unnecessary.  That said, unwrap is available in theevent a reference to the original dictionary is lost or goes out of scope.# function add_attribute(wrapped_item, attribute_name, attribute_value)The _add\_attribute_ function can be used to add an attribute to a DictWrapperafter it has been instantiated.  It can be used if the original dictionary isno longer available.    &gt;&gt;&gt; from python_dict_wrapper import wrap, add_attribute    &gt;&gt;&gt; auth_config = wrap({'username': 'john@doe.com', 'password': 'itza!secret'})    &gt;&gt;&gt; add_attribute(auth_config, 'host', 'ldap.doe.com')    &gt;&gt;&gt; auth_config.host    'ldap.doe.com'# function del_attribute(wrapped_item, attribute_name)Conversely, _del\_attribute_ removes an existing attribute from an existingDictWrapper.  The del_attribute will return what the attribute's last value wasbefore being removed.    &gt;&gt;&gt; from python_dict_wrapper import wrap, del_attribute    &gt;&gt;&gt; auth_config = wrap({'username': 'john@doe.com', 'password': 'itza!secret'})    &gt;&gt;&gt; del_attribute(auth_config, 'password')    'itza!secret'    &gt;&gt;&gt; hasattr(auth_config, 'password')    False# class DictWrapper(data, strict=False, key_prefix=None, mutable=True)Like the wrap function, each _DictWrapper_ instance takes one required argumentand three optional ones:* dict - A Python dictionary that the wrapper will use as it's source. This  argument is required.* strict - An optional boolean that indicates if the wrapper should enforce  types when setting attribute values.* key_prefix - A string or list of strings that contains characters that  dictionary keys should be prefixed with before they become attributes.* mutable - A boolean indicating whether the DictWapper should be mutable or not. ## Attributes  Once a _DictWrapper_ instance has been created, the keys of it's source dictionary will be exposed as attributes.  So for example if a _DictWrapper_ is instantiated with the following dictionary:     &gt;&gt;&gt; from dict_wrapper import wrap    &gt;&gt;&gt; address_dict = {'street': '221B Baker Street', 'city': 'London', 'country': 'UK'}    &gt;&gt;&gt; address = wrap(address_dict)The keys: _street_, _city_, and 'country' will be exposed as attributes of _address_    &gt;&gt;&gt; address.street    '221B Baker Street'    &gt;&gt;&gt; address.city    'London'    &gt;&gt;&gt; address.country    'UK'The attributes are both readable and writeable, so you can update the values simply byassigning to them:    &gt;&gt;&gt; address.country = &quot;United Kingdom&quot;    &gt;&gt;&gt; address.country    'United Kingdom'  If the _strict_ argument to the constructor was set to _True_, then the _DictWrapper_ will enforce that that when you assign a new value to an attribute, it must be the same Type as the original dictionary value.     &gt;&gt;&gt; address = wrap(address_dict, strict=True)    &gt;&gt;&gt; address.street = 221    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;dict_wrapper.py&quot;, line 62, in __setattr__        raise TypeError(&quot;Value for %s must be a %s, not %s&quot; % (    TypeError: Value for street must be a str, not intIf the _key\_prefix_ argument to the constructor is set to a string or list of strings,attributes in the dictionary are searched without their prefixes.  This is typically usedfor dictionaries that have keys that cannot be represented in attributes.  Here's anexample:    &gt;&gt;&gt; the_dict = {'@timestamp': '2020-04-19 05:00:00', 'author': 'Arthur Conan Doyle'}    &gt;&gt;&gt;    &gt;&gt;&gt; entry = wrap(the_dict)    &gt;&gt;&gt; entry.timestamp    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;python_dict_wrapper.py&quot;, line 49, in __getattr__        self._check_for_bad_attribute(key)      File &quot;python_dict_wrapper.py&quot;, line 87, in _check_for_bad_attribute        raise AttributeError(&quot;'%s' object has no attribute '%s'&quot; % (self.__class__.__name__, key))    AttributeError: 'DictWrapper' object has no attribute 'timestamp'    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; entry = DictWrapper(the_dict, key_prefix='@')    &gt;&gt;&gt; entry.timestamp    '2020-04-19 05:00:00'## Methods ## _DictWrapper_ instances have two methods: _to\_json()_ and _to\_dict()_. ### to\_json(pretty=False) Converts the dictionary values to a JSON string.  If the _pretty_ argument is set to _True_,the returned JSON will be multi-lined and indented with 4 characters.  If it's false, thereturned JSON will a single-line of text. ### to\_dict() Converts the _DictWrapper_ back to a Python dictionary. ## Nesting_DictWrapper_ instances should be able to handle nested dictionaries and lists withoutissue.  It automatically wraps any nested dictionaries in their own _DictWrapper_instances for you.    &gt;&gt;&gt; shelock_dict = {    ...     'name': 'Sherlock Holmes',    ...     'address': {    ...             'street': '221B Baker Street',    ...             'city': 'London',    ...             'country': 'UK'    ...     }    ... }    &gt;&gt;&gt; sherlock = DictWrapper(sherlock_dict)    &gt;&gt;&gt; sherlock.address.country = 'United Kingdom'    &gt;&gt;&gt; print(sherlock.to_json(pretty=True))    {        &quot;name&quot;: &quot;Sherlock Holmes&quot;,        &quot;address&quot;: {            &quot;street&quot;: &quot;221B Baker Street&quot;,            &quot;city&quot;: &quot;London&quot;,            &quot;country&quot;: &quot;United Kingdom&quot;        }    }# class ListWrapper(data, strict=False, key_prefix=None, mutable=True)The _ListWrapper_ is a &quot;list&quot; version of the _DictWrapper_.  It is used by the_DictWrapper_ when nesting lists within dictionary values.  The _ListWrapper_is a subclass of a built-in Python list and behaves almost exactly like a Pythonlist with one exception.  When retrieving items out of the list if the item isa dictionary, it will wrap it in a _DictWrapper_.  If the item in question isa Python list, it will wrap it in another ListWrapper.    &gt;&gt;&gt; from python_dict_wrapper import ListWrapper    &gt;&gt;&gt; the_list = [    ...     'one',    ...     [1, 2, 3],    ...     {'color': 'blue'}    ... ]    &gt;&gt;&gt; wrapped_list = ListWrapper(the_list)    &gt;&gt;&gt; wrapped_list[0]    'one'    &gt;&gt;&gt; wrapped_list[1]    &lt;ListWrapper: [1, 2, 3]&gt;    &gt;&gt;&gt; wrapped_list[1][2]    3    &gt;&gt;&gt; wrapped_list[2]    &lt;DictWrapper: {'color': 'blue'}&gt;    &gt;&gt;&gt; wrapped_list[2].color    'blue'# Mutability #If the _DictWrapper_ is instantiated with _mutable_ set to True (default), the_DictWrapper_ will be mutable, meaning the attribute can be changed.  However, if_mutable_ is set to False when the DictWrapper is instantiated, it will be immutable.You will not be able to change any of the attributes (or nested attributes).  AnyListWrappers that result from lists within the underlying dict will also be immutable.You will not be able to add/remove from them.    &gt;&gt;&gt; from python_dict_wrapper import wrap    &gt;&gt;&gt; auth_config = wrap({'username': 'john@doe.com', 'password': 'itza!secret'}, mutable=False)    &gt;&gt;&gt; auth_config.password    'itza!secret'    &gt;&gt;&gt; auth_config.password = 'super!secret'    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;python_dict_wrapper.py&quot;, line 78, in __setattr__        raise AttributeError(&quot;can't set attribute&quot;)    AttributeError: can't set attribute# Performance #_DictWrapper_ and _ListWrapper_ instances lazy evaluate on the original dicts/liststhat they are given when wrapped.  As a result performance of these classes shouldbe roughly the same as their native counterparts.</longdescription>
</pkgmetadata>