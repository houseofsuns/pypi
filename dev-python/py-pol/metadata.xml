<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>========================Python polarization========================.. image:: https://img.shields.io/pypi/v/py_pol.svg        :target: https://pypi.org/project/py-pol/.. image:: https://img.shields.io/travis/optbrea/py_pol.svg        :target: https://bitbucket.org/optbrea/py_pol/src/master/.. image:: https://readthedocs.org/projects/py-pol/badge/?version=latest        :target: https://py-pol.readthedocs.io/en/master/        :alt: Documentation Status* Free software: MIT license* Documentation: https://py-pol.readthedocs.io.. image:: logo.png   :width: 75   :align: rightFeatures--------Py-pol is a Python library for Jones and Stokes-Mueller polarization optics. It has 4 main modules:    * jones_vector - Light polarization states in Jones formalism (2x1 vectors).    * jones_matrix - Optical elements polarization properties in Jones formalism (2x2 matrices).    * stokes - Light polarization states in Mueller-Stokes formalism (4x1 vectors).    * mueller - Optical elements polarization properties in Mueller-Stokes formalism (4x4 matrices).Each one has its own class, with multiple methods for generation, operation and parameters extraction.Examples--------Jones formalism===============Generating Jones vectors and Matrices.. code-block:: python    from py_pol.jones_vector import Jones_vector    from py_pol.jones_matrix import Jones_matrix    from py_pol.utils import degrees    j0 = Jones_vector(&quot;j0&quot;)    j0.linear_light(angle=45*degrees)    m0 = Jones_matrix(&quot;m0&quot;)    m0.diattenuator_linear( p1=0.75, p2=0.25, angle=45*degrees)    m1 = Jones_matrix(&quot;m1&quot;)    m1.quarter_waveplate(angle=0 * degrees)    j1=m1*m0*j0Extracting information form Jones Vector... code-block:: python    print(j0,'\n')    print(j0.parameters).. code-block:: python    j0 = [+0.707; +0.707]    parameters of j0:        intensity        : 1.000 arb.u        alpha            : 45.000 deg        delay            : 0.000 deg        azimuth          : 45.000 deg        ellipticity angle: 0.000 deg        a, b             : 1.000  0.000        phase            : 0.000 deg.. code-block:: python    print(j1,'\n')    print(j1.parameters).. code-block:: python        m1 * m0 @45.00 deg * j0 = [+0.530+0.000j; +0.000+0.530j]'        parameters of m1 * m0 @45.00 deg * j0:            intensity        : 0.562 arb.u            alpha            : 45.000 deg            delay            : 90.000 deg            azimuth          : 8.618 deg            ellipticity angle: -45.000 deg            a, b             : 0.530  0.530            phase            : 0.000 degExtracting information form Jones Matrices... code-block:: python    print(m0,'\n')    print(m0.parameters).. code-block:: python        m0 @45.00 deg =              [+0.500, +0.250]              [+0.250, +0.500]        parameters of m0 @45.00 deg:            is_homogeneous: True            delay:          0.000 deg            diattenuation:  0.800.. code-block:: python    print(m1,'\n')    print(m1.parameters).. code-block:: python        m1 =              [+1+0j, +0+0j]              [+0+0j, +0+1j]        parameters of m1:            is_homogeneous: True            delay:          90.000 deg            diattenuation:  0.000Stokes-Mueller formalism========================Generating Stokes vectors and Mueller matrices... code-block:: python    from py_pol.stokes import Stokes    from py_pol.mueller import Mueller    from py_pol.utils import degrees    j0 = Stokes(&quot;j0&quot;)    j0.linear_light(angle=45*degrees)    m1 = Mueller(&quot;m1&quot;)    m1.diattenuator_linear(p1=1, p2=0, angle=0*degrees)    j1=m1*j0Extracting information from Stokes vectors.Determining the intensity of a Stokes vector:.. code-block:: python    i1=j0.parameters.intensity()    print(&quot;intensity = {:4.3f} arb. u.&quot;.format(i1)).. code-block:: python    intensity = 1.000 arb. u.Determining all the parameters of a Stokes vector:.. code-block:: python    print(j0,'\n')    print(j0.parameters).. code-block:: python        j0 = [ +1;  +0;  +1;  +0]        parameters of j0:            intensity             : 1.000 arb. u.            amplitudes            : E0x 0.707, E0y 0.707, E0_unpol 0.000            degree polarization   : 1.000            degree linear pol.    : 1.000            degree   circular pol.: 0.000            alpha                 : 45.000 deg            delay                 : 0.000 deg            azimuth               : 45.000 deg            ellipticity  angle    : 0.000 deg            ellipticity  param    : 0.000            eccentricity          : 1.000            polarized vector      : [+1.000; +0.000; +1.000; +0.000]'            unpolarized vector    : [+0.000; +0.000; +0.000; +0.000]'.. code-block:: python    print(j1,'\n')    print(j1.parameters).. code-block:: python        m1 * j0 = [+0.500; +0.500; +0.000; +0.000]        parameters of m1 * j0:            intensity             : 0.500 arb. u.            amplitudes            : E0x 0.707, E0y 0.000, E0_unpol 0.000            degree polarization   : 1.000            degree linear pol.    : 1.000            degree   circular pol.: 0.000            alpha                 : 0.000 deg            delay                 : 0.000 deg            azimuth               : 0.000 deg            ellipticity  angle    : 0.000 deg            ellipticity  param    : 0.000            eccentricity          : 1.000            polarized vector      : [+0.500; +0.500; +0.000; +0.000]'            unpolarized vector    : [+0.000; +0.000; +0.000; +0.000]'Extracting information from Mueller matrices... code-block:: python    m2 = Mueller(&quot;m2&quot;)    m2.diattenuator_retarder_linear(D=90*degrees, p1=1, p2=0.5, angle=0)    delay = m2.parameters.retardance()    print(&quot;delay = {:2.1f}Âº&quot;.format(delay/degrees)).. code-block:: python    delay = 90.0ÂºThere is a function in Parameters_Jones_Vector class, .get_all() that will compute all the parameters available and stores in a dictionary .dict_params(). Info about dict parameters can be revised using the print function... code-block:: python    print(m2,'\n')    m2.parameters.get_all()    print(m2.parameters).. code-block:: python        m2 =          [+0.6250, +0.3750, +0.0000, +0.0000]          [+0.3750, +0.6250, +0.0000, +0.0000]          [+0.0000, +0.0000, +0.0000, +0.5000]          [+0.0000, +0.0000, -0.5000, +0.0000]      Parameters of m2:          Transmissions:              - Mean                  : 62.5 %.              - Maximum               : 100.0 %.              - Minimum               : 25.0 %.          Diattenuation:              - Total                 : 0.600.              - Linear                : 0.600.              - Circular              : 0.000.          Polarizance:              - Total                 : 0.600.              - Linear                : 0.600.              - Circular              : 0.000.          Spheric purity              : 0.872.          Retardance                  : 1.571.          Polarimetric purity         : 1.000.          Depolarization degree       : 0.000.          Depolarization factors:              - Euclidean distance    : 1.732.              - Depolarization factor : 0.000.          Polarimetric purity indices:              - P1                    : 1.000.              - P2                    : 1.000.              - P3                    : 1.000.There are many types of Mueller matrices. The Check_Mueller calss implements all the checks that can be performed in order to clasify a Mueller matrix. They are stored in the checks field of Mueller class... code-block:: python    m1 = Mueller(&quot;m1&quot;)    m1.diattenuator_linear(p1=1, p2=0.2, angle=0*degrees)    print(m1,'\n')    c1 = m1.checks.is_physical()    c2 = m1.checks.is_homogeneous()    c3 = m1.checks.is_retarder()    print('The linear diattenuator is physical: {}; hogeneous: {}; and a retarder: {}.'.format(c1, c2, c3)).. code-block:: python    m1 =      [+0.520, +0.480, +0.000, +0.000]      [+0.480, +0.520, +0.000, +0.000]      [+0.000, +0.000, +0.200, +0.000]      [+0.000, +0.000, +0.000, +0.200]    The linear diattenuator is physical: True; hogeneous: True; and a retarder: False.Drawings========The modules also allows to obtain graphical representation of polarization.Drawing polarization ellipse for Jones vectors... image:: ellipse_Jones_1.png   :width: 600.. image:: ellipse_Jones_3.png   :width: 600Drawing polarization ellipse for Stokes vectors with random distribution due to unpolarized part of light... image:: ellipse_Stokes_1.png   :width: 600.. image:: ellipse_Stokes_2.png   :width: 600Drawing Stokes vectors in Poincare sphere... image:: poincare2.png   :width: 600.. image:: poincare3.png   :width: 600.. image:: poincare4.png   :width: 600Authors-------.. image:: logoUCM.png   :width: 125   :align: right* Jesus del Hoyo &lt;jhoyo@ucm.es&gt;* Luis Miguel Sanchez Brea &lt;optbrea@ucm.es&gt;    **Universidad Complutense de Madrid**,    Faculty of Physical Sciences,    Department of Optics    Plaza de las ciencias 1,    ES-28040 Madrid (Spain)Citing------* J. Hoyo, L. M. Sanchez-Brea, A. Soria-Garcia, &quot;Open source library for polarimetric calculations &quot;py_pol&quot;&quot;, Proc. SPIE 11875, Computational Optics 2021, 1187506 (14 September 2021); doi: 10.1117/12.2597163, https://spie.org/Publications/Proceedings/Paper/10.1117/12.2597163?SSO=1.* J. del Hoyo, L.M. Sanchez Brea, &quot;py-pol, Python module for polarization optics&quot;, https://pypi.org/project/py-pol/ (2019)References----------* D. Goldstein &quot;Polarized light&quot; 2nd edition, Marcel Dekker (1993).* J. J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016).* C. Brosseau &quot;Fundamentals of Polarized Light&quot; Wiley (1998).* R. Martinez-Herrero, P. M. Mejias, G. Piquero &quot;Characterization of partially polarized light fields&quot; Springer series in Optical sciences (2009).* J. M. Bennet &quot;Handbook of Optics 1&quot; Chapter 5 'Polarization'.* R. A. Chipman &quot;Handbook of Optics 2&quot; Chapter 2 'Polarimetry'.* S. Y. Lu and RA Chipman, &quot;Homogeneous and inhomogeneous Jones matrices&quot;,  J. Opt. Soc. Am. A 11(2) 766 (1994).Acknowlegments--------------This software was initially developed for the project Retos-ColaboraciÃ³n 2016 &quot;Ecograb&quot; (RTC-2016-5277-5) and &quot;Teluro-AEI&quot; (RTC2019-007113-3) of Ministerio de EconomÃa y Competitivdad (Spain) and the European funds for regional development (EU), led by Luis Miguel Sanchez-Brea.Credits-------This package was created with Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template... _Cookiecutter: https://github.com/audreyr/cookiecutter.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage=======History=======1.1.3-----------------------* bugfix zeroslike* bugfix not taking shape = False as flatten the object.1.1.2-----------------------* bugfix Jones_vector.parameters.global_phase1.1.1-----------------------* from_list can also be used with lists of Py_pol objects, lists and tuples. Also, all elemeents may have more than one elemnt.* minor bugfixes1.1.0 (2022-3-31)-------------------* Added base class Py_pol* Objects are now iterable* 3D drawings changed to Plotly* New density and existence methods1.0.4 (2022-02-07)------------------* Bug fix related to variable limits1.0.4 (2021-07-19)------------------* Bug fixes1.0.3 (2021-01-22)------------------* Bug fixes1.0.2 (2020-07-04)--------------------* Implemented workaround of axis_equal issue.1.0.0 (2020-06-04)-------------------py_pol multidimensional. Alpha stateThis is a big overhaul with many changes. All of them are based on the possibility of storing several vector/matrices in the same object. This reduces significantly the time required to perform the same operation to multiple vectors/matrices, using numpy methods instead of for loops. We have calculated that the reduction is around one order of magnitude.New methods have been introduced. First, methods available for Mueller / Stoes modules have been created also for Jones (when possible). Also, some bugs and errors in the calculations have been solved.Finally, some method and argument names have been changed to be consistent between different classes. Also, the default value of arguments with the same name have also been unified.The biggest TO DO we have are tests. Right now, we only have tests for the Jones_vector class. However, we thought that it would be useful to release this version so the community can use it.NOTE: Due to the change of argument and method names, this version is not compatible with the previous ones.0.2.2 (2019-09-04)------------------* Bug fixes.0.2.1 (2019-09-04)------------------* Bug fixes.* Solve incidents.* Start to homogenize structures for both Jones and Stokes.0.2.0 (2019-05-25)------------------pre-alpha state* Upgrade to Python 3* Stable version including tests0.1.5 (2019-02-25)------------------* Jones_vector, Jones_matrix, Stokes works.* Jones_vector: simplify function to represent better Jones vectors.* tests drawing: Made tests for drawing* Mueller is in progress.* Functions = 9/10* Documentation = 8/10* Tutorial = 8/10.* Examples = 8/10.* Tests = 8/10* Drawing = 10/10. Finished. Polarization ellipse for Jones and Stokes (partially random). Stokes on PoincarÃ© sphere.0.1.4 (2019-02-03)------------------* bug fixes0.1.3 (2019-01-22)------------------* Fixed axis_equal issue.* Jones_vector, Jones_matrix, Stokes works.* Mueller is in progress.* Functions = 9/10* Documentation = 8/10* Tutorial = 7/10.* Examples = 6/10.* Drawing = 0/10.0.1.1 (2018-12-22)------------------* First release on PyPI in alpha state.0.0.0 (2018-11-22)------------------First implementation of py_pol.</longdescription>
</pkgmetadata>