<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pocketsearchpocketsearch is a pure-Python full text indexing search engine based on sqlite and the [FTS5](https://www.sqlite.org/fts5.html) extension. It provides- A simple API (inspired by the ORM layer of the Django web framework) for defining schemas and searching - no need to write SQL- Multi-field indices using schemas including text, numeric and date search- Prefix, phrase and initial token queries- Boolean search queries- Highlightning search results and extracting snippets- Autocomplete featuresIt does not have any external dependencies other than Python itself. pocketsearch has been tested on Python 3.8, Python 3.9, Python 3.10 and Python 3.11.pocketsearch is currently being tested on data from Wikipedia, indexing more than 6 million abstracts. If you are interested in preliminary performance tests, have a look at https://github.com/kaykay-dv/pocketsearch/tree/development/tests.# StatusThe package is currently in Beta status.![Unit tests main](https://github.com/kaykay-dv/pocketsearch/actions/workflows/unittests-main.yml/badge.svg)![Unit tests development](https://github.com/kaykay-dv/pocketsearch/actions/workflows/unittests-development.yml/badge.svg)# InstallationRun ```Shellpip install pocketsearch```to install the package.# Getting startedBy default, pocketsearch creates an in-memory database using a default search index schema containing only one field called 'text':```Pythonfrom pocketsearch import PocketSearchpocket_search = PocketSearch()pocket_search.insert(text=&quot;Hello World !&quot;)pocket_search.search(text=&quot;hello&quot;)[0].textHello World !```From a database perspective, the new document will be immediately available to the search index, as each insert is followed by a database commit.Be aware that the search methods limits results to 10 by default. Results are ordered by the rank of the search result which is calculated by the FTS extension in sqlite (see https://www.sqlite.org/fts5.html#the_bm25_function for more details) showing how relevant a document is to a given query. The API also supports iteration:```Pythonfor document in pocket_search.search(text=&quot;hello&quot;):    print(document.text)```There is also support for slicing:```Pythonpocket_search.search(text=&quot;hello&quot;)[1:3]```## AND/OR queriesThe FTS5 engines supports AND/OR queries. By default they are disabled in the API, if you want to make boolean queries, you have to use a lookup parameter in your query: ```Pythonfrom pocketsearch import PocketSearchpocket_search = PocketSearch()pocket_search.insert(text=&quot;Hello World !&quot;)pocket_search.search(text__allow_boolean=&quot;hello OR world&quot;)[0].textHello World !```&gt; **_NOTE:_** Please note, that AND as well as OR are case-sensitive in this context.Similar to the Django Web Framework, pocketsearch supports Q objects, thusyou can use this notation as well:```Pythonfrom pocketsearch import PocketSearch, Qpocket_search = PocketSearch()pocket_search.insert(text=&quot;Hello World !&quot;)# Q object-based notation:pocket_search.search(Q(text=&quot;hello&quot;) | Q(text=&quot;world&quot;))[0].text# this is equivalent to:pocket_search.search(text__allow_boolean=&quot;hello OR world&quot;)[0].textHello World !```## Counting resultsBy invoking the count method you get the number of search results:```Pythonpocket_search.search(text__allow_boolean=&quot;hello OR world&quot;).count()1```## Prefix queriesIf you want to search for substrings, you can use prefix queries, by providing the allow_prefix lookup:```Pythonpocket_search.search(text__allow_prefix=&quot;hel*&quot;)[0].text```Please note, that prefix queries might get very slow as the index grows. To optimize performance, you can use prefix indices as described in the chapter on &quot;schemas&quot; in this README.## Initial token queriesIf you want to search only the first token at the begining of a document, use the allow_initial_token lookup:```Pythonpocket_search.search(text__allow_initial_token=&quot;^hello&quot;)```This will only match results that have 'hello' at the very beginning. ## Phrase queriesIf you want to search for phrases, use quotation marks:```Pythonpocket_search.search(text='&quot;this is&quot; &quot;a phrase&quot;').count()```## Combining lookupsLookups can also be combined:```Pythonpocket_search.search(text__allow_prefix__allow_boolean=&quot;hel* OR wor*&quot;)[0].textHello World !```## Ordering resultsBy invoking the order method you can influence how your results are sorted. By default search results are sorted by relevance to the query.```Python# Order by text in ascending orderpocket_search.search(text__allow_boolean=&quot;hello OR world&quot;).order_by(&quot;text&quot;)# This is equivalent to the previous call:pocket_search.search(text__allow_boolean=&quot;hello OR world&quot;).order_by(&quot;+text&quot;)# Order by text in descending orderpocket_search.search(text__allow_boolean=&quot;hello OR world&quot;).order_by(&quot;-text&quot;)```**+** indicates ascending order, **-** descending order. If not explicitly given, ascending order is assumed. &gt; **_NOTE:_** If order_by is not explicitly set, results are order by rank in descending order.## Highlighting and extracting snippets from resultsFTS5 provides 2 functions to highlight tokens found in text and extracting snippets from a text. There are 2 methods to support this in pocketsearch:```Pythonpocket_search.search(text=&quot;hello&quot;).highlight(&quot;text&quot;)[0].text*Hello* World !```The keyword arguments marker_start and marker_end allow you to control how highlighting is done:```Pythonpocket_search.search(text=&quot;hello&quot;).highlight(&quot;text&quot;,marker_start=&quot;[&quot;,marker_end=&quot;]&quot;)[0].text[Hello] World !```The positional arguments of the highlight method represent the fields you want to hightlight. If you have very long text, you might want to only show a snippet with all terms found in your +search results. This can be done with the snippet method. Assuming we have the article on Wikipedia article on [inverted indices](https://en.wikipedia.org/wiki/Inverted_index) in our database we can extract snippets like this:```Pythonpocket_search.search(text=&quot;inverted file&quot;).snippet(&quot;text&quot;,snippet_length=16)[0].text'In computer science, an *inverted* index (also referred to as a postings list, postings *file*, or...'```Similar to the highlight method, the snippet method highlights tokens found. snippet_length defines the maximum number of tokens that should be contained in the snippet. It must be greater than 0 and lesser than 64. You can change the markers by providing text_before and text_after arguments:```Pythonpocket_search.search(text=&quot;inverted file&quot;).snippet(&quot;text&quot;,snippet_length=16,text_before=&quot;&lt;&quot;,text_after=&quot;&gt;&quot;)[0].text```## Autocomplete queriesThe autocomplete feature is a convenience function that predicts the rest of an input a user might type as a query. ```Pythonpocket_search.autocomplete(text=&quot;inv&quot;)[0]Inverted file```Autocomplete works as follows:* If only one token is entered the query is turned to a prefix query: ^inv* OR inv - thus the characters are searched at the beginning of the column OR at any arbitrary position in the column.* If more tokens are provided (e.g. &quot;inverted f&quot; - separated by whitespaces), only the last token is turned to a prefix query. In this case the query becomes (^inverted OR inverted) AND f*Some rules apply when using the autocomplete method:* Look ups are not allowed (e.g. allow_boolean, etc.)* Special operators are not allowed (e.g. ^ or *)* You can only provide one field as keyword argument* .autocomplete returns a Query objects, thus you can apply slicing, counting, order_by and highlighting as described above.# SchemasA search index may have an arbitrary list of fields that can be searched. Schemas are defined through Schema classes:```Pythonfrom pocketsearch import Schema, PocketSearchfrom pocketsearch import Text, Int, Real, Numeric, Blob, Date, Datetimeclass FileContents(Schema):    text = Text(index=True)    filename = Text(is_id_field=True)# create pocketsearch instance and provide schemapocket_search.PocketSearch(schema=FileContents)pocket_search.insert(text=&quot;Hello world&quot;,filename=&quot;a.txt&quot;)```## FieldsFollowing fields are available:| Field        | SQLite data type | |--------------|-----------|| Text         | TEXT   || Int          | INTEGER  || Real         | REAL  || Numeric      | Numeric  || Blob         | Blob  || Date         | Date  || Datetime     | Datetime  |Following options are available for fields:* **index** - if the field is a Text field, a full text search index is created, otherwise a standard sqlite3 index is created* **is_id_field** - a schema can only have one IDField. It is used by the .insert_or_update method to decide if a document should be inserted or an existing document should be updated.With respect to naming your fields following restrictions apply:* Fields may not start with an underscore.* Fields may not contain double underscores.Moreover field names may not be composed of reserved SQL keywords.&gt; **_NOTE:_**  While not explicitly set, pocketsearch automatically adds an &quot;id&quot; field to the schema (using the INTEGER data type plus the AUTOINCREMENT option of sqlite). It is used as the primary key for each document. The ID field is used to delete or update documents.## Queries on multi-field indicesOnce the schema is created, you can query multiple fields:```Python# Searches field text for &quot;world&quot;pocket_search.search(text=&quot;world&quot;)# Searches documents that contain &quot;world&quot; in text AND have &quot;a.txt&quot; is a filename.# Please note: as &quot;filename&quot; has not set its index option, only exact matches # will be considered.pocket_search.search(text=&quot;world&quot;,filename=&quot;a.txt&quot;)```&gt; **_NOTE:_**  When using multiple fields in search, the default boolean operation is AND.### AND/OR queries on multiple fieldsSimilar to the Django web framework, you can use &quot;Q Objects&quot; to express OR queries on multiple fields:```Pythonfrom pocketsearch import Q# Search for documents where text=&quot;world&quot; OR filename=&quot;a.txt&quot;q = pocket_search.search(Q(text=&quot;world&quot;) | Q(filename=&quot;a.txt&quot;))# Search for documents where text=&quot;world&quot; AND filename=&quot;a.txt&quot;q = pocket_search.search(Q(text=&quot;world&quot;) &amp; Q(filename=&quot;a.txt&quot;))```Please note, that you either have to use one notation or the other. You cannot mix Q objects with keyword arguments and you can only provide one field per Q object:```Python# This will NOT work:pocket_search.search(Q(text=&quot;world&quot;) , filename=&quot;a.txt&quot;)# This will work neither:pocket_search.search(Q(text=&quot;world&quot;,filename=&quot;a.txt&quot;))```## Setting prefix indicesTo speed up prefix queries, you can setup prefix indices:```Python    class PrefixIndex1(Schema):        '''        Simple schema that sets a prefix index for         2,3 and 4 characters        '''        class Meta:            prefix_index=[2,3,4]        body = Text(index=True)```This will create prefix indices for 2,3 and 4 character prefixes.# Inserting, updating and deleting data## Handling updates and deletesUsing the id of a document, you can run updates:```Pythonpocket_search.update(rowid=1, text=&quot;The updated text.&quot;)```If want to update more fields, simply provide them as keyword arguments.To delete a document, use:```Pythonpocket_search.delete(rowid=1)```## Using index readers to insert dataNormally we have a data source at hand (e.g. files in a file system or a source database) that we use to read data from. IndexReader classes can be used to build an index from such a data source. Assume, you want to index text files from a directory, we first define a schema:```Pythonclass FileSchema(Schema):        text = Text(index=True)        filename = Text(is_id_field=True) ```Next, we create a PocketSearch and ```Pythonfrom pocketsearch import FileSystemReaderpocket_search = PocketSearch(schema=FileSchema)reader = FileSystemReader(base_dir=&quot;/some/directory&quot;, file_extensions=[&quot;.txt&quot;])pocket_search.build(reader)```This will build the index. If a document has already been seen it will be updated, a new document will be inserted otherwise. Currently, the FileSystemReader is the only implementation provided, however you can easily implement your own by implementing the abstract class IndexError implementing a .read method. The .read method should return an iterable containing dictionaries whereas the dictionary's keys correspond to schema fields and its values the data you want to insert for the document. ## Optimizing the index for query performanceIf you have inserted a large volume of new documents, it might be sensible to optimize the index for query performance. This can be achieved by running VACUUM ANALYSE on the database, pocketsearch has a convenience method for this, that can be run e.g. after the indexing process is complete:```Pythonpocket_search = PocketSearch(db_name=&quot;my_db.db&quot;,writeable=True)pocket_search.optimize()```Note, that this will close the current database connection and establish a new one. # More search options## Searching numeric dataYou can also search for numeric data:```Pythonclass Product(Schema):    price = Int()    description = Text(index=True) # Full text index    category = Text()  # not part of FT index``````Pythonpocket_search = PocketSearch(schema=Product)# Create some sensible test data before proceeding ...# Matches products with price=3pocket_search.search(price=3)# Matches products with price greater than 3pocket_search.search(price__gt=3)# Matches products with price lower than 3pocket_search.search(price__lt=3)# Matches products with price lower than equal 3pocket_search.search(price__lte=3)# Matches products with price greater than equal 3pocket_search.search(price__gte=3)# Matches products with price greater than equal 3 AND where the description contains &quot;apple&quot;.pocket_search.search(price__gte=3,description=&quot;apple&quot;)```You can also provide an index for numeric data by setting ...```Pythonprice = Int(index=True)```... to speed up queries.## Searching date fieldspocketsearch also provides some (experimental) support for searching dates:```Pythonclass AllFields(Schema):    published=Datetime()pocket_search = PocketSearch(schema=Product)# Search documents published in year 2023pocket_search.search(published__year=2023)# Search document published after 2020pocket_search.search(published__year__gt=2023)# Search documents published in month 6pocket_search.search(published__month=6)# Search documents published on 21/6/2023:pocket_search.search(published__month=21,published__month=6,published_year=2023)```&gt; **_NOTE:_**  In search results, datefields are automatically converted to datetime and date objects respectivley. # Making your database persistentThe previous examples use an in-memory sqlite database. If you want to actually store the database, you have to provide a name:```Pythonpocket_search = PocketSearch(db_name=&quot;my_db.db&quot;,writeable=True)# now, all operations will be done on the my_db database that is stored in the # current working directory.```When working with search indices that are stored on disk, *it is important to provide the writeable argument*, as any PocketSearch instance that works with file sqlite databases, is in read-only mode by default (unlike their in-memory counterpart.). # Behind the scenes: how searching workspocketsearch uses the FTS5 extension of sqlite. More information can be found here:https://www.sqlite.org/fts5.htmlInternally, it:* Creates two tables, one named &quot;document&quot; and one virtual table &quot;document_idx&quot; - the latter holds the full-text-search enabled files.* The document_idx table is populated through triggers on the document table. * It uses the unicode61 tokenizer as default.If you want to change the tokenizer, you can do so by overriding the Meta class of a schema:```Pythonfrom pocketsearch import Schema, PocketSearchclass FileContents(Schema):    class Meta:        '''        Additional options for setting up FTS5        See https://www.sqlite.org/fts5.html for more information.        If a value is set to None, we leave it up to sqlite to        set proper defaults.        '''        sqlite_tokenize = &quot;unicode61&quot; # change to available tokenizer of your choice        sqlite_remove_diacritics = None        sqlite_categories = None        sqlite_tokenchars = None        sqlite_separators = None        text = Text(index=True)    filename = Text(is_id_field=True)```# Multiple indices in one databaseYou can have multiple indices in one database (only databases written to disk) by setting the &quot;index_name&quot; option:```Pythonpocket_search = PocketSearch(db_name=&quot;my_db.db&quot;,index_name=&quot;Product&quot;,schema=Product)```# ContributePull requests are welcome. If you come across any issues, please report them at https://github.com/kaykay-dv/pocketsearch/issues</longdescription>
</pkgmetadata>