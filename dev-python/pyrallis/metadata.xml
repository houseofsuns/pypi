<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eladrich/pyrallis/master/docs/pyrallis_logo.png&quot; alt=&quot;logo&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://badge.fury.io/py/pyrallis&quot;&gt;&lt;img src=&quot;https://badge.fury.io/py/pyrallis.svg&quot; alt=&quot;PyPI version&quot; height=&quot;18&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;https://github.com/eladrich/pyrallis/actions/workflows/pytest.yml&quot;&gt;&lt;img src=&quot;https://github.com/eladrich/pyrallis/actions/workflows/pytest.yml/badge.svg&quot; alt=&quot;PyTest&quot; height=&quot;18&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;https://pepy.tech/project/pyrallis&quot;&gt;&lt;img src=&quot;https://pepy.tech/badge/pyrallis&quot; alt=&quot;Downloads&quot; height=&quot;18&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;#contributors-&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/all_contributors-2-orange.svg&quot; alt=&quot;All Contributors&quot; height=&quot;18&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;https://opensource.org/licenses/MIT&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/License-MIT-yellow.svg&quot; alt=&quot;License: MIT&quot; height=&quot;18&quot;&gt;&lt;/a&gt;&lt;/p&gt;# Pyrallis - Simple Configuration with Dataclasses&gt; Pyrausta (also called pyrallis (œÄœÖœÅŒ±ŒªŒªŒØœÇ), pyragones) is a mythological insect-sized dragon from Cyprus.`Pyrallis` is a simple library, derived from `simple-parsing` and inspired by `Hydra`, for automagically creating project configuration from a dataclass.&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://github.com/eladrich/pyrallis/raw/master/docs/argparse2pyrallis.gif&quot; alt=&quot;GIF&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;## Why `pyrallis`?With `pyrallis` your configuration is linked directly to your pre-defined `dataclass`, allowing you to easily create different configuration structures, including nested ones, using an object-oriented design. The parsed arguments are used to initialize your `dataclass`, giving you the typing hints and automatic code completion of a full `dataclass` object.## My First Pyrallis Example üë∂There are several key features to pyrallis but at its core pyrallis simply allows defining an argument parser using a dataclass.```python from dataclasses import dataclassimport pyrallis@dataclassclass TrainConfig:    &quot;&quot;&quot; Training config for Machine Learning &quot;&quot;&quot;    workers: int = 8 # The number of workers for training    exp_name: str = 'default_exp' # The experiment namedef main():    cfg = pyrallis.parse(config_class=TrainConfig)    print(f'Training {cfg.exp_name} with {cfg.workers} workers...')```The arguments can then be specified using command-line arguments, a `yaml` configuration file, or both.```console$ python train_model.py --config_path=some_config.yaml --exp_name=my_first_expTraining my_first_exp with 42 workers...```Assuming the following configuration file```yamlexp_name: my_yaml_expworkers: 42```### Key FeaturesBuilding on that design `pyrallis` offers some really enjoyable features including * Builtin IDE support for autocompletion and linting thanks to the structured config. ü§ì* Joint reading from command-line and a config file, with support for specifying a default config file. üòç* Support for builtin dataclass features, such as `__post_init__` and `@property` üòÅ* Support for nesting and inheritance of dataclasses, nested arguments are automatically created! üò≤* A magical `@pyrallis.wrap()` decorator for wrapping your main class ü™Ñ* Easy extension to new types using `pyrallis.encode.register` and `pyrallis.decode.register` üëΩ* Easy loading and saving of existing configurations using `pyrallis.dump` and `pyrallis.load` üíæ* Magical `--help` creation from dataclasses, taking into account the comments as well! üòé* Support for multiple configuration formats (`yaml`, `json`,`toml`) using `pyrallis.set_config_type` ‚öôÔ∏è## Getting to Know The `pyrallis` API in 5 Simple Steps üê≤The best way to understand the full `pyrallis` API is through examples, let's get started!###  üê≤ 1/5 `pyrallis.parse` for `dataclass` Parsing üê≤Creation of an argparse configuration is really simple, just use `pyrallis.parse` on your predefined dataclass.```pythonfrom dataclasses import dataclass, fieldimport pyrallis@dataclassclass TrainConfig:    &quot;&quot;&quot; Training config for Machine Learning &quot;&quot;&quot;    # The number of workers for training    workers: int = field(default=8)    # The experiment name    exp_name: str = field(default='default_exp')def main():    cfg = pyrallis.parse(config_class=TrainConfig)    print(f'Training {cfg.exp_name} with {cfg.workers} workers...')if __name__ == '__main__':    main()```&gt; Not familiar with `dataclasses`? you should probably check the [Python Tutorial](https://docs.python.org/3/library/dataclasses.html) and come back here.The config can then be parsed directly from command-line```console$ python train_model.py --exp_name=my_first_modelTraining my_first_model with 8 workers...```Oh, and `pyrallis` also generates an `--help` string automatically using the comments in your dataclass ü™Ñ```console$ python train_model.py --helpusage: train_model.py [-h] [--config_path str] [--workers int] [--exp_name str]optional arguments:  -h, --help      show this help message and exit  --config_path str    Path for a config file to parse with pyrallis (default:                  None)TrainConfig:   Training config for Machine Learning  --workers int   The number of workers for training (default: 8)  --exp_name str  The experiment name (default: default_exp)```### üê≤ 2/5 The `pyrallis.wrap` Decorator üê≤Don't like the `pyrallis.parse` syntax?```pythondef main():    cfg = pyrallis.parse(config_class=TrainConfig)    print(f'Training {cfg.exp_name} with {cfg.workers} workers...')```One can equivalently use the `pyrallis.wrap` syntax üòé ```python@pyrallis.wrap()def main(cfg: TrainConfig):    # The decorator automagically uses the type hint to parsers arguments into TrainConfig    print(f'Training {cfg.exp_name} with {cfg.workers} workers...')```We will use this syntax for the rest of our tutorial.### üê≤ 3/5 Better Configs Using Inherent `dataclass` Features üê≤When using a dataclass we can add additional functionality using existing `dataclass` features, such as the `post_init` mechanism or `@properties` :grin:```pythonfrom dataclasses import dataclass, fieldfrom pathlib import Pathfrom typing import Optionalimport pyrallis@dataclassclass TrainConfig:    &quot;&quot;&quot; Training config for Machine Learning &quot;&quot;&quot;    # The number of workers for training    workers: int = field(default=8)    # The number of workers for evaluation    eval_workers: Optional[int] = field(default=None)    # The experiment name    exp_name: str = field(default='default_exp')    # The experiment root folder path    exp_root: Path = field(default=Path('/share/experiments'))    def __post_init__(self):        # A builtin method of dataclasses, used for post-processing our configuration.        self.eval_workers = self.eval_workers or self.workers    @property    def exp_dir(self) -&gt; Path:        # Properties are great for arguments that can be derived from existing ones        return self.exp_root / self.exp_name@pyrallis.wrap()def main(cfg: TrainConfig):    print(f'Training {cfg.exp_name}...')    print(f'\tUsing {cfg.workers} workers and {cfg.eval_workers} evaluation workers')    print(f'\tSaving to {cfg.exp_dir}')``````console$ python -m train_model.py --exp_name=my_second_exp --workers=42Training my_second_exp...    Using 42 workers and 42 evaluation workers    Saving to /share/experiments/my_second_exp```&gt; Notice that in all examples we use the explicit `dataclass.field` syntax. This isn't a requirement of `pyrallis` but rather a style choice. As some of your arguments will probably require `dataclass.field` (mutable types for example) we find it cleaner to always use the same notation.### üê≤ 4/5 Building Hierarchical Configurations üê≤Sometimes configs get too complex for a flat hierarchy üòï, luckily `pyrallis` supports nested dataclasses üí•```python@dataclassclass ComputeConfig:    &quot;&quot;&quot; Config for training resources &quot;&quot;&quot;    # The number of workers for training    workers: int = field(default=8)    # The number of workers for evaluation    eval_workers: Optional[int] = field(default=None)    def __post_init__(self):        # A builtin method of dataclasses, used for post-processing our configuration.        self.eval_workers = self.eval_workers or self.workers@dataclassclass LogConfig:    &quot;&quot;&quot; Config for logging arguments &quot;&quot;&quot;    # The experiment name    exp_name: str = field(default='default_exp')    # The experiment root folder path    exp_root: Path = field(default=Path('/share/experiments'))    @property    def exp_dir(self) -&gt; Path:        # Properties are great for arguments that can be derived from existing ones        return self.exp_root / self.exp_name# TrainConfig will be our main configuration class.# Notice that default_factory is the standard way to initialize a class argument in dataclasses@dataclassclass TrainConfig:    log: LogConfig = field(default_factory=LogConfig)    compute: ComputeConfig = field(default_factory=ComputeConfig)@pyrallis.wrap()def main(cfg: TrainConfig):    print(f'Training {cfg.log.exp_name}...')    print(f'\tUsing {cfg.compute.workers} workers and {cfg.compute.eval_workers} evaluation workers')    print(f'\tSaving to {cfg.log.exp_dir}')```The argument parse will be updated accordingly```console$ python train_model.py --log.exp_name=my_third_exp --compute.eval_workers=2Training my_third_exp...    Using 8 workers and 2 evaluation workers    Saving to /share/experiments/my_third_exp```### üê≤ 5/5 Easy Serialization with `pyrallis.dump` üê≤As your config get longer you will probably want to start working with configuration files. Pyrallis supports encoding a dataclass configuration into a `yaml` file üíæThe command `pyrallis.dump(cfg, open('run_config.yaml','w'))` will result in the following `yaml` file```yamlcompute:  eval_workers: 2  workers: 8log:  exp_name: my_third_exp  exp_root: /share/experiments```&gt; `pyrallis.dump` extends `yaml.dump` and uses the same syntax.Configuration files can also be loaded back into a dataclass, and can even be used together with the command-line arguments.```pythoncfg = pyrallis.parse(config_class=TrainConfig,                              config_path='/share/configs/config.yaml')# or the decorator synrax@pyrallis.wrap(config_path='/share/configs/config.yaml')# or with the CONFIG argumentpython my_script.py --log.exp_name=readme_exp --config_path=/share/configs/config.yaml# Or if you just want to load from a .yaml without cmd parsingcfg = pyrallis.load(TrainConfig, '/share/configs/config.yaml')```&gt; Command-line arguments have a higher priority and will override the configuration fileFinally, one can easily extend the serialization to support new types üî•```python# For decoding from cmd/yamlpyrallis.decode.register(np.ndarray,np.asarray)# For encoding to yaml pyrallis.encode.register(np.ndarray, lambda x: x.tolist())# Or with the wrapper version instead @pyrallis.encode.registerdef encode_array(arr : np.ndarray) -&gt; str:    return arr.tolist()```#### üê≤ That's it you are now a `pyrallis` expert! üê≤## Why Another Parsing Library?&lt;img src=&quot;https://imgs.xkcd.com/comics/standards_2x.png&quot; alt=&quot;XKCD 927 - Standards&quot; width=&quot;70%&quot; /&gt;&gt; XKCD 927 - Standards The builtin `argparse` has many great features but is somewhat outdated :older_man: with one its greatest weakness being the lack of typing. This has led to the development of many great libraries tackling different weaknesses of `argparse` (shout out for all the great projects out there! You rock! :metal:).  In our case, we were looking for a library that would  support the vanilla `dataclass` without requiring dedicated classes, and would have a loading interface from both command-line and files. The closest candidates were `hydra` and `simple-parsing`, but they weren't exactly what we were looking for. Below are the pros and cons from our perspective:#### [Hydra](https://github.com/facebookresearch/hydra)A framework for elegantly configuring complex applications from Facebook Research.* Supports complex configuration from multiple files and allows for overriding them from command-line.* Does not support non-standard types, does not play nicely with `datclass.__post_init__`and requires a `ConfigStore` registration.#### [SimpleParsing](https://github.com/lebrice/SimpleParsing)A framework for simple, elegant and typed Argument Parsing by Fabrice Normandin* Strong integration with `argparse`, support for nested configurations together with standard arguments.* No support for joint loading from command-line and files, dataclasses are still wrapped by a Namespace, requires dedicated classes for serialization.We decided to create a simple hybrid of the two approaches, building from `SimpleParsing` with some `hydra` features in mind. The result, `pyrallis`, is a simple library that that is relatively low on features, but hopefully excels at what it does.If `pyrallis` isn't what you're looking for we strongly advise you to give `hydra` and `simpleParsing` a try (where other interesting option include `click`, `ext_argpase`, `jsonargparse`, `datargs` and `tap`). If you do :heart: `pyrallis` then welcome aboard! We're gonna have a great journey together! üê≤## Tips and Design Choices### Beware of Mutable Types (or use pyrallis.field)Dataclasses are great (really!) but using mutable fields can sometimes be confusing. For example, say we try to code the following dataclass```python@dataclassclass OptimConfig:    worker_inds: List[int] = []    # Or the more explicit version    worker_inds: List[int] = field(default=[])```As `[]` is mutable we would actually initialize every instance of this dataclass with the same list instance, and thus is not allowed. Instead `dataclasses` would direct you the default_factory function, which calls a factory function for generating the field in every new instance of your dataclass.```pythonworker_inds: List[int] = field(default_factory=list)```Now, this works great for empty collections, but what would be the alternative for```pythonworker_inds: List[int] = field(default=[1,2,3])```Well, you would have to create a dedicated factory function that regenerates the object, for example```pythonworker_inds: List[int] = field(default_factory=lambda : [1,2,3])```Kind of annoying and could be confusing for a new guest reading your code :confused: Now, while this isn't really related to parsing/configuration we decided it could be nice to offer a sugar-syntax for such cases as part of `pyrallis````pythonfrom pyrallis import fieldworker_inds: List[int] = field(default=[1,2,3], is_mutable=True)```The `pyrallis.field` behaves like the regular `dataclasses.field` with an additional `is_mutable` flag. When toggled, the `default_factory` is created automatically, offering the same functionally with a more reader-friendly syntax.### Uniform Parsing SyntaxFor parsing files we opted for `yaml` as our format of choice, following `hydra`, due to its concise format. Now, let us assume we have the following `.yaml` file which `yaml` successfully handles:```yamlcompute:  worker_inds: [0,2,3]```Intuitively we would also want users to be able to use the same syntax ```cmdpython my_app.py --compute.worker_inds=[0,2,3]```However, the more standard syntax for an argparse application would be ```cmdpython my_app.py --compute.worker_inds 0 2 3```We decided to use the same syntax as in the `yaml` files to avoid confusion when loading from multiple sources.Not a `yaml` fun? `pyrallis` also supports `json` and `toml` formats using `pyrallis.set_config_type('json')` or `with pyrallis.config_type('json'):`# TODOs:- [x] Fix error with default Dict and List&gt;         Underlying error: No decoding function for type ~KT, consider using pyrallis.decode.register- [x] Refine the `--help` command&gt; For example the `options` argument is confusing there- [ ] Add a test to `omit_defaults`## Contributors ‚ú®Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):&lt;!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section --&gt;&lt;!-- prettier-ignore-start --&gt;&lt;!-- markdownlint-disable --&gt;&lt;table&gt;  &lt;tr&gt;    &lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://about.me/ido.weiss&quot;&gt;&lt;img src=&quot;https://avatars.githubusercontent.com/u/10072365?v=4?s=100&quot; width=&quot;100px;&quot; alt=&quot;&quot;/&gt;&lt;br /&gt;&lt;sub&gt;&lt;b&gt;Ido Weiss&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;#design-idow09&quot; title=&quot;Design&quot;&gt;üé®&lt;/a&gt; &lt;a href=&quot;#ideas-idow09&quot; title=&quot;Ideas, Planning, &amp; Feedback&quot;&gt;ü§î&lt;/a&gt;&lt;/td&gt;    &lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/yairf11&quot;&gt;&lt;img src=&quot;https://avatars.githubusercontent.com/u/13931256?v=4?s=100&quot; width=&quot;100px;&quot; alt=&quot;&quot;/&gt;&lt;br /&gt;&lt;sub&gt;&lt;b&gt;Yair Feldman&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;#design-yairf11&quot; title=&quot;Design&quot;&gt;üé®&lt;/a&gt; &lt;a href=&quot;#ideas-yairf11&quot; title=&quot;Ideas, Planning, &amp; Feedback&quot;&gt;ü§î&lt;/a&gt;&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;!-- markdownlint-restore --&gt;&lt;!-- prettier-ignore-end --&gt;&lt;!-- ALL-CONTRIBUTORS-LIST:END --&gt;This project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!</longdescription>
</pkgmetadata>