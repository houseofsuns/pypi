<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>mutablerecords.Record---------------------This is similar to collections.namedtuple, except it supports optionalattributes and mutability. A class definition is generated (with\_\_slots\_\_, \_\_str\_\_ and other niceties), and can be used toinstantiate new records of that type. The record can also be subclassedto add new attributes or to add methods to that data.Sometimes, a Record definition is used to replace a simple \_\_init\_\_method that only takes N arguments and sets them as instance variables.These \_\_init\_\_ methods are tedious to write and, even if you do, youstill have to write str, hash, eq functions, and set \_\_slots\_\_ to befully correct, but who has the time for that? With records, you get allof that in a single declaration, which you can even inline as your baseclass... code:: python    # This acts like a mutable namedtuple, taking the same arguments.    Simple = mutablerecords.Record('Simple', ['foo'])    # Now let's use a default argument.    SecondRecord = mutablerecords.Record('SecondRecord', ['attr1', 'attr2'], {'attr3': 0})    foo = SecondRecord(1, 2, attr3=3)    # str(foo) --&gt; 'SecondRecord(attr1=1, attr2=2, attr3=3)'    bar = SecondRecord(attr1=1, attr2=2, attr3=5)    # str(bar) --&gt; 'SecondRecord(attr1=1, attr2=2, attr3=5)'    class Third(SecondRecord):        required_attributes = ['third1']        optional_attributes = {'third2': 5}    # Third requires attr1, attr2, and third1.    baz = Third(1, 2, 3, third2=4)    # Here, second1 is required, so it goes before attr3:    # str(baz) --&gt; 'Third(attr1=1, attr2=2, third1=3, attr3=0, third2=5)'    class OptionalMaker(mutablerecords.Record('Required', ['required'])):        required = None        required_attributes = ['other']    opt = OptionalMaker(1)    # OptionalMaker has a class attribute that matches the name of a    #   required_attribute (required), so it becomes an optional_attribute with a    #   default equal to the attribute value (None). It also defines a new    #   required attribute 'other', which is set in opt as 1:    # str(opt) --&gt; 'OptionalMaker(other=1, required=None)'    opt2 = OptionalMaker(2, required=3)    # This time, opt2 has required set, too, which is still an attribute.    # str(opt2) --&gt; 'OptionalMaker(other=2, required=3)'mutablerecords.HashableRecord-----------------------------All this does is add a \_\_hash\_\_ implementation for when the recordwill be hashed, such as when a key in a ``dict`` or in a ``set``.mutablerecords.CopyRecord-------------------------This will copy a record and all of its fields. If a field is set to aRecord instance, then it is also copied using ``CopyRecord``. A futurefeature may also check for collections of Records, such as tuples orlists of instances, and recurse into those as well.</longdescription>
</pkgmetadata>