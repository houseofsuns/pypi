<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![arXiv](https://img.shields.io/badge/arXiv-2011.00898-b31b1b.svg)](https://arxiv.org/abs/2011.00898)[![DOI](https://joss.theoj.org/papers/10.21105/joss.02844/status.svg)](https://doi.org/10.21105/joss.02844)&lt;img src=&quot;https://i.imgur.com/2nGwlux.png&quot; alt=&quot;c-lasso&quot; height=&quot;145&quot; align=&quot;right&quot;/&gt;# c-lasso: a Python package for constrained sparse regression and classification c-lasso is a Python package that enables sparse and robust linear regression and classification with linear equalityconstraints on the model parameters. For detailed info, one can check the [documentation](https://c-lasso.readthedocs.io/en/latest/).The forward model is assumed to be: &lt;img src=&quot;https://latex.codecogs.com/gif.latex?y=X\beta&amp;plus;\sigma\epsilon\qquad\text{s.t.}\qquad&amp;space;C\beta=0&quot; title=&quot;y=X\beta+\sigma\epsilon\qquad\text{s.t.}\qquad C\beta=0&quot; /&gt;Here, y and X are given outcome and predictor data. The vector y can be continuous (for regression) or binary (for classification). C is a general constraint matrix. The vector &amp;beta; comprises the unknown coefficients and &amp;sigma; an unknown scale.The package handles several different estimators for inferring &amp;beta; (and &amp;sigma;), including the constrained Lasso, the constrained scaled Lasso, sparse Huber M-estimation with linear equality constraints, and regularized Support Vector Machines.Several different algorithmic strategies, including path and proximal splitting algorithms, are implemented to solve the underlying convex optimization problems.We also include two model selection strategies for determining the sparsity of the model parameters: k-fold cross-validation and stability selection.   This package is intended to fill the gap between popular python tools such as [scikit-learn](https://scikit-learn.org/stable/) which CANNOT solve sparse constrained problems and general-purpose optimization solvers that do not scale well or are inaccurate (see [benchmarks](./benchmark/README.md)) for the considered problems. In its current stage, however, c-lasso is not yet compatible with the scikit-learn API but rather a stand-alone tool.Below we show several use cases of the package, including an application of sparse *log-contrast*regression tasks for *compositional* microbiome data.The code builds on results from several papers which can be found in the [References](#references). We also refer to the accompanying [JOSS paper submission](https://github.com/Leo-Simpson/c-lasso/blob/master/paper/paper.md), also available on [arXiv](https://arxiv.org/pdf/2011.00898.pdf).## Table of Contents* [Installation](#installation)* [Regression and classification problems](#regression-and-classification-problems)* [Getting started](#getting-started)* [Log-contrast regression for microbiome data](#log-contrast-regression-for-microbiome-data)* [Optimization schemes](#optimization-schemes)* [References](#references)##  Installationc-lasso is available on pip. You can install the packagein the shell using```shellpip install c-lasso```To use the c-lasso package in Python, type ```pythonfrom classo import classo_problem # one can add auxiliary functions as well such as random_data or csv_to_np```The `c-lasso` package depends on the following Python packages:- `numpy`; - `matplotlib`; - `scipy`; - `pandas`; - `pytest` (for tests)##  Regression and classification problemsThe c-lasso package can solve six different types of estimation problems: four regression-type and two classification-type formulations.#### [R1] Standard constrained Lasso regression:             &lt;img src=&quot;https://latex.codecogs.com/gif.latex?\arg\min_{\beta\in&amp;space;R^d}&amp;space;||&amp;space;X\beta-y&amp;space;||^2&amp;space;&amp;plus;&amp;space;\lambda&amp;space;||\beta||_1&amp;space;\qquad\mbox{s.t.}\qquad&amp;space;C\beta=0&quot; /&gt;This is the standard Lasso problem with linear equality constraints on the &amp;beta; vector. The objective function combines Least-Squares for model fitting with l1 penalty for sparsity.   #### [R2] Constrained sparse Huber regression:                   &lt;img src=&quot;https://latex.codecogs.com/gif.latex?\arg\min_{\beta\in&amp;space;R^d}&amp;space;h_{\rho}(X\beta-y&amp;space;)&amp;space;&amp;plus;&amp;space;\lambda&amp;space;||\beta||_1&amp;space;\qquad\mbox{s.t.}\qquad&amp;space;C\beta=0&quot; /&gt;This regression problem uses the [Huber loss](https://en.wikipedia.org/wiki/Huber_loss) as objective function for robust model fitting with l1 and linear equality constraints on the &amp;beta; vector. The parameter &amp;rho;=1.345.#### [R3] Constrained scaled Lasso regression: &lt;img src=&quot;https://latex.codecogs.com/gif.latex?\arg&amp;space;\min_{\beta&amp;space;\in&amp;space;\mathbb{R}^d,&amp;space;\sigma&amp;space;&gt;&amp;space;0}&amp;space;\frac{||&amp;space;X\beta&amp;space;-&amp;space;y||^2}{\sigma}&amp;space;&amp;plus;&amp;space;\frac{n}{2}&amp;space;\sigma&amp;plus;&amp;space;\lambda&amp;space;||\beta||_1&amp;space;\qquad&amp;space;\mbox{s.t.}&amp;space;\qquad&amp;space;C\beta&amp;space;=&amp;space;0&quot; title=&quot;\arg \min_{\beta \in \mathbb{R}^d, \sigma &gt; 0} \frac{|| X\beta - y||^2}{\sigma} + \frac{n}{2} \sigma+ \lambda ||\beta||_1 \qquad \mbox{s.t.} \qquad C\beta = 0&quot; /&gt;This formulation is similar to [R1] but allows for joint estimation of the (constrained) &amp;beta; vector and the standard deviation &amp;sigma; in a concomitant fashion (see [References](#references) [4,5] for further info).This is the default problem formulation in c-lasso.#### [R4] Constrained sparse Huber regression with concomitant scale estimation:        &lt;img src=&quot;https://latex.codecogs.com/gif.latex?\arg&amp;space;\min_{\beta&amp;space;\in&amp;space;\mathbb{R}^d,&amp;space;\sigma&amp;space;&gt;&amp;space;0}&amp;space;\left(&amp;space;h_{\rho}&amp;space;\left(&amp;space;\frac{&amp;space;X\beta&amp;space;-&amp;space;y}{\sigma}&amp;space;\right)&amp;plus;&amp;space;n&amp;space;\right)&amp;space;\sigma&amp;plus;&amp;space;\lambda&amp;space;||\beta||_1&amp;space;\qquad&amp;space;\mbox{s.t.}&amp;space;\qquad&amp;space;C\beta&amp;space;=&amp;space;0&quot; title=&quot;\arg \min_{\beta \in \mathbb{R}^d, \sigma &gt; 0} \left( h_{\rho} \left( \frac{ X\beta - y}{\sigma} \right)+ n \right) \sigma+ \lambda ||\beta||_1 \qquad \mbox{s.t.} \qquad C\beta = 0&quot; /&gt;This formulation combines [R2] and [R3] to allow robust joint estimation of the (constrained) &amp;beta; vector and the scale &amp;sigma; in a concomitant fashion (see [References](#references) [4,5] for further info).#### [C1] Constrained sparse classification with Square Hinge loss: &lt;img src=&quot;https://latex.codecogs.com/gif.latex?\arg&amp;space;\min_{\beta&amp;space;\in&amp;space;\mathbb{R}^d}&amp;space;\sum_{i=1}^n&amp;space;l(y_i&amp;space;x_i^\top&amp;space;\beta)&amp;space;&amp;plus;&amp;space;\lambda&amp;space;\left\lVert&amp;space;\beta\right\rVert_1&amp;space;\qquad&amp;space;s.t.&amp;space;\qquad&amp;space;C\beta&amp;space;=&amp;space;0&quot; title=&quot;\arg \min_{\beta \in \mathbb{R}^d} \sum_{i=1}^n l(y_i x_i \beta) + \lambda \left\lVert \beta\right\rVert_1 \qquad s.t. \qquad C\beta = 0&quot; /&gt;where the x&lt;sub&gt;i&lt;/sub&gt; are the rows of X and l is defined as:&lt;img src=&quot;https://latex.codecogs.com/gif.latex?l(r)&amp;space;=&amp;space;\begin{cases}&amp;space;(1-r)^2&amp;space;&amp;&amp;space;if&amp;space;\quad&amp;space;r&amp;space;\leq&amp;space;1&amp;space;\\&amp;space;0&amp;space;&amp;if&amp;space;\quad&amp;space;r&amp;space;\geq&amp;space;1&amp;space;\end{cases}&quot; title=&quot;l(r) = \begin{cases} (1-r)^2 &amp; if \quad r \leq 1 \\ 0 &amp;if \quad r \geq 1 \end{cases}&quot; /&gt;This formulation is similar to [R1] but adapted for classification tasks using the Square Hinge losswith (constrained) sparse &amp;beta; vector estimation.#### [C2] Constrained sparse classification with Huberized Square Hinge loss:        &lt;img src=&quot;https://latex.codecogs.com/gif.latex?\arg&amp;space;\min_{\beta&amp;space;\in&amp;space;\mathbb{R}^d}&amp;space;\sum_{i=1}^n&amp;space;l_{\rho}(y_i&amp;space;x_i^\top\beta)&amp;space;&amp;plus;&amp;space;\lambda&amp;space;\left\lVert&amp;space;\beta\right\rVert_1&amp;space;\qquad&amp;space;s.t.&amp;space;\qquad&amp;space;C\beta&amp;space;=&amp;space;0&quot; title=&quot;\arg \min_{\beta \in \mathbb{R}^d} \sum_{i=1}^n l_{\rho}(y_i x_i\beta) + \lambda \left\lVert \beta\right\rVert_1 \qquad s.t. \qquad C\beta = 0&quot; /&gt;where the x&lt;sub&gt;i&lt;/sub&gt; are the rows of X and l&lt;sub&gt;ρ&lt;/sub&gt; is defined as:&lt;img src=&quot;https://latex.codecogs.com/gif.latex?l_{\rho}(r)&amp;space;=&amp;space;\begin{cases}&amp;space;(1-r)^2&amp;space;&amp;if&amp;space;\quad&amp;space;\rho&amp;space;\leq&amp;space;r&amp;space;\leq&amp;space;1&amp;space;\\&amp;space;(1-\rho)(1&amp;plus;\rho-2r)&amp;space;&amp;&amp;space;if&amp;space;\quad&amp;space;r&amp;space;\leq&amp;space;\rho&amp;space;\\&amp;space;0&amp;space;&amp;if&amp;space;\quad&amp;space;r&amp;space;\geq&amp;space;1&amp;space;\end{cases}&quot; title=&quot;l_{\rho}(r) = \begin{cases} (1-r)^2 &amp;if \quad \rho \leq r \leq 1 \\ (1-\rho)(1+\rho-2r) &amp; if \quad r \leq \rho \\ 0 &amp;if \quad r \geq 1 \end{cases}&quot; /&gt;This formulation is similar to [C1] but uses the Huberized Square Hinge loss for robust classification with (constrained) sparse &amp;beta; vector estimation.## Getting started#### Basic exampleWe begin with a basic example that shows how to run c-lasso on synthetic data. This example and the next one can be found on the notebook 'Synthetic data Notebook.ipynb'The c-lasso package includesthe routine ```random_data``` that allows you to generate problem instances using normally distributed data.```pythonm, d, d_nonzero, k, sigma = 100, 200, 5, 1, 0.5(X, C, y), sol = random_data(m, d, d_nonzero, k, sigma, zerosum=True, seed=1)```This code snippet generates a problem instance with sparse &amp;beta; in dimensiond=100 (sparsity d_nonzero=5). The design matrix X comprises n=100 samples generated from an i.i.d standard normaldistribution. The dimension of the constraint matrix C is d x k matrix. The noise level is &amp;sigma;=0.5. The input ```zerosum=True``` implies that C is the all-ones vector and C&amp;beta;=0. The n-dimensional outcome vector yand the regression vector &amp;beta; is then generated to satisfy the given constraints. Next we can define a default c-lasso problem instance with the generated data:```pythonproblem = classo_problem(X, y, C) ```You can look at the generated problem instance by typing:```pythonprint(problem)```This gives you a summary of the form:```FORMULATION: R3MODEL SELECTION COMPUTED:       Stability selectionSTABILITY SELECTION PARAMETERS:      numerical_method : not specified     method : first     B = 50     q = 10     percent_nS = 0.5     threshold = 0.7     lamin = 0.01     Nlam = 50```As we have not specified any problem, algorithm, or model selection settings, this problem instancerepresents the *default* settings for a c-lasso instance: - The problem is of regression type and uses formulation [R3], i.e. with concomitant scale estimation. - The *default* optimization scheme is the path algorithm (see [Optimization schemes](#optimization-schemes) for further info). - For model selection, stability selection at a theoretically derived &amp;lambda; value is used (see [Reference](#references) [4] for details). Stability selection comprises a relatively large number of parameters. For a description of the settings, we refer to the more advanced examples below and the API.You can solve the corresponding c-lasso problem instance using```pythonproblem.solve()```After completion, the results of the optimization and model selection routines can be visualized using```pythonprint(problem.solution)```The command shows the running time(s) for the c-lasso problem instance, and the selected variables for sability selection```STABILITY SELECTION :    Selected variables :  7    63    148    164    168       Running time :  1.546s```Here, we only used stability selection as *default* model selection strategy. The command also allows you to inspect the computed stability profile for all variables at the theoretical &amp;lambda; ![1.StabSel](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/basic/StabSel.png)The refitted &amp;beta; values on the selected support are also displayed in the next plot![beta](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/basic/beta.png)#### Advanced example             In the next example, we show how one can specify different aspects of the problem formulation and model selection strategy.```pythonm,  d,  d_nonzero,  k, sigma = 100, 200, 5, 0, 0.5(X, C, y), sol = random_data(m, d, d_nonzero, k, sigma, zerosum = True, seed = 4)problem                                     = classo_problem(X, y, C)problem.formulation.huber                   = Trueproblem.formulation.concomitant             = Falseproblem.model_selection.CV                  = Trueproblem.model_selection.LAMfixed            = Trueproblem.model_selection.PATH                = Trueproblem.model_selection.StabSelparameters.method = 'max'problem.model_selection.CVparameters.seed = 1problem.model_selection.LAMfixedparameters.rescaled_lam = Trueproblem.model_selection.LAMfixedparameters.lam = .1problem.solve()print(problem)print(problem.solution)```Results : ```     FORMULATION: R2     MODEL SELECTION COMPUTED:            Lambda fixed          Path          Cross Validation          Stability selection     LAMBDA FIXED PARAMETERS:           numerical_method = Path-Alg          rescaled lam : True          threshold = 0.09          lam = 0.1          theoretical_lam = 0.224     PATH PARAMETERS:           numerical_method : Path-Alg          lamin = 0.001          Nlam = 80     CROSS VALIDATION PARAMETERS:           numerical_method : Path-Alg          one-SE method : True          Nsubset = 5          lamin = 0.001          Nlam = 80     STABILITY SELECTION PARAMETERS:           numerical_method : Path-Alg          method : max          B = 50          q = 10          percent_nS = 0.5          threshold = 0.7          lamin = 0.01          Nlam = 50     LAMBDA FIXED :      Selected variables :  17    59    123         Running time :  0.104s     PATH COMPUTATION :      Running time :  0.638s     CROSS VALIDATION :      Selected variables :  16    17    57    59    64    73    74    76    93    115    123    134    137    181         Running time :  2.1s     STABILITY SELECTION :      Selected variables :  17    59    76    123    137         Running time :  6.062s```![2.StabSel](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/advanced/StabSel.png)![2.StabSel-beta](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/advanced/StabSel-beta.png)![2.CV-beta](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/advanced/CVbeta.png)![2.CV-graph](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/advanced/CV.png)![2.LAM-beta](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/advanced/beta.png)![2.Path](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/advanced/Beta-path.png)## Log-contrast regression for microbiome dataIn the [the accompanying notebook](./examples/example-notebook.ipynb) we study several microbiome data sets. We showcase two examples below.#### BMI prediction using the COMBO dataset We first consider the [COMBO data set](./examples/COMBO_data) and show how to predict Body Mass Index (BMI) from microbial genus abundances and two non-compositional covariates  using &quot;filtered_data&quot;.```pythonfrom classo import csv_to_np, classo_problem, clr# Load microbiome and covariate data XX0  = csv_to_np('COMBO_data/complete_data/GeneraCounts.csv', begin = 0).astype(float)X_C = csv_to_np('COMBO_data/CaloriData.csv', begin = 0).astype(float)X_F = csv_to_np('COMBO_data/FatData.csv', begin = 0).astype(float)# Load BMI measurements yy   = csv_to_np('COMBO_data/BMI.csv', begin = 0).astype(float)[:, 0]labels = csv_to_np('COMBO_data/complete_data/GeneraPhylo.csv').astype(str)[:, -1]# Normalize/transform datay   = y - np.mean(y) #BMI data (n = 96)X_C = X_C - np.mean(X_C, axis = 0)  #Covariate data (Calorie)X_F = X_F - np.mean(X_F, axis = 0)  #Covariate data (Fat)X0 = clr(X0, 1 / 2).T# Set up design matrix and zero-sum constraints for 45 generaX     = np.concatenate((X0, X_C, X_F, np.ones((len(X0), 1))), axis = 1) # Joint microbiome and covariate data and offsetlabel = np.concatenate([labels, np.array(['Calorie', 'Fat', 'Bias'])])C = np.ones((1, len(X[0])))C[0, -1], C[0, -2], C[0, -3] = 0., 0., 0.# Set up c-lassso problemproblem = classo_problem(X, y, C, label = label)# Use stability selection with theoretical lambda [Combettes &amp; Müller, 2020b]problem.model_selection.StabSelparameters.method      = 'lam'problem.model_selection.StabSelparameters.threshold_label = 0.5# Use formulation R3problem.formulation.concomitant = Trueproblem.solve()print(problem)print(problem.solution)# Use formulation R4problem.formulation.huber = Trueproblem.formulation.concomitant = Trueproblem.solve()print(problem)print(problem.solution)```![3.Stability profile R3](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/exampleFilteredCOMBO/R3-StabSel.png)![3.Beta solution R3](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/exampleFilteredCOMBO/R3-StabSel-beta.png)![3.Stability profile R4](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/exampleFilteredCOMBO/R4-StabSel.png)![3.Beta solution R4](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/exampleFilteredCOMBO/R4-StabSel-beta.png)&lt;!---&lt;img src=&quot;https://i.imgur.com/8tFmM8T.png&quot; alt=&quot;Central Park Soil Microbiome&quot; height=&quot;250&quot; align=&quot;right&quot;/&gt;#### pH prediction using the Central Park soil dataset The next microbiome example considers the [Central Park Soil dataset](./examples/pH_data) from [Ramirez et al.](https://royalsocietypublishing.org/doi/full/10.1098/rspb.2014.1988). The sample locations are shown in the Figure on the right.)--&gt;#### pH prediction using the 88 soils datasetThe next microbiome example considers the [88 soils dataset](./examples/pH_data) from [Lauber et al., 2009](https://pubmed.ncbi.nlm.nih.gov/19502440/).The task is to predict pH concentration in the soil from microbial abundance data. A similar analysis is availablein [Tree-Aggregated Predictive Modeling of Microbiome Data](https://www.biorxiv.org/content/10.1101/2020.09.01.277632v1) with Central Park soil data from [Ramirez et al.](https://royalsocietypublishing.org/doi/full/10.1098/rspb.2014.1988).Code to run this application is available in [the accompanying notebook](./examples/example-notebook.ipynb) under `pH data`. Below is a summary of a c-lasso problem instance (using the R3 formulation).```FORMULATION: R3MODEL SELECTION COMPUTED:       Lambda fixed     Path     Stability selectionLAMBDA FIXED PARAMETERS:      numerical_method = Path-Alg     rescaled lam : True     threshold = 0.004     lam : theoretical     theoretical_lam = 0.2182PATH PARAMETERS:      numerical_method : Path-Alg     lamin = 0.001     Nlam = 80STABILITY SELECTION PARAMETERS:      numerical_method : Path-Alg     method : lam     B = 50     q = 10     percent_nS = 0.5     threshold = 0.7     lam = theoretical     theoretical_lam = 0.3085```The c-lasso estimation results are summarized below:```LAMBDA FIXED :    Sigma  =  0.198   Selected variables :  14    18    19    39    43    57    62    85    93    94    104    107       Running time :  0.008s PATH COMPUTATION :    Running time :  0.12s STABILITY SELECTION :    Selected variables :  2    12    15       Running time :  0.287s```![Ex4.1](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/examplePH/R3-Beta-path.png)![Ex4.2](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/examplePH/R3-Sigma-path.png)![Ex4.3](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/examplePH/R3-StabSel.png)![Ex4.4](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/examplePH/R3-StabSel-beta.png)![Ex4.5](https://github.com/Leo-Simpson/c-lasso/blob/master/figures/examplePH/R3-beta.png)## Optimization schemesThe available problem formulations [R1-C2] require different algorithmic strategies for efficiently solving the underlying optimization problem. We have implemented four algorithms (with provable convergence guarantees) that vary in generality and are not necessarily applicable to all problems. For each problem type, c-lasso has a default algorithm setting that proved to be the fastest in our numerical experiments.### Path algorithms (Path-Alg) This is the default algorithm for non-concomitant problems [R1,R3,C1,C2]. The algorithm uses the fact that the solution path along &amp;lambda; is piecewise-affine (as shown, e.g., in [1]). When Least-Squares is used as objective function,we derive a novel efficient procedure that allows us to also derive the solution for the concomitant problem [R2] along the path with little extra computational overhead.### Projected primal-dual splitting method (P-PDS):This algorithm is derived from [2] and belongs to the class of proximal splitting algorithms. It extends the classical Forward-Backward (FB) (aka proximal gradient descent) algorithm to handle an additional linear equality constraintvia projection. In the absence of a linear constraint, the method reduces to FB.This method can solve problem [R1]. For the Huber problem [R3], P-PDS can solve the mean-shift formulation of the problem (see [6]).### Projection-free primal-dual splitting method (PF-PDS):This algorithm is a special case of an algorithm proposed in [3] (Eq.4.5) and also belongs to the class of proximal splitting algorithms. The algorithm does not require projection operators which may be beneficial when C has a more complex structure. In the absence of a linear constraint, the method reduces to the Forward-Backward-Forward scheme. This method can solve problem [R1]. For the Huber problem [R3], PF-PDS can solve the mean-shift formulation of the problem (see [6]).### Douglas-Rachford-type splitting method (DR)This algorithm is the most general algorithm and can solve all regression problems [R1-R4]. It is based on Doulgas Rachford splitting in a higher-dimensional product space.It makes use of the proximity operators of the perspective of the LS objective (see [4,5])The Huber problem with concomitant scale [R4] is reformulated as scaled Lasso problem with the mean shift (see [6]) and thus solved in (n + d) dimensions. ## References * [1] B. R. Gaines, J. Kim, and H. Zhou, [Algorithms for Fitting the Constrained Lasso](https://www.tandfonline.com/doi/abs/10.1080/10618600.2018.1473777?journalCode=ucgs20), J. Comput. Graph. Stat., vol. 27, no. 4, pp. 861–871, 2018.* [2] L. Briceno-Arias and S.L. Rivera, [A Projected Primal–Dual Method for Solving Constrained Monotone Inclusions](https://link.springer.com/article/10.1007/s10957-018-1430-2?shared-article-renderer), J. Optim. Theory Appl., vol. 180, Issue 3, March 2019.* [3] P. L. Combettes and J.C. Pesquet, [Primal-Dual Splitting Algorithm for Solving Inclusions with Mixtures of Composite, Lipschitzian, and Parallel-Sum Type Monotone Operators](https://arxiv.org/pdf/1107.0081.pdf), Set-Valued and Variational Analysis, vol. 20, pp. 307-330, 2012.* [4] P. L. Combettes and C. L. Müller, [Perspective M-estimation via proximal decomposition](https://arxiv.org/abs/1805.06098), Electronic Journal of Statistics, 2020, [Journal version](https://projecteuclid.org/euclid.ejs/1578452535) * [5] P. L. Combettes and C. L. Müller, [Regression models for compositional data: General log-contrast formulations, proximal optimization, and microbiome data applications](https://arxiv.org/abs/1903.01050), Statistics in Bioscience, 2020.* [6] A. Mishra and C. L. Müller, [Robust regression with compositional covariates](https://arxiv.org/abs/1909.04990), arXiv, 2019.* [7] S. Rosset and J. Zhu, [Piecewise linear regularized solution paths](https://projecteuclid.org/euclid.aos/1185303996), Ann. Stat., vol. 35, no. 3, pp. 1012–1030, 2007.* [8] J. Bien, X. Yan, L. Simpson, and C. L. Müller,   [Tree-Aggregated Predictive Modeling of Microbiome Data](https://www.biorxiv.org/content/10.1101/2020.09.01.277632v1), biorxiv, 2020.</longdescription>
</pkgmetadata>